From a4a8e15b2d58ad77780242bb4ab849f7dd3be392 Mon Sep 17 00:00:00 2001
From: Sum Yi Li <sum@lnxsrv07.seas.ucla.edu>
Date: Thu, 14 Mar 2019 19:41:41 -0700
Subject: [PATCH] 2019-03-14  Sum Yi Li  <sum@lnxsrv07.seas.ucla.edu>

	*maint: quote 'like this' or "like this", not `like this'
	Accroding to the *vc-diff* buffer, I have replaced the first character
	' with character ` for the following c extension files.
	src/analyze.c, src/cmp.c, src/context.c, src/diff.c, src/diff3.c,
	src/dir.c, src/ifdef.c,src/sdiff.c, src/side.c, src/util.c, src/io.c.

	For the rejected c extension files, I manually go into the two files
	which are src/diff.c and src/diff3.c to change the character ` to
	character '.
---
 ChangeLog                     |    12 +
 ChangeLog~                    |    11 +
 diffutils                     |     1 +
 diffutils-3.0-original        |     1 +
 diffutils-3.0-patch/analyze.c |   723 +++
 diffutils-3.0-patch/cmp.c     |   685 +++
 diffutils-3.0-patch/context.c |   493 ++
 diffutils-3.0-patch/diff.c    |  1330 ++++++
 diffutils-3.0-patch/diff3.c   |  1747 +++++++
 diffutils-3.0-patch/dir.c     |   283 ++
 diffutils-3.0-patch/ed.c      |   175 +
 diffutils-3.0-patch/ifdef.c   |   430 ++
 diffutils-3.0-patch/io.c      |   845 ++++
 diffutils-3.0-patch/normal.c  |    69 +
 diffutils-3.0-patch/sdiff.c   |  1236 +++++
 diffutils-3.0-patch/side.c    |   320 ++
 diffutils-3.0-patch/util.c    |   788 ++++
 diffutils-3.0/analyze.c       |   723 +++
 diffutils-3.0/cmp.c           |   685 +++
 diffutils-3.0/context.c       |   493 ++
 diffutils-3.0/diff.c          |  1330 ++++++
 diffutils-3.0/diff3.c         |  1747 +++++++
 diffutils-3.0/dir.c           |   283 ++
 diffutils-3.0/ed.c            |   175 +
 diffutils-3.0/ifdef.c         |   430 ++
 diffutils-3.0/io.c            |   845 ++++
 diffutils-3.0/normal.c        |    69 +
 diffutils-3.0/sdiff.c         |  1236 +++++
 diffutils-3.0/side.c          |   320 ++
 diffutils-3.0/util.c          |   788 ++++
 diffutils-gets.diff           |    11 +
 formatted-patch.txt           |     0
 git-log.txt                   | 10003 ++++++++++++++++++++++++++++++++++++++++
 git-tags.txt                  |    15 +
 quote-3.0-patch.txt           |   326 ++
 quote-3.0-test.txt            |   320 ++
 quote-patch.txt               |  1195 +++++
 37 files changed, 30143 insertions(+)
 create mode 100644 ChangeLog
 create mode 100644 ChangeLog~
 create mode 160000 diffutils
 create mode 160000 diffutils-3.0-original
 create mode 100644 diffutils-3.0-patch/analyze.c
 create mode 100644 diffutils-3.0-patch/cmp.c
 create mode 100644 diffutils-3.0-patch/context.c
 create mode 100644 diffutils-3.0-patch/diff.c
 create mode 100644 diffutils-3.0-patch/diff3.c
 create mode 100644 diffutils-3.0-patch/dir.c
 create mode 100644 diffutils-3.0-patch/ed.c
 create mode 100644 diffutils-3.0-patch/ifdef.c
 create mode 100644 diffutils-3.0-patch/io.c
 create mode 100644 diffutils-3.0-patch/normal.c
 create mode 100644 diffutils-3.0-patch/sdiff.c
 create mode 100644 diffutils-3.0-patch/side.c
 create mode 100644 diffutils-3.0-patch/util.c
 create mode 100644 diffutils-3.0/analyze.c
 create mode 100644 diffutils-3.0/cmp.c
 create mode 100644 diffutils-3.0/context.c
 create mode 100644 diffutils-3.0/diff.c
 create mode 100644 diffutils-3.0/diff3.c
 create mode 100644 diffutils-3.0/dir.c
 create mode 100644 diffutils-3.0/ed.c
 create mode 100644 diffutils-3.0/ifdef.c
 create mode 100644 diffutils-3.0/io.c
 create mode 100644 diffutils-3.0/normal.c
 create mode 100644 diffutils-3.0/sdiff.c
 create mode 100644 diffutils-3.0/side.c
 create mode 100644 diffutils-3.0/util.c
 create mode 100644 diffutils-gets.diff
 create mode 100644 formatted-patch.txt
 create mode 100644 git-log.txt
 create mode 100644 git-tags.txt
 create mode 100644 quote-3.0-patch.txt
 create mode 100644 quote-3.0-test.txt
 create mode 100644 quote-patch.txt

diff --git a/ChangeLog b/ChangeLog
new file mode 100644
index 0000000..af6db97
--- /dev/null
+++ b/ChangeLog
@@ -0,0 +1,12 @@
+2019-03-14  Sum Yi Li  <sum@lnxsrv07.seas.ucla.edu>
+
+	*maint: quote 'like this' or "like this", not `like this'
+	Accroding to the *vc-diff* buffer, I have replaced the first character
+	' with character ` for the following c extension files.
+	src/analyze.c, src/cmp.c, src/context.c, src/diff.c, src/diff3.c,
+	src/dir.c, src/ifdef.c,src/sdiff.c, src/side.c, src/util.c, src/io.c.
+
+	For the rejected c extension files, I manually go into the two files
+	which are src/diff.c and src/diff3.c to change the character ` to
+	character '.
+
diff --git a/ChangeLog~ b/ChangeLog~
new file mode 100644
index 0000000..334256c
--- /dev/null
+++ b/ChangeLog~
@@ -0,0 +1,11 @@
+2019-03-14  Sum Yi Li  <sum@lnxsrv07.seas.ucla.edu>
+
+	* Accroding to the *vc-diff* buffer, I have replaced the first character
+	' with character ` for the following c extension files.
+	src/analyze.c, src/cmp.c, src/context.c, src/diff.c, src/diff3.c,
+	src/dir.c, src/ifdef.c,src/sdiff.c, src/side.c, src/util.c, src/io.c.
+
+	For the rejected c extension files, I manually go into the two files
+	which are src/diff.c and src/diff3.c to change the character ` to
+	character '.
+
diff --git a/diffutils b/diffutils
new file mode 160000
index 0000000..022cd5c
--- /dev/null
+++ b/diffutils
@@ -0,0 +1 @@
+Subproject commit 022cd5c5eb647a22a4daa5fe5cbc10af6d5a1112
diff --git a/diffutils-3.0-original b/diffutils-3.0-original
new file mode 160000
index 0000000..022cd5c
--- /dev/null
+++ b/diffutils-3.0-original
@@ -0,0 +1 @@
+Subproject commit 022cd5c5eb647a22a4daa5fe5cbc10af6d5a1112
diff --git a/diffutils-3.0-patch/analyze.c b/diffutils-3.0-patch/analyze.c
new file mode 100644
index 0000000..e797248
--- /dev/null
+++ b/diffutils-3.0-patch/analyze.c
@@ -0,0 +1,723 @@
+/* Analyze file differences for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <error.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* The core of the Diff algorithm.  */
+#define ELEMENT lin
+#define EQUAL(x,y) ((x) == (y))
+#define OFFSET lin
+#define EXTRA_CONTEXT_FIELDS /* none */
+#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
+#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
+#define USE_HEURISTIC 1
+#include <diffseq.h>
+
+/* Discard lines from one file that have no matches in the other file.
+
+   A line which is discarded will not be considered by the actual
+   comparison algorithm; it will be as if that line were not in the file.
+   The file's `realindexes' table maps virtual line numbers
+   (which don't count the discarded lines) into real line numbers;
+   this is how the actual comparison algorithm produces results
+   that are comprehensible when the discarded lines are counted.
+
+   When we discard a line, we also mark it as a deletion or insertion
+   so that it will be printed in the output.  */
+
+static void
+discard_confusing_lines (struct file_data filevec[])
+{
+  int f;
+  lin i;
+  char *discarded[2];
+  lin *equiv_count[2];
+  lin *p;
+
+  /* Allocate our results.  */
+  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
+	       * (2 * sizeof *p));
+  for (f = 0; f < 2; f++)
+    {
+      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
+      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
+    }
+
+  /* Set up equiv_count[F][I] as the number of lines in file F
+     that fall in equivalence class I.  */
+
+  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
+  equiv_count[0] = p;
+  equiv_count[1] = p + filevec[0].equiv_max;
+
+  for (i = 0; i < filevec[0].buffered_lines; ++i)
+    ++equiv_count[0][filevec[0].equivs[i]];
+  for (i = 0; i < filevec[1].buffered_lines; ++i)
+    ++equiv_count[1][filevec[1].equivs[i]];
+
+  /* Set up tables of which lines are going to be discarded.  */
+
+  discarded[0] = zalloc (filevec[0].buffered_lines
+			 + filevec[1].buffered_lines);
+  discarded[1] = discarded[0] + filevec[0].buffered_lines;
+
+  /* Mark to be discarded each line that matches no line of the other file.
+     If a line matches many lines, mark it as provisionally discardable.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      size_t end = filevec[f].buffered_lines;
+      char *discards = discarded[f];
+      lin *counts = equiv_count[1 - f];
+      lin *equivs = filevec[f].equivs;
+      size_t many = 5;
+      size_t tem = end / 64;
+
+      /* Multiply MANY by approximate square root of number of lines.
+	 That is the threshold for provisionally discardable lines.  */
+      while ((tem = tem >> 2) > 0)
+	many *= 2;
+
+      for (i = 0; i < end; i++)
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
+    }
+
+  /* Don't really discard the provisional lines except when they occur
+     in a run of discardables, with nonprovisionals at the beginning
+     and end.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      lin end = filevec[f].buffered_lines;
+      register char *discards = discarded[f];
+
+      for (i = 0; i < end; i++)
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Actually discard the lines. */
+  for (f = 0; f < 2; f++)
+    {
+      char *discards = discarded[f];
+      lin end = filevec[f].buffered_lines;
+      lin j = 0;
+      for (i = 0; i < end; ++i)
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
+      filevec[f].nondiscarded_lines = j;
+    }
+
+  free (discarded[0]);
+  free (equiv_count[0]);
+}
+
+/* Adjust inserts/deletes of identical lines to join changes
+   as much as possible.
+
+   We do something when a run of changed lines include a
+   line at one end and have an excluded, identical line at the other.
+   We are free to choose which identical line is included.
+   `compareseq' usually chooses the one at the beginning,
+   but usually it is cleaner to consider the following identical line
+   to be the "change".  */
+
+static void
+shift_boundaries (struct file_data filevec[])
+{
+  int f;
+
+  for (f = 0; f < 2; f++)
+    {
+      char *changed = filevec[f].changed;
+      char *other_changed = filevec[1 - f].changed;
+      lin const *equivs = filevec[f].equivs;
+      lin i = 0;
+      lin j = 0;
+      lin i_end = filevec[f].buffered_lines;
+
+      while (1)
+	{
+	  lin runlength, start, corresponding;
+
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
+
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
+    }
+}
+
+/* Cons an additional entry onto the front of an edit script OLD.
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+static struct change *
+add_change (lin line0, lin line1, lin deleted, lin inserted,
+	    struct change *old)
+{
+  struct change *new = xmalloc (sizeof *new);
+
+  new->line0 = line0;
+  new->line1 = line1;
+  new->inserted = inserted;
+  new->deleted = deleted;
+  new->link = old;
+  return new;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in reverse order.  */
+
+static struct change *
+build_reverse_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin len0 = filevec[0].buffered_lines;
+  lin len1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[lenN] does exist, and is 0.  */
+
+  lin i0 = 0, i1 = 0;
+
+  while (i0 < len0 || i1 < len1)
+    {
+      if (changed0[i0] | changed1[i1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0++, i1++;
+    }
+
+  return script;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in forward order.  */
+
+static struct change *
+build_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[-1] does exist, and is 0.  */
+
+  while (i0 >= 0 || i1 >= 0)
+    {
+      if (changed0[i0 - 1] | changed1[i1 - 1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0--, i1--;
+    }
+
+  return script;
+}
+
+/* If CHANGES, briefly report that two files differed.
+   Return 2 if trouble, CHANGES otherwise.  */
+static int
+briefly_report (int changes, struct file_data const filevec[])
+{
+  if (changes)
+    {
+      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
+      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
+
+      if (brief)
+	message ("Files %s and %s differ\n", label0, label1);
+      else
+	{
+	  message ("Binary files %s and %s differ\n", label0, label1);
+	  changes = 2;
+	}
+    }
+
+  return changes;
+}
+
+/* Report the differences of two files.  */
+int
+diff_2_files (struct comparison *cmp)
+{
+  int f;
+  struct change *e, *p;
+  struct change *script;
+  int changes;
+
+
+  /* If we have detected that either file is binary,
+     compare the two files as binary.  This can happen
+     only when the first chunk is read.
+     Also, --brief without any --ignore-* options means
+     we can speed things up by treating the files as binary.  */
+
+  if (read_files (cmp->file, files_can_be_treated_as_binary))
+    {
+      /* Files with different lengths must be different.  */
+      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
+
+      /* Standard input equals itself.  */
+      else if (cmp->file[0].desc == cmp->file[1].desc)
+	changes = 0;
+
+      else
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
+
+      changes = briefly_report (changes, cmp->file);
+    }
+  else
+    {
+      struct context ctxt;
+      lin diags;
+      lin too_expensive;
+
+      /* Allocate vectors for the results of comparison:
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
+
+      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
+      char *flag_space = zalloc (s);
+      cmp->file[0].changed = flag_space + 1;
+      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
+
+      /* Some lines are obviously insertions or deletions
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
+
+      discard_confusing_lines (cmp->file);
+
+      /* Now do the main comparison algorithm, considering just the
+	 undiscarded lines.  */
+
+      ctxt.xvec = cmp->file[0].undiscarded;
+      ctxt.yvec = cmp->file[1].undiscarded;
+      diags = (cmp->file[0].nondiscarded_lines
+	       + cmp->file[1].nondiscarded_lines + 3);
+      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
+      ctxt.bdiag = ctxt.fdiag + diags;
+      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
+      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
+
+      ctxt.heuristic = speed_large_files;
+
+      /* Set TOO_EXPENSIVE to be approximate square root of input size,
+	 bounded below by 256.  */
+      too_expensive = 1;
+      for (;  diags != 0;  diags >>= 2)
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (256, too_expensive);
+
+      files[0] = cmp->file[0];
+      files[1] = cmp->file[1];
+
+      compareseq (0, cmp->file[0].nondiscarded_lines,
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+
+      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
+
+      /* Modify the results slightly to make them prettier
+	 in cases where that can validly be done.  */
+
+      shift_boundaries (cmp->file);
+
+      /* Get the results of comparison in the form of a chain
+	 of `struct change's -- an edit script.  */
+
+      if (output_style == OUTPUT_ED)
+	script = build_reverse_script (cmp->file);
+      else
+	script = build_script (cmp->file);
+
+      /* Set CHANGES if we had any diffs.
+	 If some changes are ignored, we must scan the script to decide.  */
+      if (ignore_blank_lines || ignore_regexp.fastmap)
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
+      else
+	changes = (script != 0);
+
+      if (brief)
+	changes = briefly_report (changes, cmp->file);
+      else
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
+
+      free (cmp->file[0].undiscarded);
+
+      free (flag_space);
+
+      for (f = 0; f < 2; f++)
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
+
+      for (e = script; e; e = p)
+	{
+	  p = e->link;
+	  free (e);
+	}
+
+      if (! ROBUST_OUTPUT_STYLE (output_style))
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
+    }
+
+  if (cmp->file[0].buffer != cmp->file[1].buffer)
+    free (cmp->file[0].buffer);
+  free (cmp->file[1].buffer);
+
+  return changes;
+}
diff --git a/diffutils-3.0-patch/cmp.c b/diffutils-3.0-patch/cmp.c
new file mode 100644
index 0000000..e19f013
--- /dev/null
+++ b/diffutils-3.0-patch/cmp.c
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+   using `buffer[0]' and `buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/diffutils-3.0-patch/context.c b/diffutils-3.0-patch/context.c
new file mode 100644
index 0000000..0be8cc5
--- /dev/null
+++ b/diffutils-3.0-patch/context.c
@@ -0,0 +1,493 @@
+/* Context-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "c-ctype.h"
+#include <inttostr.h>
+#include <stat-time.h>
+#include <strftime.h>
+
+static char const *find_function (char const * const *, lin);
+static struct change *find_hunk (struct change *);
+static void mark_ignorable (struct change *);
+static void pr_context_hunk (struct change *);
+static void pr_unidiff_hunk (struct change *);
+
+/* Last place find_function started searching from.  */
+static lin find_function_last_search;
+
+/* The value find_function returned when it started searching there.  */
+static lin find_function_last_match;
+
+/* Print a label for a context diff, with a file name and date or a label.  */
+
+static void
+print_context_label (char const *mark,
+		     struct file_data *inf,
+		     char const *label)
+{
+  if (label)
+    fprintf (outfile, "%s %s\n", mark, label);
+  else
+    {
+      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
+		    INT_STRLEN_BOUND (time_t) + 11)];
+      struct tm const *tm = localtime (&inf->stat.st_mtime);
+      int nsec = get_stat_mtime_ns (&inf->stat);
+      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
+    }
+}
+
+/* Print a header for a context diff, with the file names and dates.  */
+
+void
+print_context_header (struct file_data inf[], bool unidiff)
+{
+  if (unidiff)
+    {
+      print_context_label ("---", &inf[0], file_label[0]);
+      print_context_label ("+++", &inf[1], file_label[1]);
+    }
+  else
+    {
+      print_context_label ("***", &inf[0], file_label[0]);
+      print_context_label ("---", &inf[1], file_label[1]);
+    }
+}
+
+/* Print an edit script in context format.  */
+
+void
+print_context_script (struct change *script, bool unidiff)
+{
+  if (ignore_blank_lines || ignore_regexp.fastmap)
+    mark_ignorable (script);
+  else
+    {
+      struct change *e;
+      for (e = script; e; e = e->link)
+	e->ignore = false;
+    }
+
+  find_function_last_search = - files[0].prefix_lines;
+  find_function_last_match = LIN_MAX;
+
+  if (unidiff)
+    print_script (script, find_hunk, pr_unidiff_hunk);
+  else
+    print_script (script, find_hunk, pr_context_hunk);
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is not greater, use the first in place of it.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_context_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B <= A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.
+
+     POSIX 1003.1-2001 requires two line numbers separated by a comma
+     even if the line numbers are the same.  However, this does not
+     match existing practice and is surely an error in the
+     specification.  */
+
+  if (trans_b <= trans_a)
+    fprintf (outfile, "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
+}
+
+/* Print FUNCTION in a context header.  */
+static void
+print_context_function (FILE *out, char const *function)
+{
+  int i, j;
+  putc (' ', out);
+  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
+    continue;
+  for (j = i; j < i + 40 && function[j] != '\n'; j++)
+    continue;
+  while (i < j && c_isspace ((unsigned char) function[j - 1]))
+    j--;
+  fwrite (function + i, sizeof (char), j - i, out);
+}
+
+/* Print a portion of an edit script in context format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_context_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1, i;
+  char const *prefix;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (! changes)
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("***************", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  fputs ("\n*** ", out);
+  print_context_number_range (&files[0], first0, last0);
+  fputs (" ****\n", out);
+
+  if (changes & OLD)
+    {
+      struct change *next = hunk;
+
+      for (i = first0; i <= last0; i++)
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were inserted here in file 1, this is "changed".
+	       Otherwise it is "deleted".  */
+	    prefix = (next->inserted > 0 ? "!" : "-");
+
+	  print_1_line (prefix, &files[0].linbuf[i]);
+	}
+    }
+
+  fputs ("--- ", out);
+  print_context_number_range (&files[1], first1, last1);
+  fputs (" ----\n", out);
+
+  if (changes & NEW)
+    {
+      struct change *next = hunk;
+
+      for (i = first1; i <= last1; i++)
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were deleted here in file 0, this is "changed".
+	       Otherwise it is "inserted".  */
+	    prefix = (next->deleted > 0 ? "!" : "+");
+
+	  print_1_line (prefix, &files[1].linbuf[i]);
+	}
+    }
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is smaller, use the first in place of it.
+   If the numbers are equal, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B < A in the case of a range of no lines.
+     In this case, we print the line number before the range,
+     which is B.  It would be more logical to print A, but
+     'patch' expects B in order to detect diffs against empty files.  */
+  if (trans_b <= trans_a)
+    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
+}
+
+/* Print a portion of an edit script in unidiff format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_unidiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  lin i, j, k;
+  struct change *next;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("@@ -", out);
+  print_unidiff_number_range (&files[0], first0, last0);
+  fputs (" +", out);
+  print_unidiff_number_range (&files[1], first1, last1);
+  fputs (" @@", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+
+  next = hunk;
+  i = first0;
+  j = first1;
+
+  while (i <= last0 || j <= last1)
+    {
+
+      /* If the line isn't a difference, output the context from file 0. */
+
+      if (!next || i < next->line0)
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
+      else
+	{
+	  /* For each difference, first output the deleted part. */
+
+	  k = next->deleted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* We're done with this hunk, so on to the next! */
+
+	  next = next->link;
+	}
+    }
+}
+
+/* Scan a (forward-ordered) edit script for the first place that more than
+   2*CONTEXT unchanged lines appear, and return a pointer
+   to the `struct change' for the last change before those lines.  */
+
+static struct change *
+find_hunk (struct change *start)
+{
+  struct change *prev;
+  lin top0, top1;
+  lin thresh;
+
+  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
+     changes, but only CONTEXT if one is ignorable.  Watch out for
+     integer overflow, though.  */
+  lin non_ignorable_threshold =
+    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
+  lin ignorable_threshold = context;
+
+  do
+    {
+      /* Compute number of first line in each file beyond this changed.  */
+      top0 = start->line0 + start->deleted;
+      top1 = start->line1 + start->inserted;
+      prev = start;
+      start = start->link;
+      thresh = (prev->ignore || (start && start->ignore)
+		? ignorable_threshold
+		: non_ignorable_threshold);
+      /* It is not supposed to matter which file we check in the end-test.
+	 If it would matter, crash.  */
+      if (start && start->line0 - top0 != start->line1 - top1)
+	abort ();
+    } while (start
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
+
+  return prev;
+}
+
+/* Set the `ignore' flag properly in each change in SCRIPT.
+   It should be 1 if all the lines inserted or deleted in that change
+   are ignorable lines.  */
+
+static void
+mark_ignorable (struct change *script)
+{
+  while (script)
+    {
+      struct change *next = script->link;
+      lin first0, last0, first1, last1;
+
+      /* Turn this change into a hunk: detach it from the others.  */
+      script->link = NULL;
+
+      /* Determine whether this change is ignorable.  */
+      script->ignore = ! analyze_hunk (script,
+				       &first0, &last0, &first1, &last1);
+
+      /* Reconnect the chain as before.  */
+      script->link = next;
+
+      /* Advance to the following change.  */
+      script = next;
+    }
+}
+
+/* Find the last function-header line in LINBUF prior to line number LINENUM.
+   This is a line containing a match for the regexp in `function_regexp'.
+   Return the address of the text, or NULL if no function-header is found.  */
+
+static char const *
+find_function (char const * const *linbuf, lin linenum)
+{
+  lin i = linenum;
+  lin last = find_function_last_search;
+  find_function_last_search = i;
+
+  while (last <= --i)
+    {
+      /* See if this line is what we want.  */
+      char const *line = linbuf[i];
+      size_t linelen = linbuf[i + 1] - line - 1;
+
+      /* FIXME: re_search's size args should be size_t, not int.  */
+      int len = MIN (linelen, INT_MAX);
+
+      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
+    }
+  /* If we search back to where we started searching the previous time,
+     find the line we found last time.  */
+  if (find_function_last_match != LIN_MAX)
+    return linbuf[find_function_last_match];
+
+  return NULL;
+}
diff --git a/diffutils-3.0-patch/diff.c b/diffutils-3.0-patch/diff.c
new file mode 100644
index 0000000..256a984
--- /dev/null
+++ b/diffutils-3.0-patch/diff.c
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in `regexps' */
+  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then `patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then `patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/diffutils-3.0-patch/diff3.c b/diffutils-3.0-patch/diff3.c
new file mode 100644
index 0000000..fbfb28b
--- /dev/null
+++ b/diffutils-3.0-patch/diff3.c
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include `:wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in `output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/diffutils-3.0-patch/dir.c b/diffutils-3.0-patch/dir.c
new file mode 100644
index 0000000..5e08318
--- /dev/null
+++ b/diffutils-3.0-patch/dir.c
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the `names' table from the `data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If `-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/diffutils-3.0-patch/ed.c b/diffutils-3.0-patch/ed.c
new file mode 100644
index 0000000..08acf50
--- /dev/null
+++ b/diffutils-3.0-patch/ed.c
@@ -0,0 +1,175 @@
+/* Output routines for ed-script format.
+
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_ed_hunk (struct change *);
+static void print_rcs_hunk (struct change *);
+static void pr_forward_ed_hunk (struct change *);
+
+/* Print our script as ed commands.  */
+
+void
+print_ed_script (struct change *script)
+{
+  print_script (script, find_reverse_change, print_ed_hunk);
+}
+
+/* Print a hunk of an ed diff */
+
+static void
+print_ed_hunk (struct change *hunk)
+{
+  lin f0, l0, f1, l1;
+  enum changes changes;
+
+#ifdef DEBUG
+  debug_script (hunk);
+#endif
+
+  /* Determine range of line numbers involved in each file.  */
+  changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], f0, l0);
+  fputc (change_letter[changes], outfile);
+  fputc ('\n', outfile);
+
+  /* Print new/changed lines from second file, if needed */
+  if (changes != OLD)
+    {
+      lin i;
+      bool insert_mode = true;
+
+      for (i = f1; i <= l1; i++)
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
+
+      if (insert_mode)
+	fputs (".\n", outfile);
+    }
+}
+
+/* Print change script in the style of ed commands,
+   but print the changes in the order they appear in the input files,
+   which means that the commands are not truly useful with ed.
+   Because of the issue with lines containing just a dot, the output
+   is not even parseable.  */
+
+void
+pr_forward_ed_script (struct change *script)
+{
+  print_script (script, find_change, pr_forward_ed_hunk);
+}
+
+static void
+pr_forward_ed_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  fputc (change_letter[changes], outfile);
+  print_number_range (' ', files, f0, l0);
+  fputc ('\n', outfile);
+
+  /* If deletion only, print just the number range.  */
+
+  if (changes == OLD)
+    return;
+
+  /* For insertion (with or without deletion), print the number range
+     and the lines from file 2.  */
+
+  for (i = f1; i <= l1; i++)
+    print_1_line ("", &files[1].linbuf[i]);
+
+  fputs (".\n", outfile);
+}
+
+/* Print in a format somewhat like ed commands
+   except that each insert command states the number of lines it inserts.
+   This format is used for RCS.  */
+
+void
+print_rcs_script (struct change *script)
+{
+  print_script (script, find_change, print_rcs_hunk);
+}
+
+/* Print a hunk of an RCS diff */
+
+static void
+print_rcs_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+  long int tf0, tl0, tf1, tl1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  translate_range (&files[0], f0, l0, &tf0, &tl0);
+
+  if (changes & OLD)
+    {
+      /* For deletion, print just the starting line number from file 0
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+    }
+
+  if (changes & NEW)
+    {
+      /* Take last-line-number from file 0 and # lines from file 1.  */
+      translate_range (&files[1], f1, l1, &tf1, &tl1);
+      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+
+      /* Print the inserted lines.  */
+      for (i = f1; i <= l1; i++)
+	print_1_line ("", &files[1].linbuf[i]);
+    }
+}
diff --git a/diffutils-3.0-patch/ifdef.c b/diffutils-3.0-patch/ifdef.c
new file mode 100644
index 0000000..a48f830
--- /dev/null
+++ b/diffutils-3.0-patch/ifdef.c
@@ -0,0 +1,430 @@
+/* #ifdef-format output routines for GNU DIFF.
+
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <xalloc.h>
+
+struct group
+{
+  struct file_data const *file;
+  lin from, upto; /* start and limit lines for this group of lines */
+};
+
+static char const *format_group (FILE *, char const *, char,
+				 struct group const *);
+static char const *do_printf_spec (FILE *, char const *,
+				   struct file_data const *, lin,
+				   struct group const *);
+static char const *scan_char_literal (char const *, char *);
+static lin groups_letter_value (struct group const *, char);
+static void format_ifdef (char const *, lin, lin, lin, lin);
+static void print_ifdef_hunk (struct change *);
+static void print_ifdef_lines (FILE *, char const *, struct group const *);
+
+static lin next_line0;
+static lin next_line1;
+
+/* Print the edit-script SCRIPT as a merged #ifdef file.  */
+
+void
+print_ifdef_script (struct change *script)
+{
+  next_line0 = next_line1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_ifdef_hunk);
+  if (next_line0 < files[0].valid_lines
+      || next_line1 < files[1].valid_lines)
+    {
+      begin_output ();
+      format_ifdef (group_format[UNCHANGED],
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
+    }
+}
+
+/* Print a hunk of an ifdef diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_ifdef_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print lines up to this change.  */
+  if (next_line0 < first0 || next_line1 < first1)
+    format_ifdef (group_format[UNCHANGED],
+		  next_line0, first0,
+		  next_line1, first1);
+
+  /* Print this change.  */
+  next_line0 = last0 + 1;
+  next_line1 = last1 + 1;
+  format_ifdef (group_format[changes],
+		first0, next_line0,
+		first1, next_line1);
+}
+
+/* Print a set of lines according to FORMAT.
+   Lines BEG0 up to END0 are from the first file;
+   lines BEG1 up to END1 are from the second file.  */
+
+static void
+format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
+{
+  struct group groups[2];
+
+  groups[0].file = &files[0];
+  groups[0].from = beg0;
+  groups[0].upto = end0;
+  groups[1].file = &files[1];
+  groups[1].from = beg1;
+  groups[1].upto = end1;
+  format_group (outfile, format, 0, groups);
+}
+
+/* Print to file OUT a set of lines according to FORMAT.
+   The format ends at the first free instance of ENDCHAR.
+   Yield the address of the terminating character.
+   GROUPS specifies which lines to print.
+   If OUT is zero, do not actually print anything; just scan the format.  */
+
+static char const *
+format_group (register FILE *out, char const *format, char endchar,
+	      struct group const *groups)
+{
+  register char c;
+  register char const *f = format;
+
+  while ((c = *f) != endchar && c != 0)
+    {
+      char const *f1 = ++f;
+      if (c == '%')
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
+
+      if (out)
+	putc (c, out);
+    }
+
+  return f;
+}
+
+/* For the line group pair G, return the number corresponding to LETTER.
+   Return -1 if LETTER is not a group format letter.  */
+static lin
+groups_letter_value (struct group const *g, char letter)
+{
+  switch (letter)
+    {
+    case 'E': letter = 'e'; g++; break;
+    case 'F': letter = 'f'; g++; break;
+    case 'L': letter = 'l'; g++; break;
+    case 'M': letter = 'm'; g++; break;
+    case 'N': letter = 'n'; g++; break;
+    }
+
+  switch (letter)
+    {
+      case 'e': return translate_line_number (g->file, g->from) - 1;
+      case 'f': return translate_line_number (g->file, g->from);
+      case 'l': return translate_line_number (g->file, g->upto) - 1;
+      case 'm': return translate_line_number (g->file, g->upto);
+      case 'n': return g->upto - g->from;
+      default: return -1;
+    }
+}
+
+/* Print to file OUT, using FORMAT to print the line group GROUP.
+   But do nothing if OUT is zero.  */
+static void
+print_ifdef_lines (register FILE *out, char const *format,
+		   struct group const *group)
+{
+  struct file_data const *file = group->file;
+  char const * const *linbuf = file->linbuf;
+  lin from = group->from, upto = group->upto;
+
+  if (!out)
+    return;
+
+  /* If possible, use a single fwrite; it's faster.  */
+  if (!expand_tabs && format[0] == '%')
+    {
+      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
+      if (format[1] == 'L' && !format[2])
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
+    }
+
+  for (;  from < upto;  from++)
+    {
+      register char c;
+      register char const *f = format;
+
+      while ((c = *f++) != 0)
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
+
+	  putc (c, out);
+	}
+    }
+}
+
+static char const *
+do_printf_spec (FILE *out, char const *spec,
+		struct file_data const *file, lin n,
+		struct group const *groups)
+{
+  char const *f = spec;
+  char c;
+  char c1;
+
+  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
+  /* assert (*f == '%'); */
+  f++;
+  while ((c = *f++) == '-' || c == '\'' || c == '0')
+    continue;
+  while (ISDIGIT (c))
+    c = *f++;
+  if (c == '.')
+    while (ISDIGIT (c = *f++))
+      continue;
+  c1 = *f++;
+
+  switch (c)
+    {
+    case 'c':
+      if (c1 != '\'')
+	return 0;
+      else
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
+      break;
+
+    case 'd': case 'o': case 'x': case 'X':
+      {
+	lin value;
+
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    long int long_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+#if HAVE_C_VARARRAYS
+	    char format[spec_prefix_len + 3];
+#else
+	    char *format = xmalloc (spec_prefix_len + 3);
+#endif
+	    char *p = format + spec_prefix_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    *p++ = 'l';
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, long_value);
+#if ! HAVE_C_VARARRAYS
+	    free (format);
+#endif
+	  }
+      }
+      break;
+
+    default:
+      return 0;
+    }
+
+  return f;
+}
+
+/* Scan the character literal represented in the string LIT; LIT points just
+   after the initial apostrophe.  Put the literal's value into *VALPTR.
+   Yield the address of the first character after the closing apostrophe,
+   or a null pointer if the literal is ill-formed.  */
+static char const *
+scan_char_literal (char const *lit, char *valptr)
+{
+  register char const *p = lit;
+  char value;
+  ptrdiff_t digits;
+  char c = *p++;
+
+  switch (c)
+    {
+      case 0:
+      case '\'':
+	return NULL;
+
+      case '\\':
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
+
+      default:
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
+    }
+
+  *valptr = value;
+  return p;
+}
diff --git a/diffutils-3.0-patch/io.c b/diffutils-3.0-patch/io.c
new file mode 100644
index 0000000..031be3d
--- /dev/null
+++ b/diffutils-3.0-patch/io.c
@@ -0,0 +1,845 @@
+/* File I/O for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* Rotate an unsigned value to the left.  */
+#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
+
+/* Given a hash value and a new character, return a new hash value.  */
+#define HASH(h, c) ((c) + ROL (h, 7))
+
+/* The type of a hash value.  */
+typedef size_t hash_value;
+verify (! TYPE_SIGNED (hash_value));
+
+/* Lines are put into equivalence classes of lines that match in lines_differ.
+   Each equivalence class is represented by one of these structures,
+   but only while the classes are being computed.
+   Afterward, each class is represented by a number.  */
+struct equivclass
+{
+  lin next;		/* Next item in this bucket.  */
+  hash_value hash;	/* Hash of lines in this class.  */
+  char const *line;	/* A line that fits this class.  */
+  size_t length;	/* That line's length, not counting its newline.  */
+};
+
+/* Hash-table: array of buckets, each being a chain of equivalence classes.
+   buckets[-1] is reserved for incomplete lines.  */
+static lin *buckets;
+
+/* Number of buckets in the hash table array, not counting buckets[-1].  */
+static size_t nbuckets;
+
+/* Array in which the equivalence classes are allocated.
+   The bucket-chains go through the elements in this array.
+   The number of an equivalence class is its index in this array.  */
+static struct equivclass *equivs;
+
+/* Index of first free element in the array `equivs'.  */
+static lin equivs_index;
+
+/* Number of elements allocated in the array `equivs'.  */
+static lin equivs_alloc;
+
+/* Read a block of data into a file buffer, checking for EOF and error.  */
+
+void
+file_block_read (struct file_data *current, size_t size)
+{
+  if (size && ! current->eof)
+    {
+      size_t s = block_read (current->desc,
+			     FILE_BUFFER (current) + current->buffered, size);
+      if (s == SIZE_MAX)
+	pfatal_with_name (current->name);
+      current->buffered += s;
+      current->eof = s < size;
+    }
+}
+
+/* Check for binary files and compare them for exact identity.  */
+
+/* Return 1 if BUF contains a non text character.
+   SIZE is the number of characters in BUF.  */
+
+#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
+
+/* Get ready to read the current file.
+   Return nonzero if SKIP_TEST is zero,
+   and if it appears to be a binary file.  */
+
+static bool
+sip (struct file_data *current, bool skip_test)
+{
+  /* If we have a nonexistent file at this stage, treat it as empty.  */
+  if (current->desc < 0)
+    {
+      /* Leave room for a sentinel.  */
+      current->bufsize = sizeof (word);
+      current->buffer = xmalloc (current->bufsize);
+    }
+  else
+    {
+      current->bufsize = buffer_lcm (sizeof (word),
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
+      current->buffer = xmalloc (current->bufsize);
+
+      if (! skip_test)
+	{
+	  /* Check first part of file to see if it's a binary file.  */
+
+	  /* FIXME: if O_BINARY, this should revert to text mode
+	     if the file is not binary.  */
+
+	  file_block_read (current, current->bufsize);
+	  return binary_file_p (current->buffer, current->buffered);
+	}
+    }
+
+  current->buffered = 0;
+  current->eof = false;
+  return false;
+}
+
+/* Slurp the rest of the current file completely into memory.  */
+
+static void
+slurp (struct file_data *current)
+{
+  size_t cc;
+
+  if (current->desc < 0)
+    {
+      /* The file is nonexistent.  */
+      return;
+    }
+
+  if (S_ISREG (current->stat.st_mode))
+    {
+      /* It's a regular file; slurp in the rest all at once.  */
+
+      /* Get the size out of the stat block.
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
+      size_t file_size = current->stat.st_size;
+      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
+      if (file_size != current->stat.st_size || cc < file_size
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
+
+      if (current->bufsize < cc)
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
+
+      /* Try to read at least 1 more byte than the size indicates, to
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
+
+      if (current->buffered <= file_size)
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
+    }
+
+  /* It's not a regular file, or it's a growing regular file; read it,
+     growing the buffer as needed.  */
+
+  file_block_read (current, current->bufsize - current->buffered);
+
+  if (current->buffered)
+    {
+      while (current->buffered == current->bufsize)
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
+
+      /* Allocate just enough room for appended newline plus word
+	 sentinel, plus word-alignment.  */
+      cc = current->buffered + 2 * sizeof (word);
+      current->bufsize = cc - cc % sizeof (word);
+      current->buffer = xrealloc (current->buffer, current->bufsize);
+    }
+}
+
+/* Split the file into lines, simultaneously computing the equivalence
+   class for each line.  */
+
+static void
+find_and_hash_each_line (struct file_data *current)
+{
+  hash_value h;
+  char const *p = current->prefix_end;
+  unsigned char c;
+  lin i, *bucket;
+  size_t length;
+
+  /* Cache often-used quantities in local variables to help the compiler.  */
+  char const **linbuf = current->linbuf;
+  lin alloc_lines = current->alloc_lines;
+  lin line = 0;
+  lin linbuf_base = current->linbuf_base;
+  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
+  struct equivclass *eqs = equivs;
+  lin eqs_index = equivs_index;
+  lin eqs_alloc = equivs_alloc;
+  char const *suffix_begin = current->suffix_begin;
+  char const *bufend = FILE_BUFFER (current) + current->buffered;
+  bool diff_length_compare_anyway =
+    ignore_white_space != IGNORE_NO_WHITE_SPACE;
+  bool same_length_diff_contents_compare_anyway =
+    diff_length_compare_anyway | ignore_case;
+
+  while (p < suffix_begin)
+    {
+      char const *ip = p;
+
+      h = 0;
+
+      /* Hash this line until we find a newline.  */
+      if (ignore_case)
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, tolower (c));
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, tolower (c));
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      c = tolower (c);
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	    break;
+	  }
+      else
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, c);
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, c);
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	    break;
+	  }
+
+   hashing_done:;
+
+      bucket = &buckets[h % nbuckets];
+      length = p - ip - 1;
+
+      if (p == bufend
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    bucket = &buckets[-1];
+	}
+
+      for (i = *bucket;  ;  i = eqs[i].next)
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
+
+	    /* Reuse existing class if lines_differ reports the lines
+               equal.  */
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
+
+      /* Maybe increase the size of the line table.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = ip;
+      cureqs[line] = i;
+      ++line;
+    }
+
+  current->buffered_lines = line;
+
+  for (i = 0;  ;  i++)
+    {
+      /* Record the line start for lines in the suffix that we care about.
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = p;
+
+      if (p == bufend)
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
+
+      if (context <= i && no_diff_means_no_output)
+	break;
+
+      line++;
+
+      while (*p++ != '\n')
+	continue;
+    }
+
+  /* Done with cache in local variables.  */
+  current->linbuf = linbuf;
+  current->valid_lines = line;
+  current->alloc_lines = alloc_lines;
+  current->equivs = cureqs;
+  equivs = eqs;
+  equivs_alloc = eqs_alloc;
+  equivs_index = eqs_index;
+}
+
+/* Prepare the text.  Make sure the text end is initialized.
+   Make sure text ends in a newline,
+   but remember that we had to add one.
+   Strip trailing CRs, if that was requested.  */
+
+static void
+prepare_text (struct file_data *current)
+{
+  size_t buffered = current->buffered;
+  char *p = FILE_BUFFER (current);
+  char *dst;
+
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
+    {
+      p[buffered++] = '\n';
+      current->missing_newline = true;
+    }
+
+  if (!p)
+    return;
+
+  /* Don't use uninitialized storage when planting or using sentinels.  */
+  memset (p + buffered, 0, sizeof (word));
+
+  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+    {
+      char const *src = dst;
+      char const *srclim = p + buffered;
+
+      do
+	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
+      while (src < srclim);
+
+      buffered -= src - dst;
+    }
+
+  current->buffered = buffered;
+}
+
+/* We have found N lines in a buffer of size S; guess the
+   proportionate number of lines that will be found in a buffer of
+   size T.  However, do not guess a number of lines so large that the
+   resulting line table might cause overflow in size calculations.  */
+static lin
+guess_lines (lin n, size_t s, size_t t)
+{
+  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
+  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
+  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
+}
+
+/* Given a vector of two file_data objects, find the identical
+   prefixes and suffixes of each object.  */
+
+static void
+find_identical_ends (struct file_data filevec[])
+{
+  word *w0, *w1;
+  char *p0, *p1, *buffer0, *buffer1;
+  char const *end0, *beg0;
+  char const **linbuf0, **linbuf1;
+  lin i, lines;
+  size_t n0, n1;
+  lin alloc_lines0, alloc_lines1;
+  lin buffered_prefix, prefix_count, prefix_mask;
+  lin middle_guess, suffix_guess;
+
+  slurp (&filevec[0]);
+  prepare_text (&filevec[0]);
+  if (filevec[0].desc != filevec[1].desc)
+    {
+      slurp (&filevec[1]);
+      prepare_text (&filevec[1]);
+    }
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+      filevec[1].missing_newline = filevec[0].missing_newline;
+    }
+
+  /* Find identical prefix.  */
+
+  w0 = filevec[0].buffer;
+  w1 = filevec[1].buffer;
+  p0 = buffer0 = (char *) w0;
+  p1 = buffer1 = (char *) w1;
+  n0 = filevec[0].buffered;
+  n1 = filevec[1].buffered;
+
+  if (p0 == p1)
+    /* The buffers are the same; sentinels won't work.  */
+    p0 = p1 += n1;
+  else
+    {
+      /* Insert end sentinels, in this case characters that are guaranteed
+	 to make the equality test false, and thus terminate the loop.  */
+
+      if (n0 < n1)
+	p0[n0] = ~p1[n0];
+      else
+	p1[n1] = ~p0[n1];
+
+      /* Loop until first mismatch, or to the sentinel characters.  */
+
+      /* Compare a word at a time for speed.  */
+      while (*w0 == *w1)
+	w0++, w1++;
+
+      /* Do the last few bytes of comparison a byte at a time.  */
+      p0 = (char *) w0;
+      p1 = (char *) w1;
+      while (*p0 == *p1)
+	p0++, p1++;
+
+      /* Don't mistakenly count missing newline as part of prefix.  */
+      if (ROBUST_OUTPUT_STYLE (output_style)
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
+    }
+
+  /* Now P0 and P1 point at the first nonmatching characters.  */
+
+  /* Skip back to last line-beginning in the prefix,
+     and then discard up to HORIZON_LINES lines from the prefix.  */
+  i = horizon_lines;
+  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
+    p0--, p1--;
+
+  /* Record the prefix.  */
+  filevec[0].prefix_end = p0;
+  filevec[1].prefix_end = p1;
+
+  /* Find identical suffix.  */
+
+  /* P0 and P1 point beyond the last chars not yet compared.  */
+  p0 = buffer0 + n0;
+  p1 = buffer1 + n1;
+
+  if (! ROBUST_OUTPUT_STYLE (output_style)
+      || filevec[0].missing_newline == filevec[1].missing_newline)
+    {
+      end0 = p0;	/* Addr of last char in file 0.  */
+
+      /* Get value of P0 at which we should stop scanning backward:
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
+      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
+
+      /* Scan back until chars don't match or we reach that point.  */
+      while (p0 != beg0)
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
+
+      /* Are we at a line-beginning in both files?  If not, add the rest of
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
+      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
+      while (i-- && p0 != end0)
+	while (*p0++ != '\n')
+	  continue;
+
+      p1 += p0 - beg0;
+    }
+
+  /* Record the suffix.  */
+  filevec[0].suffix_begin = p0;
+  filevec[1].suffix_begin = p1;
+
+  /* Calculate number of lines of prefix to save.
+
+     prefix_count == 0 means save the whole prefix;
+     we need this for options like -D that output the whole file,
+     or for enormous contexts (to avoid worrying about arithmetic overflow).
+     We also need it for options like -F that output some preceding line;
+     at least we will need to find the last few lines,
+     but since we don't know how many, it's easiest to find them all.
+
+     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
+     of the line buffer; they'll be moved to the proper location later.
+     Handle 1 more line than the context says (because we count 1 too many),
+     rounded up to the next power of 2 to speed index computation.  */
+
+  if (no_diff_means_no_output && ! function_regexp.fastmap
+      && context < LIN_MAX / 4 && context < n0)
+    {
+      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
+      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
+      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
+	continue;
+      alloc_lines0 = (prefix_count + middle_guess
+		      + MIN (context, suffix_guess));
+    }
+  else
+    {
+      prefix_count = 0;
+      alloc_lines0 = guess_lines (0, 0, n0);
+    }
+
+  prefix_mask = prefix_count - 1;
+  lines = 0;
+  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+  p0 = buffer0;
+
+  /* If the prefix is needed, find the prefix lines.  */
+  if (! (no_diff_means_no_output
+	 && filevec[0].prefix_end == p0
+	 && filevec[1].prefix_end == p1))
+    {
+      end0 = filevec[0].prefix_end;
+      while (p0 != end0)
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
+    }
+  buffered_prefix = prefix_count && context < lines ? context : lines;
+
+  /* Allocate line buffer 1.  */
+
+  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
+  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
+  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
+  if (alloc_lines1 < buffered_prefix
+      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
+    xalloc_die ();
+  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
+
+  if (buffered_prefix != lines)
+    {
+      /* Rotate prefix lines to proper location.  */
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf0[i] = linbuf1[i];
+    }
+
+  /* Initialize line buffer 1 from line buffer 0.  */
+  for (i = 0; i < buffered_prefix; i++)
+    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
+
+  /* Record the line buffer, adjusted so that
+     linbuf[0] points at the first differing line.  */
+  filevec[0].linbuf = linbuf0 + buffered_prefix;
+  filevec[1].linbuf = linbuf1 + buffered_prefix;
+  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
+  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
+  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
+  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
+}
+
+/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
+   than 2**k.  This table is derived from Chris K. Caldwell's list
+   <http://www.utm.edu/research/primes/lists/2small/>.  */
+
+static unsigned char const prime_offset[] =
+{
+  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
+  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
+  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
+  55, 93, 1, 57, 25
+};
+
+/* Verify that this host's size_t is not too wide for the above table.  */
+
+verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
+
+/* Given a vector of two file_data objects, read the file associated
+   with each one, and build the table of equivalence classes.
+   Return nonzero if either file appears to be a binary file.
+   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
+
+bool
+read_files (struct file_data filevec[], bool pretend_binary)
+{
+  int i;
+  bool skip_test = text | pretend_binary;
+  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
+
+  if (filevec[0].desc != filevec[1].desc)
+    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+    }
+  if (appears_binary)
+    {
+      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
+      return true;
+    }
+
+  find_identical_ends (filevec);
+
+  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
+  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
+    xalloc_die ();
+  equivs = xmalloc (equivs_alloc * sizeof *equivs);
+  /* Equivalence class 0 is permanently safe for lines that were not
+     hashed.  Real equivalence classes start at 1.  */
+  equivs_index = 1;
+
+  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
+     number between 1/3 and 2/3 of the value of equiv_allocs,
+     approximately.  */
+  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
+    continue;
+  nbuckets = ((size_t) 1 << i) - prime_offset[i];
+  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
+    xalloc_die ();
+  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
+  buckets++;
+
+  for (i = 0; i < 2; i++)
+    find_and_hash_each_line (&filevec[i]);
+
+  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
+
+  free (equivs);
+  free (buckets - 1);
+
+  return false;
+}
diff --git a/diffutils-3.0-patch/normal.c b/diffutils-3.0-patch/normal.c
new file mode 100644
index 0000000..154efaa
--- /dev/null
+++ b/diffutils-3.0-patch/normal.c
@@ -0,0 +1,69 @@
+/* Normal-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_normal_hunk (struct change *);
+
+/* Print the edit-script SCRIPT as a normal diff.
+   INF points to an array of descriptions of the two files.  */
+
+void
+print_normal_script (struct change *script)
+{
+  print_script (script, find_change, print_normal_hunk);
+}
+
+/* Print a hunk of a normal diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_normal_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], first0, last0);
+  fputc (change_letter[changes], outfile);
+  print_number_range (',', &files[1], first1, last1);
+  fputc ('\n', outfile);
+
+  /* Print the lines that the first file has.  */
+  if (changes & OLD)
+    for (i = first0; i <= last0; i++)
+      print_1_line ("<", &files[0].linbuf[i]);
+
+  if (changes == CHANGED)
+    fputs ("---\n", outfile);
+
+  /* Print the lines that the second file has.  */
+  if (changes & NEW)
+    for (i = first1; i <= last1; i++)
+      print_1_line (">", &files[1].linbuf[i]);
+}
diff --git a/diffutils-3.0-patch/sdiff.c b/diffutils-3.0-patch/sdiff.c
new file mode 100644
index 0000000..5bbecd8
--- /dev/null
+++ b/diffutils-3.0-patch/sdiff.c
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/diffutils-3.0-patch/side.c b/diffutils-3.0-patch/side.c
new file mode 100644
index 0000000..6aa96a9
--- /dev/null
+++ b/diffutils-3.0-patch/side.c
@@ -0,0 +1,320 @@
+/* sdiff-format output routines for GNU DIFF.
+
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
+   Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <wchar.h>
+
+static void print_sdiff_common_lines (lin, lin);
+static void print_sdiff_hunk (struct change *);
+
+/* Next line number to be printed in the two input files.  */
+static lin next0, next1;
+
+/* Print the edit-script SCRIPT as a sdiff style output.  */
+
+void
+print_sdiff_script (struct change *script)
+{
+  begin_output ();
+
+  next0 = next1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_sdiff_hunk);
+
+  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
+}
+
+/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
+
+static size_t
+tab_from_to (size_t from, size_t to)
+{
+  FILE *out = outfile;
+  size_t tab;
+  size_t tab_size = tabsize;
+
+  if (!expand_tabs)
+    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
+      {
+	putc ('\t', out);
+	from = tab;
+      }
+  while (from++ < to)
+    putc (' ', out);
+  return to;
+}
+
+/* Print the text for half an sdiff line.  This means truncate to
+   width observing tabs, and trim a trailing newline.  Return the
+   last column written (not the number of chars).  */
+
+static size_t
+print_half_line (char const *const *line, size_t indent, size_t out_bound)
+{
+  FILE *out = outfile;
+  register size_t in_position = 0;
+  register size_t out_position = 0;
+  register char const *text_pointer = line[0];
+  register char const *text_limit = line[1];
+  mbstate_t mbstate = { 0 };
+
+  while (text_pointer < text_limit)
+    {
+      char const *tp0 = text_pointer;
+      register char c = *text_pointer++;
+
+      switch (c)
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  /* Fall through.  */
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
+    }
+
+  return out_position;
+}
+
+/* Print side by side lines with a separator in the middle.
+   0 parameters are taken to indicate white space text.
+   Blank lines that can easily be caught are reduced to a single newline.  */
+
+static void
+print_1sdiff_line (char const *const *left, char sep,
+		   char const *const *right)
+{
+  FILE *out = outfile;
+  size_t hw = sdiff_half_width;
+  size_t c2o = sdiff_column2_offset;
+  size_t col = 0;
+  bool put_newline = false;
+
+  if (left)
+    {
+      put_newline |= left[1][-1] == '\n';
+      col = print_half_line (left, 0, hw);
+    }
+
+  if (sep != ' ')
+    {
+      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
+      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
+	sep = put_newline ? '/' : '\\';
+      putc (sep, out);
+    }
+
+  if (right)
+    {
+      put_newline |= right[1][-1] == '\n';
+      if (**right != '\n')
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
+    }
+
+  if (put_newline)
+    putc ('\n', out);
+}
+
+/* Print lines common to both files in side-by-side format.  */
+static void
+print_sdiff_common_lines (lin limit0, lin limit1)
+{
+  lin i0 = next0, i1 = next1;
+
+  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
+    {
+      if (sdiff_merge_assist)
+	{
+	  long int len0 = limit0 - i0;
+	  long int len1 = limit1 - i1;
+	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+	}
+
+      if (!left_column)
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
+      while (i0 != limit0)
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+    }
+
+  next0 = limit0;
+  next1 = limit1;
+}
+
+/* Print a hunk of an sdiff diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_sdiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i, j;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes =
+    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  /* Print out lines up to this change.  */
+  print_sdiff_common_lines (first0, first1);
+
+  if (sdiff_merge_assist)
+    {
+      long int len0 = last0 - first0 + 1;
+      long int len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%ld,%ld\n", len0, len1);
+    }
+
+  /* Print ``xxx  |  xxx '' lines */
+  if (changes == CHANGED)
+    {
+      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
+      next0 = first0 = i;
+      next1 = first1 = j;
+    }
+
+  /* Print ``     >  xxx '' lines */
+  if (changes & NEW)
+    {
+      for (j = first1; j <= last1; ++j)
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+      next1 = j;
+    }
+
+  /* Print ``xxx  <     '' lines */
+  if (changes & OLD)
+    {
+      for (i = first0; i <= last0; ++i)
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+      next0 = i;
+    }
+}
diff --git a/diffutils-3.0-patch/util.c b/diffutils-3.0-patch/util.c
new file mode 100644
index 0000000..d18bf38
--- /dev/null
+++ b/diffutils-3.0-patch/util.c
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to `message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to `stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the `pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of `struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/diffutils-3.0/analyze.c b/diffutils-3.0/analyze.c
new file mode 100644
index 0000000..e797248
--- /dev/null
+++ b/diffutils-3.0/analyze.c
@@ -0,0 +1,723 @@
+/* Analyze file differences for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <error.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* The core of the Diff algorithm.  */
+#define ELEMENT lin
+#define EQUAL(x,y) ((x) == (y))
+#define OFFSET lin
+#define EXTRA_CONTEXT_FIELDS /* none */
+#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
+#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
+#define USE_HEURISTIC 1
+#include <diffseq.h>
+
+/* Discard lines from one file that have no matches in the other file.
+
+   A line which is discarded will not be considered by the actual
+   comparison algorithm; it will be as if that line were not in the file.
+   The file's `realindexes' table maps virtual line numbers
+   (which don't count the discarded lines) into real line numbers;
+   this is how the actual comparison algorithm produces results
+   that are comprehensible when the discarded lines are counted.
+
+   When we discard a line, we also mark it as a deletion or insertion
+   so that it will be printed in the output.  */
+
+static void
+discard_confusing_lines (struct file_data filevec[])
+{
+  int f;
+  lin i;
+  char *discarded[2];
+  lin *equiv_count[2];
+  lin *p;
+
+  /* Allocate our results.  */
+  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
+	       * (2 * sizeof *p));
+  for (f = 0; f < 2; f++)
+    {
+      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
+      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
+    }
+
+  /* Set up equiv_count[F][I] as the number of lines in file F
+     that fall in equivalence class I.  */
+
+  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
+  equiv_count[0] = p;
+  equiv_count[1] = p + filevec[0].equiv_max;
+
+  for (i = 0; i < filevec[0].buffered_lines; ++i)
+    ++equiv_count[0][filevec[0].equivs[i]];
+  for (i = 0; i < filevec[1].buffered_lines; ++i)
+    ++equiv_count[1][filevec[1].equivs[i]];
+
+  /* Set up tables of which lines are going to be discarded.  */
+
+  discarded[0] = zalloc (filevec[0].buffered_lines
+			 + filevec[1].buffered_lines);
+  discarded[1] = discarded[0] + filevec[0].buffered_lines;
+
+  /* Mark to be discarded each line that matches no line of the other file.
+     If a line matches many lines, mark it as provisionally discardable.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      size_t end = filevec[f].buffered_lines;
+      char *discards = discarded[f];
+      lin *counts = equiv_count[1 - f];
+      lin *equivs = filevec[f].equivs;
+      size_t many = 5;
+      size_t tem = end / 64;
+
+      /* Multiply MANY by approximate square root of number of lines.
+	 That is the threshold for provisionally discardable lines.  */
+      while ((tem = tem >> 2) > 0)
+	many *= 2;
+
+      for (i = 0; i < end; i++)
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
+    }
+
+  /* Don't really discard the provisional lines except when they occur
+     in a run of discardables, with nonprovisionals at the beginning
+     and end.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      lin end = filevec[f].buffered_lines;
+      register char *discards = discarded[f];
+
+      for (i = 0; i < end; i++)
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Actually discard the lines. */
+  for (f = 0; f < 2; f++)
+    {
+      char *discards = discarded[f];
+      lin end = filevec[f].buffered_lines;
+      lin j = 0;
+      for (i = 0; i < end; ++i)
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
+      filevec[f].nondiscarded_lines = j;
+    }
+
+  free (discarded[0]);
+  free (equiv_count[0]);
+}
+
+/* Adjust inserts/deletes of identical lines to join changes
+   as much as possible.
+
+   We do something when a run of changed lines include a
+   line at one end and have an excluded, identical line at the other.
+   We are free to choose which identical line is included.
+   `compareseq' usually chooses the one at the beginning,
+   but usually it is cleaner to consider the following identical line
+   to be the "change".  */
+
+static void
+shift_boundaries (struct file_data filevec[])
+{
+  int f;
+
+  for (f = 0; f < 2; f++)
+    {
+      char *changed = filevec[f].changed;
+      char *other_changed = filevec[1 - f].changed;
+      lin const *equivs = filevec[f].equivs;
+      lin i = 0;
+      lin j = 0;
+      lin i_end = filevec[f].buffered_lines;
+
+      while (1)
+	{
+	  lin runlength, start, corresponding;
+
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
+
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
+    }
+}
+
+/* Cons an additional entry onto the front of an edit script OLD.
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+static struct change *
+add_change (lin line0, lin line1, lin deleted, lin inserted,
+	    struct change *old)
+{
+  struct change *new = xmalloc (sizeof *new);
+
+  new->line0 = line0;
+  new->line1 = line1;
+  new->inserted = inserted;
+  new->deleted = deleted;
+  new->link = old;
+  return new;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in reverse order.  */
+
+static struct change *
+build_reverse_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin len0 = filevec[0].buffered_lines;
+  lin len1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[lenN] does exist, and is 0.  */
+
+  lin i0 = 0, i1 = 0;
+
+  while (i0 < len0 || i1 < len1)
+    {
+      if (changed0[i0] | changed1[i1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0++, i1++;
+    }
+
+  return script;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in forward order.  */
+
+static struct change *
+build_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[-1] does exist, and is 0.  */
+
+  while (i0 >= 0 || i1 >= 0)
+    {
+      if (changed0[i0 - 1] | changed1[i1 - 1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0--, i1--;
+    }
+
+  return script;
+}
+
+/* If CHANGES, briefly report that two files differed.
+   Return 2 if trouble, CHANGES otherwise.  */
+static int
+briefly_report (int changes, struct file_data const filevec[])
+{
+  if (changes)
+    {
+      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
+      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
+
+      if (brief)
+	message ("Files %s and %s differ\n", label0, label1);
+      else
+	{
+	  message ("Binary files %s and %s differ\n", label0, label1);
+	  changes = 2;
+	}
+    }
+
+  return changes;
+}
+
+/* Report the differences of two files.  */
+int
+diff_2_files (struct comparison *cmp)
+{
+  int f;
+  struct change *e, *p;
+  struct change *script;
+  int changes;
+
+
+  /* If we have detected that either file is binary,
+     compare the two files as binary.  This can happen
+     only when the first chunk is read.
+     Also, --brief without any --ignore-* options means
+     we can speed things up by treating the files as binary.  */
+
+  if (read_files (cmp->file, files_can_be_treated_as_binary))
+    {
+      /* Files with different lengths must be different.  */
+      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
+
+      /* Standard input equals itself.  */
+      else if (cmp->file[0].desc == cmp->file[1].desc)
+	changes = 0;
+
+      else
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
+
+      changes = briefly_report (changes, cmp->file);
+    }
+  else
+    {
+      struct context ctxt;
+      lin diags;
+      lin too_expensive;
+
+      /* Allocate vectors for the results of comparison:
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
+
+      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
+      char *flag_space = zalloc (s);
+      cmp->file[0].changed = flag_space + 1;
+      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
+
+      /* Some lines are obviously insertions or deletions
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
+
+      discard_confusing_lines (cmp->file);
+
+      /* Now do the main comparison algorithm, considering just the
+	 undiscarded lines.  */
+
+      ctxt.xvec = cmp->file[0].undiscarded;
+      ctxt.yvec = cmp->file[1].undiscarded;
+      diags = (cmp->file[0].nondiscarded_lines
+	       + cmp->file[1].nondiscarded_lines + 3);
+      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
+      ctxt.bdiag = ctxt.fdiag + diags;
+      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
+      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
+
+      ctxt.heuristic = speed_large_files;
+
+      /* Set TOO_EXPENSIVE to be approximate square root of input size,
+	 bounded below by 256.  */
+      too_expensive = 1;
+      for (;  diags != 0;  diags >>= 2)
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (256, too_expensive);
+
+      files[0] = cmp->file[0];
+      files[1] = cmp->file[1];
+
+      compareseq (0, cmp->file[0].nondiscarded_lines,
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+
+      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
+
+      /* Modify the results slightly to make them prettier
+	 in cases where that can validly be done.  */
+
+      shift_boundaries (cmp->file);
+
+      /* Get the results of comparison in the form of a chain
+	 of `struct change's -- an edit script.  */
+
+      if (output_style == OUTPUT_ED)
+	script = build_reverse_script (cmp->file);
+      else
+	script = build_script (cmp->file);
+
+      /* Set CHANGES if we had any diffs.
+	 If some changes are ignored, we must scan the script to decide.  */
+      if (ignore_blank_lines || ignore_regexp.fastmap)
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
+      else
+	changes = (script != 0);
+
+      if (brief)
+	changes = briefly_report (changes, cmp->file);
+      else
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
+
+      free (cmp->file[0].undiscarded);
+
+      free (flag_space);
+
+      for (f = 0; f < 2; f++)
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
+
+      for (e = script; e; e = p)
+	{
+	  p = e->link;
+	  free (e);
+	}
+
+      if (! ROBUST_OUTPUT_STYLE (output_style))
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
+    }
+
+  if (cmp->file[0].buffer != cmp->file[1].buffer)
+    free (cmp->file[0].buffer);
+  free (cmp->file[1].buffer);
+
+  return changes;
+}
diff --git a/diffutils-3.0/cmp.c b/diffutils-3.0/cmp.c
new file mode 100644
index 0000000..2455dc4
--- /dev/null
+++ b/diffutils-3.0/cmp.c
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try `%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value `%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is `-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value `%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after `%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand `%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+   using `buffer[0]' and `buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/diffutils-3.0/context.c b/diffutils-3.0/context.c
new file mode 100644
index 0000000..0be8cc5
--- /dev/null
+++ b/diffutils-3.0/context.c
@@ -0,0 +1,493 @@
+/* Context-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "c-ctype.h"
+#include <inttostr.h>
+#include <stat-time.h>
+#include <strftime.h>
+
+static char const *find_function (char const * const *, lin);
+static struct change *find_hunk (struct change *);
+static void mark_ignorable (struct change *);
+static void pr_context_hunk (struct change *);
+static void pr_unidiff_hunk (struct change *);
+
+/* Last place find_function started searching from.  */
+static lin find_function_last_search;
+
+/* The value find_function returned when it started searching there.  */
+static lin find_function_last_match;
+
+/* Print a label for a context diff, with a file name and date or a label.  */
+
+static void
+print_context_label (char const *mark,
+		     struct file_data *inf,
+		     char const *label)
+{
+  if (label)
+    fprintf (outfile, "%s %s\n", mark, label);
+  else
+    {
+      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
+		    INT_STRLEN_BOUND (time_t) + 11)];
+      struct tm const *tm = localtime (&inf->stat.st_mtime);
+      int nsec = get_stat_mtime_ns (&inf->stat);
+      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
+    }
+}
+
+/* Print a header for a context diff, with the file names and dates.  */
+
+void
+print_context_header (struct file_data inf[], bool unidiff)
+{
+  if (unidiff)
+    {
+      print_context_label ("---", &inf[0], file_label[0]);
+      print_context_label ("+++", &inf[1], file_label[1]);
+    }
+  else
+    {
+      print_context_label ("***", &inf[0], file_label[0]);
+      print_context_label ("---", &inf[1], file_label[1]);
+    }
+}
+
+/* Print an edit script in context format.  */
+
+void
+print_context_script (struct change *script, bool unidiff)
+{
+  if (ignore_blank_lines || ignore_regexp.fastmap)
+    mark_ignorable (script);
+  else
+    {
+      struct change *e;
+      for (e = script; e; e = e->link)
+	e->ignore = false;
+    }
+
+  find_function_last_search = - files[0].prefix_lines;
+  find_function_last_match = LIN_MAX;
+
+  if (unidiff)
+    print_script (script, find_hunk, pr_unidiff_hunk);
+  else
+    print_script (script, find_hunk, pr_context_hunk);
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is not greater, use the first in place of it.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_context_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B <= A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.
+
+     POSIX 1003.1-2001 requires two line numbers separated by a comma
+     even if the line numbers are the same.  However, this does not
+     match existing practice and is surely an error in the
+     specification.  */
+
+  if (trans_b <= trans_a)
+    fprintf (outfile, "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
+}
+
+/* Print FUNCTION in a context header.  */
+static void
+print_context_function (FILE *out, char const *function)
+{
+  int i, j;
+  putc (' ', out);
+  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
+    continue;
+  for (j = i; j < i + 40 && function[j] != '\n'; j++)
+    continue;
+  while (i < j && c_isspace ((unsigned char) function[j - 1]))
+    j--;
+  fwrite (function + i, sizeof (char), j - i, out);
+}
+
+/* Print a portion of an edit script in context format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_context_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1, i;
+  char const *prefix;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (! changes)
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("***************", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  fputs ("\n*** ", out);
+  print_context_number_range (&files[0], first0, last0);
+  fputs (" ****\n", out);
+
+  if (changes & OLD)
+    {
+      struct change *next = hunk;
+
+      for (i = first0; i <= last0; i++)
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were inserted here in file 1, this is "changed".
+	       Otherwise it is "deleted".  */
+	    prefix = (next->inserted > 0 ? "!" : "-");
+
+	  print_1_line (prefix, &files[0].linbuf[i]);
+	}
+    }
+
+  fputs ("--- ", out);
+  print_context_number_range (&files[1], first1, last1);
+  fputs (" ----\n", out);
+
+  if (changes & NEW)
+    {
+      struct change *next = hunk;
+
+      for (i = first1; i <= last1; i++)
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were deleted here in file 0, this is "changed".
+	       Otherwise it is "inserted".  */
+	    prefix = (next->deleted > 0 ? "!" : "+");
+
+	  print_1_line (prefix, &files[1].linbuf[i]);
+	}
+    }
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is smaller, use the first in place of it.
+   If the numbers are equal, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B < A in the case of a range of no lines.
+     In this case, we print the line number before the range,
+     which is B.  It would be more logical to print A, but
+     'patch' expects B in order to detect diffs against empty files.  */
+  if (trans_b <= trans_a)
+    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
+}
+
+/* Print a portion of an edit script in unidiff format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_unidiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  lin i, j, k;
+  struct change *next;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("@@ -", out);
+  print_unidiff_number_range (&files[0], first0, last0);
+  fputs (" +", out);
+  print_unidiff_number_range (&files[1], first1, last1);
+  fputs (" @@", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+
+  next = hunk;
+  i = first0;
+  j = first1;
+
+  while (i <= last0 || j <= last1)
+    {
+
+      /* If the line isn't a difference, output the context from file 0. */
+
+      if (!next || i < next->line0)
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
+      else
+	{
+	  /* For each difference, first output the deleted part. */
+
+	  k = next->deleted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* We're done with this hunk, so on to the next! */
+
+	  next = next->link;
+	}
+    }
+}
+
+/* Scan a (forward-ordered) edit script for the first place that more than
+   2*CONTEXT unchanged lines appear, and return a pointer
+   to the `struct change' for the last change before those lines.  */
+
+static struct change *
+find_hunk (struct change *start)
+{
+  struct change *prev;
+  lin top0, top1;
+  lin thresh;
+
+  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
+     changes, but only CONTEXT if one is ignorable.  Watch out for
+     integer overflow, though.  */
+  lin non_ignorable_threshold =
+    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
+  lin ignorable_threshold = context;
+
+  do
+    {
+      /* Compute number of first line in each file beyond this changed.  */
+      top0 = start->line0 + start->deleted;
+      top1 = start->line1 + start->inserted;
+      prev = start;
+      start = start->link;
+      thresh = (prev->ignore || (start && start->ignore)
+		? ignorable_threshold
+		: non_ignorable_threshold);
+      /* It is not supposed to matter which file we check in the end-test.
+	 If it would matter, crash.  */
+      if (start && start->line0 - top0 != start->line1 - top1)
+	abort ();
+    } while (start
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
+
+  return prev;
+}
+
+/* Set the `ignore' flag properly in each change in SCRIPT.
+   It should be 1 if all the lines inserted or deleted in that change
+   are ignorable lines.  */
+
+static void
+mark_ignorable (struct change *script)
+{
+  while (script)
+    {
+      struct change *next = script->link;
+      lin first0, last0, first1, last1;
+
+      /* Turn this change into a hunk: detach it from the others.  */
+      script->link = NULL;
+
+      /* Determine whether this change is ignorable.  */
+      script->ignore = ! analyze_hunk (script,
+				       &first0, &last0, &first1, &last1);
+
+      /* Reconnect the chain as before.  */
+      script->link = next;
+
+      /* Advance to the following change.  */
+      script = next;
+    }
+}
+
+/* Find the last function-header line in LINBUF prior to line number LINENUM.
+   This is a line containing a match for the regexp in `function_regexp'.
+   Return the address of the text, or NULL if no function-header is found.  */
+
+static char const *
+find_function (char const * const *linbuf, lin linenum)
+{
+  lin i = linenum;
+  lin last = find_function_last_search;
+  find_function_last_search = i;
+
+  while (last <= --i)
+    {
+      /* See if this line is what we want.  */
+      char const *line = linbuf[i];
+      size_t linelen = linbuf[i + 1] - line - 1;
+
+      /* FIXME: re_search's size args should be size_t, not int.  */
+      int len = MIN (linelen, INT_MAX);
+
+      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
+    }
+  /* If we search back to where we started searching the previous time,
+     find the line we found last time.  */
+  if (find_function_last_match != LIN_MAX)
+    return linbuf[find_function_last_match];
+
+  return NULL;
+}
diff --git a/diffutils-3.0/diff.c b/diffutils-3.0/diff.c
new file mode 100644
index 0000000..cc1b611
--- /dev/null
+++ b/diffutils-3.0/diff.c
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in `regexps' */
+  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then `patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then `patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length `%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width `%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length `%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize `%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after `%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand `%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is `-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value `%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare `-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/diffutils-3.0/diff3.c b/diffutils-3.0/diff3.c
new file mode 100644
index 0000000..0f11fdc
--- /dev/null
+++ b/diffutils-3.0/diff3.c
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include `:wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after `%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand `%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("`-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try `%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append `w' and `q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is `-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program `%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program `%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program `%s' failed"
+	     : "subsidiary program `%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in `output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/diffutils-3.0/dir.c b/diffutils-3.0/dir.c
new file mode 100644
index 0000000..5b4eaec
--- /dev/null
+++ b/diffutils-3.0/dir.c
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the `names' table from the `data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If `-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/diffutils-3.0/ed.c b/diffutils-3.0/ed.c
new file mode 100644
index 0000000..08acf50
--- /dev/null
+++ b/diffutils-3.0/ed.c
@@ -0,0 +1,175 @@
+/* Output routines for ed-script format.
+
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_ed_hunk (struct change *);
+static void print_rcs_hunk (struct change *);
+static void pr_forward_ed_hunk (struct change *);
+
+/* Print our script as ed commands.  */
+
+void
+print_ed_script (struct change *script)
+{
+  print_script (script, find_reverse_change, print_ed_hunk);
+}
+
+/* Print a hunk of an ed diff */
+
+static void
+print_ed_hunk (struct change *hunk)
+{
+  lin f0, l0, f1, l1;
+  enum changes changes;
+
+#ifdef DEBUG
+  debug_script (hunk);
+#endif
+
+  /* Determine range of line numbers involved in each file.  */
+  changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], f0, l0);
+  fputc (change_letter[changes], outfile);
+  fputc ('\n', outfile);
+
+  /* Print new/changed lines from second file, if needed */
+  if (changes != OLD)
+    {
+      lin i;
+      bool insert_mode = true;
+
+      for (i = f1; i <= l1; i++)
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
+
+      if (insert_mode)
+	fputs (".\n", outfile);
+    }
+}
+
+/* Print change script in the style of ed commands,
+   but print the changes in the order they appear in the input files,
+   which means that the commands are not truly useful with ed.
+   Because of the issue with lines containing just a dot, the output
+   is not even parseable.  */
+
+void
+pr_forward_ed_script (struct change *script)
+{
+  print_script (script, find_change, pr_forward_ed_hunk);
+}
+
+static void
+pr_forward_ed_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  fputc (change_letter[changes], outfile);
+  print_number_range (' ', files, f0, l0);
+  fputc ('\n', outfile);
+
+  /* If deletion only, print just the number range.  */
+
+  if (changes == OLD)
+    return;
+
+  /* For insertion (with or without deletion), print the number range
+     and the lines from file 2.  */
+
+  for (i = f1; i <= l1; i++)
+    print_1_line ("", &files[1].linbuf[i]);
+
+  fputs (".\n", outfile);
+}
+
+/* Print in a format somewhat like ed commands
+   except that each insert command states the number of lines it inserts.
+   This format is used for RCS.  */
+
+void
+print_rcs_script (struct change *script)
+{
+  print_script (script, find_change, print_rcs_hunk);
+}
+
+/* Print a hunk of an RCS diff */
+
+static void
+print_rcs_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+  long int tf0, tl0, tf1, tl1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  translate_range (&files[0], f0, l0, &tf0, &tl0);
+
+  if (changes & OLD)
+    {
+      /* For deletion, print just the starting line number from file 0
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+    }
+
+  if (changes & NEW)
+    {
+      /* Take last-line-number from file 0 and # lines from file 1.  */
+      translate_range (&files[1], f1, l1, &tf1, &tl1);
+      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+
+      /* Print the inserted lines.  */
+      for (i = f1; i <= l1; i++)
+	print_1_line ("", &files[1].linbuf[i]);
+    }
+}
diff --git a/diffutils-3.0/ifdef.c b/diffutils-3.0/ifdef.c
new file mode 100644
index 0000000..a48f830
--- /dev/null
+++ b/diffutils-3.0/ifdef.c
@@ -0,0 +1,430 @@
+/* #ifdef-format output routines for GNU DIFF.
+
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <xalloc.h>
+
+struct group
+{
+  struct file_data const *file;
+  lin from, upto; /* start and limit lines for this group of lines */
+};
+
+static char const *format_group (FILE *, char const *, char,
+				 struct group const *);
+static char const *do_printf_spec (FILE *, char const *,
+				   struct file_data const *, lin,
+				   struct group const *);
+static char const *scan_char_literal (char const *, char *);
+static lin groups_letter_value (struct group const *, char);
+static void format_ifdef (char const *, lin, lin, lin, lin);
+static void print_ifdef_hunk (struct change *);
+static void print_ifdef_lines (FILE *, char const *, struct group const *);
+
+static lin next_line0;
+static lin next_line1;
+
+/* Print the edit-script SCRIPT as a merged #ifdef file.  */
+
+void
+print_ifdef_script (struct change *script)
+{
+  next_line0 = next_line1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_ifdef_hunk);
+  if (next_line0 < files[0].valid_lines
+      || next_line1 < files[1].valid_lines)
+    {
+      begin_output ();
+      format_ifdef (group_format[UNCHANGED],
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
+    }
+}
+
+/* Print a hunk of an ifdef diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_ifdef_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print lines up to this change.  */
+  if (next_line0 < first0 || next_line1 < first1)
+    format_ifdef (group_format[UNCHANGED],
+		  next_line0, first0,
+		  next_line1, first1);
+
+  /* Print this change.  */
+  next_line0 = last0 + 1;
+  next_line1 = last1 + 1;
+  format_ifdef (group_format[changes],
+		first0, next_line0,
+		first1, next_line1);
+}
+
+/* Print a set of lines according to FORMAT.
+   Lines BEG0 up to END0 are from the first file;
+   lines BEG1 up to END1 are from the second file.  */
+
+static void
+format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
+{
+  struct group groups[2];
+
+  groups[0].file = &files[0];
+  groups[0].from = beg0;
+  groups[0].upto = end0;
+  groups[1].file = &files[1];
+  groups[1].from = beg1;
+  groups[1].upto = end1;
+  format_group (outfile, format, 0, groups);
+}
+
+/* Print to file OUT a set of lines according to FORMAT.
+   The format ends at the first free instance of ENDCHAR.
+   Yield the address of the terminating character.
+   GROUPS specifies which lines to print.
+   If OUT is zero, do not actually print anything; just scan the format.  */
+
+static char const *
+format_group (register FILE *out, char const *format, char endchar,
+	      struct group const *groups)
+{
+  register char c;
+  register char const *f = format;
+
+  while ((c = *f) != endchar && c != 0)
+    {
+      char const *f1 = ++f;
+      if (c == '%')
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
+
+      if (out)
+	putc (c, out);
+    }
+
+  return f;
+}
+
+/* For the line group pair G, return the number corresponding to LETTER.
+   Return -1 if LETTER is not a group format letter.  */
+static lin
+groups_letter_value (struct group const *g, char letter)
+{
+  switch (letter)
+    {
+    case 'E': letter = 'e'; g++; break;
+    case 'F': letter = 'f'; g++; break;
+    case 'L': letter = 'l'; g++; break;
+    case 'M': letter = 'm'; g++; break;
+    case 'N': letter = 'n'; g++; break;
+    }
+
+  switch (letter)
+    {
+      case 'e': return translate_line_number (g->file, g->from) - 1;
+      case 'f': return translate_line_number (g->file, g->from);
+      case 'l': return translate_line_number (g->file, g->upto) - 1;
+      case 'm': return translate_line_number (g->file, g->upto);
+      case 'n': return g->upto - g->from;
+      default: return -1;
+    }
+}
+
+/* Print to file OUT, using FORMAT to print the line group GROUP.
+   But do nothing if OUT is zero.  */
+static void
+print_ifdef_lines (register FILE *out, char const *format,
+		   struct group const *group)
+{
+  struct file_data const *file = group->file;
+  char const * const *linbuf = file->linbuf;
+  lin from = group->from, upto = group->upto;
+
+  if (!out)
+    return;
+
+  /* If possible, use a single fwrite; it's faster.  */
+  if (!expand_tabs && format[0] == '%')
+    {
+      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
+      if (format[1] == 'L' && !format[2])
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
+    }
+
+  for (;  from < upto;  from++)
+    {
+      register char c;
+      register char const *f = format;
+
+      while ((c = *f++) != 0)
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
+
+	  putc (c, out);
+	}
+    }
+}
+
+static char const *
+do_printf_spec (FILE *out, char const *spec,
+		struct file_data const *file, lin n,
+		struct group const *groups)
+{
+  char const *f = spec;
+  char c;
+  char c1;
+
+  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
+  /* assert (*f == '%'); */
+  f++;
+  while ((c = *f++) == '-' || c == '\'' || c == '0')
+    continue;
+  while (ISDIGIT (c))
+    c = *f++;
+  if (c == '.')
+    while (ISDIGIT (c = *f++))
+      continue;
+  c1 = *f++;
+
+  switch (c)
+    {
+    case 'c':
+      if (c1 != '\'')
+	return 0;
+      else
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
+      break;
+
+    case 'd': case 'o': case 'x': case 'X':
+      {
+	lin value;
+
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    long int long_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+#if HAVE_C_VARARRAYS
+	    char format[spec_prefix_len + 3];
+#else
+	    char *format = xmalloc (spec_prefix_len + 3);
+#endif
+	    char *p = format + spec_prefix_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    *p++ = 'l';
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, long_value);
+#if ! HAVE_C_VARARRAYS
+	    free (format);
+#endif
+	  }
+      }
+      break;
+
+    default:
+      return 0;
+    }
+
+  return f;
+}
+
+/* Scan the character literal represented in the string LIT; LIT points just
+   after the initial apostrophe.  Put the literal's value into *VALPTR.
+   Yield the address of the first character after the closing apostrophe,
+   or a null pointer if the literal is ill-formed.  */
+static char const *
+scan_char_literal (char const *lit, char *valptr)
+{
+  register char const *p = lit;
+  char value;
+  ptrdiff_t digits;
+  char c = *p++;
+
+  switch (c)
+    {
+      case 0:
+      case '\'':
+	return NULL;
+
+      case '\\':
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
+
+      default:
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
+    }
+
+  *valptr = value;
+  return p;
+}
diff --git a/diffutils-3.0/io.c b/diffutils-3.0/io.c
new file mode 100644
index 0000000..031be3d
--- /dev/null
+++ b/diffutils-3.0/io.c
@@ -0,0 +1,845 @@
+/* File I/O for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* Rotate an unsigned value to the left.  */
+#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
+
+/* Given a hash value and a new character, return a new hash value.  */
+#define HASH(h, c) ((c) + ROL (h, 7))
+
+/* The type of a hash value.  */
+typedef size_t hash_value;
+verify (! TYPE_SIGNED (hash_value));
+
+/* Lines are put into equivalence classes of lines that match in lines_differ.
+   Each equivalence class is represented by one of these structures,
+   but only while the classes are being computed.
+   Afterward, each class is represented by a number.  */
+struct equivclass
+{
+  lin next;		/* Next item in this bucket.  */
+  hash_value hash;	/* Hash of lines in this class.  */
+  char const *line;	/* A line that fits this class.  */
+  size_t length;	/* That line's length, not counting its newline.  */
+};
+
+/* Hash-table: array of buckets, each being a chain of equivalence classes.
+   buckets[-1] is reserved for incomplete lines.  */
+static lin *buckets;
+
+/* Number of buckets in the hash table array, not counting buckets[-1].  */
+static size_t nbuckets;
+
+/* Array in which the equivalence classes are allocated.
+   The bucket-chains go through the elements in this array.
+   The number of an equivalence class is its index in this array.  */
+static struct equivclass *equivs;
+
+/* Index of first free element in the array `equivs'.  */
+static lin equivs_index;
+
+/* Number of elements allocated in the array `equivs'.  */
+static lin equivs_alloc;
+
+/* Read a block of data into a file buffer, checking for EOF and error.  */
+
+void
+file_block_read (struct file_data *current, size_t size)
+{
+  if (size && ! current->eof)
+    {
+      size_t s = block_read (current->desc,
+			     FILE_BUFFER (current) + current->buffered, size);
+      if (s == SIZE_MAX)
+	pfatal_with_name (current->name);
+      current->buffered += s;
+      current->eof = s < size;
+    }
+}
+
+/* Check for binary files and compare them for exact identity.  */
+
+/* Return 1 if BUF contains a non text character.
+   SIZE is the number of characters in BUF.  */
+
+#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
+
+/* Get ready to read the current file.
+   Return nonzero if SKIP_TEST is zero,
+   and if it appears to be a binary file.  */
+
+static bool
+sip (struct file_data *current, bool skip_test)
+{
+  /* If we have a nonexistent file at this stage, treat it as empty.  */
+  if (current->desc < 0)
+    {
+      /* Leave room for a sentinel.  */
+      current->bufsize = sizeof (word);
+      current->buffer = xmalloc (current->bufsize);
+    }
+  else
+    {
+      current->bufsize = buffer_lcm (sizeof (word),
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
+      current->buffer = xmalloc (current->bufsize);
+
+      if (! skip_test)
+	{
+	  /* Check first part of file to see if it's a binary file.  */
+
+	  /* FIXME: if O_BINARY, this should revert to text mode
+	     if the file is not binary.  */
+
+	  file_block_read (current, current->bufsize);
+	  return binary_file_p (current->buffer, current->buffered);
+	}
+    }
+
+  current->buffered = 0;
+  current->eof = false;
+  return false;
+}
+
+/* Slurp the rest of the current file completely into memory.  */
+
+static void
+slurp (struct file_data *current)
+{
+  size_t cc;
+
+  if (current->desc < 0)
+    {
+      /* The file is nonexistent.  */
+      return;
+    }
+
+  if (S_ISREG (current->stat.st_mode))
+    {
+      /* It's a regular file; slurp in the rest all at once.  */
+
+      /* Get the size out of the stat block.
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
+      size_t file_size = current->stat.st_size;
+      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
+      if (file_size != current->stat.st_size || cc < file_size
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
+
+      if (current->bufsize < cc)
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
+
+      /* Try to read at least 1 more byte than the size indicates, to
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
+
+      if (current->buffered <= file_size)
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
+    }
+
+  /* It's not a regular file, or it's a growing regular file; read it,
+     growing the buffer as needed.  */
+
+  file_block_read (current, current->bufsize - current->buffered);
+
+  if (current->buffered)
+    {
+      while (current->buffered == current->bufsize)
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
+
+      /* Allocate just enough room for appended newline plus word
+	 sentinel, plus word-alignment.  */
+      cc = current->buffered + 2 * sizeof (word);
+      current->bufsize = cc - cc % sizeof (word);
+      current->buffer = xrealloc (current->buffer, current->bufsize);
+    }
+}
+
+/* Split the file into lines, simultaneously computing the equivalence
+   class for each line.  */
+
+static void
+find_and_hash_each_line (struct file_data *current)
+{
+  hash_value h;
+  char const *p = current->prefix_end;
+  unsigned char c;
+  lin i, *bucket;
+  size_t length;
+
+  /* Cache often-used quantities in local variables to help the compiler.  */
+  char const **linbuf = current->linbuf;
+  lin alloc_lines = current->alloc_lines;
+  lin line = 0;
+  lin linbuf_base = current->linbuf_base;
+  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
+  struct equivclass *eqs = equivs;
+  lin eqs_index = equivs_index;
+  lin eqs_alloc = equivs_alloc;
+  char const *suffix_begin = current->suffix_begin;
+  char const *bufend = FILE_BUFFER (current) + current->buffered;
+  bool diff_length_compare_anyway =
+    ignore_white_space != IGNORE_NO_WHITE_SPACE;
+  bool same_length_diff_contents_compare_anyway =
+    diff_length_compare_anyway | ignore_case;
+
+  while (p < suffix_begin)
+    {
+      char const *ip = p;
+
+      h = 0;
+
+      /* Hash this line until we find a newline.  */
+      if (ignore_case)
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, tolower (c));
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, tolower (c));
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      c = tolower (c);
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	    break;
+	  }
+      else
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, c);
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, c);
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	    break;
+	  }
+
+   hashing_done:;
+
+      bucket = &buckets[h % nbuckets];
+      length = p - ip - 1;
+
+      if (p == bufend
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    bucket = &buckets[-1];
+	}
+
+      for (i = *bucket;  ;  i = eqs[i].next)
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
+
+	    /* Reuse existing class if lines_differ reports the lines
+               equal.  */
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
+
+      /* Maybe increase the size of the line table.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = ip;
+      cureqs[line] = i;
+      ++line;
+    }
+
+  current->buffered_lines = line;
+
+  for (i = 0;  ;  i++)
+    {
+      /* Record the line start for lines in the suffix that we care about.
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = p;
+
+      if (p == bufend)
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
+
+      if (context <= i && no_diff_means_no_output)
+	break;
+
+      line++;
+
+      while (*p++ != '\n')
+	continue;
+    }
+
+  /* Done with cache in local variables.  */
+  current->linbuf = linbuf;
+  current->valid_lines = line;
+  current->alloc_lines = alloc_lines;
+  current->equivs = cureqs;
+  equivs = eqs;
+  equivs_alloc = eqs_alloc;
+  equivs_index = eqs_index;
+}
+
+/* Prepare the text.  Make sure the text end is initialized.
+   Make sure text ends in a newline,
+   but remember that we had to add one.
+   Strip trailing CRs, if that was requested.  */
+
+static void
+prepare_text (struct file_data *current)
+{
+  size_t buffered = current->buffered;
+  char *p = FILE_BUFFER (current);
+  char *dst;
+
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
+    {
+      p[buffered++] = '\n';
+      current->missing_newline = true;
+    }
+
+  if (!p)
+    return;
+
+  /* Don't use uninitialized storage when planting or using sentinels.  */
+  memset (p + buffered, 0, sizeof (word));
+
+  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+    {
+      char const *src = dst;
+      char const *srclim = p + buffered;
+
+      do
+	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
+      while (src < srclim);
+
+      buffered -= src - dst;
+    }
+
+  current->buffered = buffered;
+}
+
+/* We have found N lines in a buffer of size S; guess the
+   proportionate number of lines that will be found in a buffer of
+   size T.  However, do not guess a number of lines so large that the
+   resulting line table might cause overflow in size calculations.  */
+static lin
+guess_lines (lin n, size_t s, size_t t)
+{
+  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
+  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
+  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
+}
+
+/* Given a vector of two file_data objects, find the identical
+   prefixes and suffixes of each object.  */
+
+static void
+find_identical_ends (struct file_data filevec[])
+{
+  word *w0, *w1;
+  char *p0, *p1, *buffer0, *buffer1;
+  char const *end0, *beg0;
+  char const **linbuf0, **linbuf1;
+  lin i, lines;
+  size_t n0, n1;
+  lin alloc_lines0, alloc_lines1;
+  lin buffered_prefix, prefix_count, prefix_mask;
+  lin middle_guess, suffix_guess;
+
+  slurp (&filevec[0]);
+  prepare_text (&filevec[0]);
+  if (filevec[0].desc != filevec[1].desc)
+    {
+      slurp (&filevec[1]);
+      prepare_text (&filevec[1]);
+    }
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+      filevec[1].missing_newline = filevec[0].missing_newline;
+    }
+
+  /* Find identical prefix.  */
+
+  w0 = filevec[0].buffer;
+  w1 = filevec[1].buffer;
+  p0 = buffer0 = (char *) w0;
+  p1 = buffer1 = (char *) w1;
+  n0 = filevec[0].buffered;
+  n1 = filevec[1].buffered;
+
+  if (p0 == p1)
+    /* The buffers are the same; sentinels won't work.  */
+    p0 = p1 += n1;
+  else
+    {
+      /* Insert end sentinels, in this case characters that are guaranteed
+	 to make the equality test false, and thus terminate the loop.  */
+
+      if (n0 < n1)
+	p0[n0] = ~p1[n0];
+      else
+	p1[n1] = ~p0[n1];
+
+      /* Loop until first mismatch, or to the sentinel characters.  */
+
+      /* Compare a word at a time for speed.  */
+      while (*w0 == *w1)
+	w0++, w1++;
+
+      /* Do the last few bytes of comparison a byte at a time.  */
+      p0 = (char *) w0;
+      p1 = (char *) w1;
+      while (*p0 == *p1)
+	p0++, p1++;
+
+      /* Don't mistakenly count missing newline as part of prefix.  */
+      if (ROBUST_OUTPUT_STYLE (output_style)
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
+    }
+
+  /* Now P0 and P1 point at the first nonmatching characters.  */
+
+  /* Skip back to last line-beginning in the prefix,
+     and then discard up to HORIZON_LINES lines from the prefix.  */
+  i = horizon_lines;
+  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
+    p0--, p1--;
+
+  /* Record the prefix.  */
+  filevec[0].prefix_end = p0;
+  filevec[1].prefix_end = p1;
+
+  /* Find identical suffix.  */
+
+  /* P0 and P1 point beyond the last chars not yet compared.  */
+  p0 = buffer0 + n0;
+  p1 = buffer1 + n1;
+
+  if (! ROBUST_OUTPUT_STYLE (output_style)
+      || filevec[0].missing_newline == filevec[1].missing_newline)
+    {
+      end0 = p0;	/* Addr of last char in file 0.  */
+
+      /* Get value of P0 at which we should stop scanning backward:
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
+      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
+
+      /* Scan back until chars don't match or we reach that point.  */
+      while (p0 != beg0)
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
+
+      /* Are we at a line-beginning in both files?  If not, add the rest of
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
+      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
+      while (i-- && p0 != end0)
+	while (*p0++ != '\n')
+	  continue;
+
+      p1 += p0 - beg0;
+    }
+
+  /* Record the suffix.  */
+  filevec[0].suffix_begin = p0;
+  filevec[1].suffix_begin = p1;
+
+  /* Calculate number of lines of prefix to save.
+
+     prefix_count == 0 means save the whole prefix;
+     we need this for options like -D that output the whole file,
+     or for enormous contexts (to avoid worrying about arithmetic overflow).
+     We also need it for options like -F that output some preceding line;
+     at least we will need to find the last few lines,
+     but since we don't know how many, it's easiest to find them all.
+
+     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
+     of the line buffer; they'll be moved to the proper location later.
+     Handle 1 more line than the context says (because we count 1 too many),
+     rounded up to the next power of 2 to speed index computation.  */
+
+  if (no_diff_means_no_output && ! function_regexp.fastmap
+      && context < LIN_MAX / 4 && context < n0)
+    {
+      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
+      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
+      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
+	continue;
+      alloc_lines0 = (prefix_count + middle_guess
+		      + MIN (context, suffix_guess));
+    }
+  else
+    {
+      prefix_count = 0;
+      alloc_lines0 = guess_lines (0, 0, n0);
+    }
+
+  prefix_mask = prefix_count - 1;
+  lines = 0;
+  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+  p0 = buffer0;
+
+  /* If the prefix is needed, find the prefix lines.  */
+  if (! (no_diff_means_no_output
+	 && filevec[0].prefix_end == p0
+	 && filevec[1].prefix_end == p1))
+    {
+      end0 = filevec[0].prefix_end;
+      while (p0 != end0)
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
+    }
+  buffered_prefix = prefix_count && context < lines ? context : lines;
+
+  /* Allocate line buffer 1.  */
+
+  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
+  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
+  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
+  if (alloc_lines1 < buffered_prefix
+      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
+    xalloc_die ();
+  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
+
+  if (buffered_prefix != lines)
+    {
+      /* Rotate prefix lines to proper location.  */
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf0[i] = linbuf1[i];
+    }
+
+  /* Initialize line buffer 1 from line buffer 0.  */
+  for (i = 0; i < buffered_prefix; i++)
+    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
+
+  /* Record the line buffer, adjusted so that
+     linbuf[0] points at the first differing line.  */
+  filevec[0].linbuf = linbuf0 + buffered_prefix;
+  filevec[1].linbuf = linbuf1 + buffered_prefix;
+  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
+  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
+  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
+  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
+}
+
+/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
+   than 2**k.  This table is derived from Chris K. Caldwell's list
+   <http://www.utm.edu/research/primes/lists/2small/>.  */
+
+static unsigned char const prime_offset[] =
+{
+  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
+  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
+  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
+  55, 93, 1, 57, 25
+};
+
+/* Verify that this host's size_t is not too wide for the above table.  */
+
+verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
+
+/* Given a vector of two file_data objects, read the file associated
+   with each one, and build the table of equivalence classes.
+   Return nonzero if either file appears to be a binary file.
+   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
+
+bool
+read_files (struct file_data filevec[], bool pretend_binary)
+{
+  int i;
+  bool skip_test = text | pretend_binary;
+  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
+
+  if (filevec[0].desc != filevec[1].desc)
+    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+    }
+  if (appears_binary)
+    {
+      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
+      return true;
+    }
+
+  find_identical_ends (filevec);
+
+  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
+  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
+    xalloc_die ();
+  equivs = xmalloc (equivs_alloc * sizeof *equivs);
+  /* Equivalence class 0 is permanently safe for lines that were not
+     hashed.  Real equivalence classes start at 1.  */
+  equivs_index = 1;
+
+  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
+     number between 1/3 and 2/3 of the value of equiv_allocs,
+     approximately.  */
+  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
+    continue;
+  nbuckets = ((size_t) 1 << i) - prime_offset[i];
+  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
+    xalloc_die ();
+  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
+  buckets++;
+
+  for (i = 0; i < 2; i++)
+    find_and_hash_each_line (&filevec[i]);
+
+  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
+
+  free (equivs);
+  free (buckets - 1);
+
+  return false;
+}
diff --git a/diffutils-3.0/normal.c b/diffutils-3.0/normal.c
new file mode 100644
index 0000000..154efaa
--- /dev/null
+++ b/diffutils-3.0/normal.c
@@ -0,0 +1,69 @@
+/* Normal-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_normal_hunk (struct change *);
+
+/* Print the edit-script SCRIPT as a normal diff.
+   INF points to an array of descriptions of the two files.  */
+
+void
+print_normal_script (struct change *script)
+{
+  print_script (script, find_change, print_normal_hunk);
+}
+
+/* Print a hunk of a normal diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_normal_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], first0, last0);
+  fputc (change_letter[changes], outfile);
+  print_number_range (',', &files[1], first1, last1);
+  fputc ('\n', outfile);
+
+  /* Print the lines that the first file has.  */
+  if (changes & OLD)
+    for (i = first0; i <= last0; i++)
+      print_1_line ("<", &files[0].linbuf[i]);
+
+  if (changes == CHANGED)
+    fputs ("---\n", outfile);
+
+  /* Print the lines that the second file has.  */
+  if (changes & NEW)
+    for (i = first1; i <= last1; i++)
+      print_1_line (">", &files[1].linbuf[i]);
+}
diff --git a/diffutils-3.0/sdiff.c b/diffutils-3.0/sdiff.c
new file mode 100644
index 0000000..4344e8d
--- /dev/null
+++ b/diffutils-3.0/sdiff.c
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is `-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program `%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program `%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program `%s' failed"
+	       : "subsidiary program `%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after `%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand `%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/diffutils-3.0/side.c b/diffutils-3.0/side.c
new file mode 100644
index 0000000..6aa96a9
--- /dev/null
+++ b/diffutils-3.0/side.c
@@ -0,0 +1,320 @@
+/* sdiff-format output routines for GNU DIFF.
+
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
+   Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <wchar.h>
+
+static void print_sdiff_common_lines (lin, lin);
+static void print_sdiff_hunk (struct change *);
+
+/* Next line number to be printed in the two input files.  */
+static lin next0, next1;
+
+/* Print the edit-script SCRIPT as a sdiff style output.  */
+
+void
+print_sdiff_script (struct change *script)
+{
+  begin_output ();
+
+  next0 = next1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_sdiff_hunk);
+
+  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
+}
+
+/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
+
+static size_t
+tab_from_to (size_t from, size_t to)
+{
+  FILE *out = outfile;
+  size_t tab;
+  size_t tab_size = tabsize;
+
+  if (!expand_tabs)
+    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
+      {
+	putc ('\t', out);
+	from = tab;
+      }
+  while (from++ < to)
+    putc (' ', out);
+  return to;
+}
+
+/* Print the text for half an sdiff line.  This means truncate to
+   width observing tabs, and trim a trailing newline.  Return the
+   last column written (not the number of chars).  */
+
+static size_t
+print_half_line (char const *const *line, size_t indent, size_t out_bound)
+{
+  FILE *out = outfile;
+  register size_t in_position = 0;
+  register size_t out_position = 0;
+  register char const *text_pointer = line[0];
+  register char const *text_limit = line[1];
+  mbstate_t mbstate = { 0 };
+
+  while (text_pointer < text_limit)
+    {
+      char const *tp0 = text_pointer;
+      register char c = *text_pointer++;
+
+      switch (c)
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  /* Fall through.  */
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
+    }
+
+  return out_position;
+}
+
+/* Print side by side lines with a separator in the middle.
+   0 parameters are taken to indicate white space text.
+   Blank lines that can easily be caught are reduced to a single newline.  */
+
+static void
+print_1sdiff_line (char const *const *left, char sep,
+		   char const *const *right)
+{
+  FILE *out = outfile;
+  size_t hw = sdiff_half_width;
+  size_t c2o = sdiff_column2_offset;
+  size_t col = 0;
+  bool put_newline = false;
+
+  if (left)
+    {
+      put_newline |= left[1][-1] == '\n';
+      col = print_half_line (left, 0, hw);
+    }
+
+  if (sep != ' ')
+    {
+      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
+      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
+	sep = put_newline ? '/' : '\\';
+      putc (sep, out);
+    }
+
+  if (right)
+    {
+      put_newline |= right[1][-1] == '\n';
+      if (**right != '\n')
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
+    }
+
+  if (put_newline)
+    putc ('\n', out);
+}
+
+/* Print lines common to both files in side-by-side format.  */
+static void
+print_sdiff_common_lines (lin limit0, lin limit1)
+{
+  lin i0 = next0, i1 = next1;
+
+  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
+    {
+      if (sdiff_merge_assist)
+	{
+	  long int len0 = limit0 - i0;
+	  long int len1 = limit1 - i1;
+	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+	}
+
+      if (!left_column)
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
+      while (i0 != limit0)
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+    }
+
+  next0 = limit0;
+  next1 = limit1;
+}
+
+/* Print a hunk of an sdiff diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_sdiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i, j;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes =
+    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  /* Print out lines up to this change.  */
+  print_sdiff_common_lines (first0, first1);
+
+  if (sdiff_merge_assist)
+    {
+      long int len0 = last0 - first0 + 1;
+      long int len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%ld,%ld\n", len0, len1);
+    }
+
+  /* Print ``xxx  |  xxx '' lines */
+  if (changes == CHANGED)
+    {
+      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
+      next0 = first0 = i;
+      next1 = first1 = j;
+    }
+
+  /* Print ``     >  xxx '' lines */
+  if (changes & NEW)
+    {
+      for (j = first1; j <= last1; ++j)
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+      next1 = j;
+    }
+
+  /* Print ``xxx  <     '' lines */
+  if (changes & OLD)
+    {
+      for (i = first0; i <= last0; ++i)
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+      next0 = i;
+    }
+}
diff --git a/diffutils-3.0/util.c b/diffutils-3.0/util.c
new file mode 100644
index 0000000..3be03e9
--- /dev/null
+++ b/diffutils-3.0/util.c
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to `message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to `stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the `pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program `%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program `%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program `%s' failed"
+		 : "subsidiary program `%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of `struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/diffutils-gets.diff b/diffutils-gets.diff
new file mode 100644
index 0000000..30800b6
--- /dev/null
+++ b/diffutils-gets.diff
@@ -0,0 +1,11 @@
+--- old/stdio.in.h	2016-01-25 16:53:50.846901000 -0800
++++ lib/stdio.in.h	2016-01-25 16:55:28.997468000 -0800
+@@ -139,7 +139,7 @@ _GL_WARN_ON_USE (fflush, "fflush is not
+    so any use of gets warrants an unconditional warning.  Assume it is
+    always declared, since it is required by C89.  */
+ #undef gets
+-_GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
++/* _GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead"); */
+ 
+ #if @GNULIB_FOPEN@
+ # if @REPLACE_FOPEN@
diff --git a/formatted-patch.txt b/formatted-patch.txt
new file mode 100644
index 0000000..e69de29
diff --git a/git-log.txt b/git-log.txt
new file mode 100644
index 0000000..6326c09
--- /dev/null
+++ b/git-log.txt
@@ -0,0 +1,10003 @@
+commit 3600e8d4f07a4dc2a62f015168e2da5a47c4f96f
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 20 22:24:59 2019 -0800
+
+    build: ensure no VLA is used
+    
+    Cause developer builds to fail for any use of a VLA.
+    VLAs (variable length arrays) limit portability.
+    * configure.ac (nw): Remove -Wvla from the list of disabled warnings,
+    thus enabling the warning when configured with --enable-gcc-warnings.
+    (GNULIB_NO_VLA) Define, disabling use of VLAs in gnulib.  This commit
+    is functionally equivalent to coreutils' v8.30-44-gd26dece5d.
+
+commit 0c8f1ff314cfa132fe2c1cf42b154c8e1e6397c9
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 20 22:24:30 2019 -0800
+
+    build: update gnulib to latest
+    
+    * gnulib: Update to latest.
+    * po/POTFILES.in: Add lib/xstdopen.c.
+
+commit db6d5f7240c8a743aebb3def80b3e3fabf05f0c1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 6 17:22:37 2019 -0800
+
+    diff: use xstdopen, not stdopen
+    
+    * bootstrap.conf (gnulib_modules):
+    * src/cmp.c, src/diff.c, src/diff3.c, src/sdiff.c (main):
+    Use xstdopen, not stdopen.
+
+commit 86ece0ee216910bce0dbceb60b98190bf8f93702
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 6 17:15:06 2019 -0800
+
+    build: update gnulib submodule to latest
+
+commit badccffea49ddc26b72208366f00429cc7ffb9e1
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Jan 5 22:04:57 2019 -0800
+
+    maint: convert all TABs to equivalent spaces in indentation
+    
+    Using this file,
+    
+    cat > leading-blank.exempt <<\EOF
+    (\.gitmodules|help2man|pre-commit)$
+    (?:^|\/)ChangeLog[^/]*$
+    (?:^|\/)(?:GNU)?[Mm]akefile[^/]*$
+    \.(?:am|mk)$
+    EOF
+    
+    run the following command to convert all non-conforming leading white
+    space to be all spaces:
+    
+    git ls-files \
+      | pcregrep -vf leading-blank.exempt \
+      | xargs pcregrep -l '^ *\t' \
+      | xargs perl -MText::Tabs -ni -le \
+        '$m=/^( *\t[ \t]*)(.*)/; print $m ? expand($1) . $2 : $_'
+    
+    Since that changed old NEWS, I also ran "make update-NEWS-hash"
+    to update the old_NEWS_hash value in cfg.mk.
+
+commit 601eceb57cfb87ded594701acc401277c53ff837
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jan 5 19:55:08 2019 -0800
+
+    diff: fix cmp, diff3, sdiff with stdin closed
+    
+    * NEWS: Mention this.
+    * src/cmp.c, src/diff3.c, src/sdiff.c: Include stdopen.h.
+    (main): Call stdopen early.
+    * src/cmp.c (main): Simplify now that we need not worry about
+    stdin being closed.
+    * src/diff.c (main): Translate stdopen diagnostic.
+
+commit 2c9d956aacdfddbb87334c985cd995d75102f789
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jan 5 19:20:11 2019 -0800
+
+    diff: remove unportable ‘diff -N - f <&-’ feature
+    
+    * NEWS: Mention this.
+    * bootstrap.conf (gnulib_modules): Add stdopen.
+    * doc/diffutils.texi (Comparing Directories):
+    Do not document behavior if stdin is closed.
+    * src/diff.c: Include stdopen.h.
+    (main): Call stdopen early.
+    (compare_files) [__hpux]: Remove recently-introduced
+    special case for HP-UX exec with stdin closed.
+    * tests/new-file: Remove tests of the removed feature.
+
+commit 1104d026514014808629f28f2e6c787bf3c520c4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jan 5 18:05:33 2019 -0800
+
+    build: update gnulib submodule to latest
+
+commit b09adbffd5ab987f10f79a69f28b5b26eae95f3c
+Author: Bruno Haible <bruno@clisp.org>
+Date:   Thu Jan 3 20:36:35 2019 +0100
+
+    diff: recognize file descriptors closed by the parent process on HP-UX
+    
+    * src/diff.c (compare_files): Use fcntl to distinguish a file
+    descriptor closed by the parent process from a file descriptor
+    that references /dev/null.
+
+commit 197d7d492f1fd38e7b090f0898dfc286e518f2b7
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 1 18:54:23 2019 -0800
+
+    maint: update all copyright dates via "make update-copyright"
+    
+    * gnulib: Also update submodule for its copyright updates.
+
+commit 70d787ef4400e23601a636f014596e0db2ca79fd
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Dec 31 17:58:56 2018 -0800
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 2de623e7a15d8142c416217bf5634698c3f66fd0
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Dec 31 17:56:36 2018 -0800
+
+    version 3.7
+    
+    * NEWS: Record release date.
+
+commit 04c64737c5df39c3d4ae7a79d5bb3cc06809bf3b
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Dec 31 17:56:23 2018 -0800
+
+    maint: distribute new file, init.cfg
+    
+    Otherwise, strip-trailing-cr would fail on a system without valgrind.
+    * tests/Makefile.am (EXTRA_DIST): Include init.cfg.
+
+commit aaf0efa70d9a72175e7847df196cda21ab3bd3a9
+Author: Dennis Lambe Jr <malsyned@malsyned.net>
+Date:   Sat Dec 29 13:04:10 2018 -0800
+
+    diff: adjust ANSI escapes for compatibility with less -R
+    
+    GNU less can display ANSI-colored text with the -R flag, but this
+    support has some limitations. One of them is that if an escape
+    sequence starts on one line and ends on a different line, only the
+    first line will be colored in less.
+    
+    As a result, when diff creates colored output with multi-line deletes
+    or adds, less will only color the first line.
+    
+    This change resets ANSI color to the default at the end of
+    each line and restarts it at the beginning of the next. It patches
+    normal and context mode. Side-by-side already worked in my testing.
+    * src/context.c (print_context_label, pr_context_hunk): As above.
+    (pr_unidiff_hunk, print_context_header): Likewise.
+    * src/normal.c (print_normal_hunk): Likewise.
+    * tests/colors: Adjust existing tests to accommodate this.
+    * NEWS (Improvements): Mention it.
+    Proposed in http://bugs.gnu.org/31105
+
+commit b9e2f4f3b395c8eff525a95e00ca14e7dd44a5b4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Dec 28 15:23:01 2018 -0800
+
+    tests: fix colors test on systems lacking fractional timestamp support
+    
+    * tests/colors: The .NNNNNNNNN suffix is not printed on some systems.
+    Adapt the test to accommodate those systems.
+
+commit b33a91993401095d3785ede93caa71226eacc5e5
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Dec 28 23:13:01 2018 -0800
+
+    tests: strip-trailing-cr: avoid failure with ASAN
+    
+    Valgrind cannot operate on an ASAN-compiled binary.
+    * tests/strip-trailing-cr (valgrind): Define as no-op when diff
+    was compiled with sanitizer support.
+
+commit c7a4eacac909ec98e3a1ca45643b4a20766864ec
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Dec 28 16:12:11 2018 -0800
+
+    tests: add test for --strip-trailing-cr UMR bug
+    
+    * tests/strip-trailing-cr: New file. Test for today's bug fix.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit a28327bd77be425702927a032f4801338de40203
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Dec 28 16:41:26 2018 -0800
+
+    tests: import test infrastructure from coreutils
+    
+    * tests/init.cfg: New file, for require_valgrind_ definition (from coreutils).
+    * tests/Makefile.am (PATH): Don't set stderr_fileno_ here, since it is
+    now initialized in init.cfg.
+
+commit f8780039532cebb4f4580af1ef7c7d9019080157
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Dec 28 19:00:50 2018 -0800
+
+    diff: fix UMR with --strip-trailing-cr
+    
+    Problem reported by Hongxu Chen (Bug#31935).
+    * src/io.c (prepare_text): Strip trailing CR before
+    doing the rest of the analysis.
+    * NEWS: Mention the fix.
+    Co-authored-by: Jim Meyering <jim@meyering.net>
+
+commit 15668f2c54d095b872cd06d78adde5a525a583e8
+Author: Bruno Haible <bruno@clisp.org>
+Date:   Fri Dec 28 07:34:47 2018 +0100
+
+    tests: colors: avoid test failure on AIX 7
+    
+    * tests/colors: Splice the argument into the printf format string.
+
+commit b18c0155f577d66fac4d12919dbfbf0bbfa8118e
+Author: Bruno Haible <address@hidden>
+Date:   Tue Jan 23 09:04:05 2018 +0100
+
+    maint: don't use an undocumented Autoconf macro
+    
+    * configure.ac: Use AC_CONFIG_HEADERS instead of AC_CONFIG_HEADER.
+
+commit d5bab3afd88a792933c565744a16667beb2e593a
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Dec 23 18:03:13 2018 -0800
+
+    build: avoid build failure with --enable-gcc-warnings and latest gcc
+    
+    * src/diff.c (usage): Assert that each line length is no longer than
+    the minimum required size of 4095.  This lets newer gcc (currently
+    9.0.0 20181219) infer that it need not issue this warning:
+    diff.c:1012:19: error: '%.*s' directive output between 0 and 2147483647
+    bytes may exceed minimum required size of 4095
+    [-Werror=format-overflow=]
+    1012 |        printf ("  %.*s", msglen, msg);
+
+commit 93a1e963e1590d9cb3c1e4f423a5664ee4a589cc
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Dec 23 17:22:02 2018 -0800
+
+    build: update gnulib to latest; and bootstrap and init.sh
+
+commit 15059822384415b62f4f7de593abba7c2e05aa57
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Dec 23 17:24:34 2018 -0800
+
+    build: make the autoconf-2.63 requirement explicit
+    
+    * configure.ac: AC_PREREQ: Require 2.63, not 2.59. And quote properly.
+    Autoconf-2.63 has been required for some time via gnulib.
+    This merely makes it explicit.
+
+commit 6cd60762b225f5d0afa24a8594aac7b2500cd5fe
+Author: Jim Meyering <meyering@fb.com>
+Date:   Thu Dec 20 22:23:27 2018 -0800
+
+    maint: use https: in gnu mirror URL prefix, not http
+    
+    This appears in the generated release announcement message.
+    * cfg.mk (url_dir_list): Use https: prefix, not http:.
+
+commit ffd63aedad3c0eb08ebb27103e5f242f8732dc0c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jul 24 10:18:28 2018 -0700
+
+    cmp: fix bug in -b diagnostic
+    
+    Problem reported by mancha (Bug#32249).
+    * src/cmp.c (count_newlines): Restore old value of sentinel.
+    * tests/cmp: Test for the bug.
+
+commit 612db4defaabc086f0c4303499dc41aee003fc69
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jul 24 10:09:30 2018 -0700
+
+    build: update gnulib submodule to latest
+
+commit 576645cdf71342ba8eb60930998655a99b7a8da1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 12:44:30 2018 -0700
+
+    doc: prepend "GNU" to NAME in man pages
+    
+    Requested by RMS.
+    * src/cmp.c, src/diff.c, src/diff3.c, src/sdiff.c:
+    Prepend "GNU" to first comment, so that the man page says "GNU".
+
+commit 56225ecca4f9598c0c9dbd7c46a51dd4816a383f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 20 13:39:15 2018 -0700
+
+    sdiff: port to mingw
+    
+    Problem reported by Ross Burton (Bug#31218).
+    * src/sdiff.c (checksigs): Use ‘raise’, not ‘kill’.
+
+commit 9b87043d8d8fb977ac07db074289571ac745e493
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 23 11:29:51 2018 -0700
+
+    build: update gnulib submodule to latest
+
+commit 5dc851ad24cde08abe3660ffecfe2c5e87203c6d
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 14 17:16:50 2018 -0800
+
+    tests: fix quoting error in previous change
+    
+    * tests/colors: Double-quote $PATH.
+
+commit 915003de198a66ffe5a5692d875c185eb2b9e923
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Jan 6 16:24:10 2018 -0800
+
+    tests: port tests/colors to some env-munging shell
+    
+    * tests/colors: Also set PATH="$PATH" in env invocation.
+
+commit 4a38f715f1fe171f6792f3044bd15d6a263b8c1c
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Jan 6 16:49:13 2018 -0800
+
+    maint: update gnulib and copyright dates for 2018
+    
+    * gnulib: Update to latest.
+    * all files: Run "make update-copyright".
+    * bootstrap: Update from gnulib.
+
+commit 81eea1db38a934e38b9307059a57c1c76fbf6163
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Jan 6 16:44:03 2018 -0800
+
+    maint: suppress gcc's new -Wcast-function-type in gnulib
+    
+    * configure.ac (WERROR_CFLAGS): Suppress gcc's new -Wcast-function-type
+    warning in gnulib, because it would trigger on this:
+    sig-handler.h:47:12: error: cast between incompatible function types\
+      from 'void (* const)(int,  siginfo_t *, void *)' \
+      {aka 'void (* const)(int,  struct <anonymous> *, void *)'} \
+      to 'void (*)(int)' [-Werror=cast-function-type]
+    return (sa_handler_t) a->sa_sigaction;
+
+commit b50ab11f235eb214d8cce710bda068365accb6e9
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Oct 20 23:13:54 2017 -0700
+
+    tests: add expected-failing test for minor subopimality
+    
+    In some unusual cases, diff -u prints suboptimal output.
+    * tests/large-subopt: New test script.
+    * tests/Makefile.am (TESTS): Add it.
+    (XFAIL_TESTS): Add it here, too, to record that this test is
+    currently expected to fail.
+    * tests/large-subopt.in1, tests/large-subopt.in2: Inputs derived from
+    those in http://bugs.gnu.org/28796
+
+commit 7ba026cae3c7b7780f1c4ead9b475f00458742d6
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Sep 23 21:47:29 2017 -0700
+
+    gnulib: update to latest
+
+commit 487e009ed7294021dcc0b66c2b5a5046aea51ab4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun May 21 15:27:10 2017 -0700
+
+    maint: make the announcement template Cc the devel- list
+    
+    * cfg.mk (announcement_Cc_): Define.
+
+commit 592e503b48e42981b0a7fa308a6c3b06f08d582b
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun May 21 13:27:36 2017 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit e73a3d5e44c2e46e2ae947eb99b3834874a601a8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun May 21 13:25:42 2017 -0700
+
+    version 3.6
+    
+    * NEWS: Record release date.
+
+commit 7c2a2d63f42135f676aec054583242734ef348c2
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri May 19 17:14:09 2017 -0700
+
+    gnulib: update to latest
+
+commit d3b51e7f02994c76b88b83857e253b4116706f91
+Author: Jim Meyering <meyering@fb.com>
+Date:   Wed May 17 22:51:31 2017 -0700
+
+    maint: update to work with GCC7's -Werror=implicit-fallthrough=
+    
+    * src/system.h (FALLTHROUGH): Define.
+    Use new FALLTHROUGH macro in place of comments
+    * src/cmp.c: FIXME
+    * src/diff3.c: FIXME
+    * src/ifdef.c: FIXME
+    * src/sdiff.c: FIXME
+    * src/side.c: FIXME
+    * src/util.c: FIXME
+
+commit 646268f5c6472d248ae0e98960f7983656a9d0e3
+Author: Jim Meyering <meyering@fb.com>
+Date:   Thu May 18 09:23:06 2017 -0700
+
+    gnulib: update to latest
+
+commit 20b31314c3d72af7159cc6ba3cdb9b1288263858
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue May 9 11:55:46 2017 -0700
+
+    tests: new-file: closed-stdin: also ensure stdout was empty
+    
+    * tests/new-file: Also require that "out" be empty.
+
+commit c881afb9b82a4943b47880d2e607825ceff286be
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat May 6 12:09:43 2017 -0700
+
+    maint: stop using @acronym{...} in texinfo sources
+    
+    * doc/diffutils.texi: Remove all uses of @acronym{...},
+    per recommendation by Karl Berry.
+    * cfg.mk (local-checks-to-skip): Remove exemption, enabling
+    the @acronym{-prohibiting syntax-check rule.
+
+commit ac05c6d549bb0731386ca2251c92b91be2e95228
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu May 4 17:17:23 2017 -0700
+
+    cmp: improve EOF diagnostic
+    
+    This improves on yesterday's change, following up on a
+    remark by Jim Meyering (Bug#22816#21).
+    * doc/diffutils.texi (Invoking cmp, cmp Options): Follow POSIX more
+    closely in the documentation of the information appended to the EOF
+    diagnostic.
+    * src/cmp.c (cmp): Be more specific about the shorter file's length
+    and fix some off-by-1 issues in reporting line counts.
+    * tests/cmp: Adjust to match new behavior.
+    Don't assume internal details about stdio buffering.
+
+commit 98b6fc2f320cfb6a1b55dc032b7de26188c04479
+Author: Benno Schulenberg <bensberg@justemail.net>
+Date:   Sat Feb 4 10:55:54 2017 +0100
+
+    diff: describe each --help option with a single string
+    
+    * src/diff.c: To ease translating, fuse four description pieces
+    into two whole ones.  Also reword and rewrap one of them to fit
+    within eighty characters.
+
+commit 1b1526b4f57649d206c61f494d4f7ac48fa12a45
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu May 4 17:17:23 2017 -0700
+
+    cmp: report prefix length when one file is shorter
+    
+    Requested by Dan Jacobson (Bug#22816).
+    * NEWS:
+    * doc/diffutils.texi (Invoking cmp, cmp Options): Document this.
+    * src/cmp.c (cmp): Implement it.
+    * tests/Makefile.am (TESTS): Add cmp.
+    * tests/cmp: New file.
+
+commit 4e40686e23dba2e89aec76ee009049602caa19ca
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue May 2 19:52:37 2017 -0700
+
+    tests: add test for latest fix
+    
+    * NEWS (Bug fixes): Describe it.
+    * tests/invalid-re: New test for just-fixed bug.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit af6d2e0dbddcdcd52ba36636c72b3ffa774238c8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue May 2 16:28:30 2017 -0700
+
+    gnulib: update to latest
+
+commit 2acb5aae869310f75dc8aa4d81a6b2e4870c1000
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Apr 27 22:39:07 2017 -0700
+
+    diff: don't crash if regexp is invalid
+    
+    Problem reported by Marcel Böhme in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2017-04/msg00002.html
+    * src/diff.c (add_regexp): Exit if re_compile_pattern fails.
+
+commit 7c636563c24982f6eb7896ef8aa24e6f78c5d48b
+Author: julama <julama@fake-box.com>
+Date:   Wed Mar 22 21:38:32 2017 -0700
+
+    tests: avoid false failure for unreadable /proc/cmdline
+    
+    * tests/brief-vs-stat-zero-kernel-lies: Use "test -r" rather than
+    just "test -f".  This avoids a false test failure on a linux system
+    with grsecurity and its GRKERNSEC_PROC_USER option enabled, for which
+    /proc/cmdline is unreadable.  Reported in https://bugs.gnu.org/26155
+
+commit 198c55a64557c89f201ddea7cbcb14c09c400071
+Author: Jim Meyering <meyering@fb.com>
+Date:   Wed Feb 1 23:06:29 2017 -0800
+
+    tests: avoid false failure with some shells on debian, freebsd
+    
+    * tests/colors: Move the TERM=dumb setting into the code run by
+    "returns_", since some shells do not propagate envvar setting through
+    to a use of a function like this.  That would cause this test to fail
+    because results were colorized when they should not have been.
+    Reported by Nelson Beebe.
+
+commit affa30def0d530022a03845372ec19c644f8f1ac
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 17:06:10 2017 -0800
+
+    maint: add "introduced in 3.4" in latest NEWS entry
+    
+    * NEWS: Update.  Also, thanks to Nelson Beebe for reporting this.
+
+commit eaa2a24345fba918eb7ad7a6a263e7e639d82d5f
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 16:44:03 2017 -0800
+
+    diff: avoid UMR with ---presume-output-tty
+    
+    * src/diff.c (main): Always define presume_output_tty.
+    Otherwise, it would be read uninitialized.
+    Introduced in v3.3-45-g17e2698
+    * NEWS (Bug fixes): Mention it.
+
+commit 8420aff7e0eac5b6d02dcb60b88b9f9c2150f85a
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 10:36:25 2017 -0800
+
+    gnulib: update to latest; and update bootstrap and init.sh
+
+commit 75173432ed47ae77d3024da8e5daa70f1f8d2650
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 10:45:11 2017 -0800
+
+    maint: change "time stamp" to "timestamp" globally
+    
+    This avoids a new syntax-check failure.
+    * ChangeLog-2008: Perform that change.
+    * doc/diffutils.texi: Likewise.
+    * NEWS: Likewise.
+    * cfg.mk: Update the old news hash accordingly.
+
+commit 90106d33ab3004872f8cfe46779683be48b7bd12
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 1 03:22:44 2017 -0800
+
+    maint: update gnulib and copyright dates for 2017
+    
+    * gnulib: Update to latest.
+    * all files: Run "make update-copyright".
+
+commit a9cc55101cc9c10cf7a8857034fef88559f4c656
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Oct 30 12:13:13 2016 -0700
+
+    tests: use "returns_" rather than explicit comparison with "$?"
+    
+    * tests/colors: Use "returns_ 1" rather than testing $? = 1
+    * tests/basic: Likewise.
+    * tests/binary: Likewise.
+    * tests/filename-quoting: Likewise.
+    * tests/function-line-vs-leading-space: Likewise.
+    * tests/ignore-matching-lines: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/new-file: Likewise.
+    * tests/no-dereference: Likewise.
+    * tests/no-newline-at-eof: Likewise.
+    * tests/stdin: Likewise.
+
+commit 68b82f6f8419a815cfcf962b3061352d414dc606
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 25 21:57:56 2016 -0700
+
+    diff: fix big performance degradation in 3.4
+    
+    * NEWS, doc/diffutils.texi (Overview): Document this.
+    * src/analyze.c (diff_2_files): Restore too_expensive heuristic,
+    but this time with a floor that is 16 times the old floor.  This
+    should fix Bug#16848, by generating good-quality output for its
+    test case, while not introducing Bug#24715, by running nearly as
+    fast as diff-3.3 for that test case.
+
+commit 571f01c069dfc7f860e5500a5d08ebfdaf9c3068
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 25 21:52:31 2016 -0700
+
+    build: update gnulib submodule to latest
+
+commit 1c1de418606f163a0027b3e7305ca91708616219
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Oct 16 08:43:14 2016 -0700
+
+    maint: use die rather than error
+    
+    Use "die (N, ..." rather than "error (N, ..." whenever N is a nonzero
+    constant.  That lets the compiler know that control never goes beyond
+    that point, and thus makes unnecessary the occasional following
+    "abort ();" or "break;" statement we have historically added to inform
+    static analysis tools of this aspect of "error" semantics.
+    * src/die.h: New file.
+    * src/Makefile.am (noinst_HEADERS): Add it.
+    * src/cmp.c: Use die in place of error whenever the first
+    argument is a nonzero constant.  Also remove any immediately-
+    following call to abort, and include "die.h".
+    * src/diff.c: Likewise.
+    * src/diff3.c: Likewise.
+    * src/sdiff.c: Likewise.
+    * src/util.c: Likewise.
+
+commit 84387b8f5fa66ecb4c2ac46a2a8cde909222f090
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Oct 1 13:00:35 2016 -0700
+
+    gnulib: update to latest
+
+commit 8db62fe5ec9b81899c39461c4380fcf2bb7a9d82
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Oct 2 10:56:55 2016 -0700
+
+    build: avoid GCC 7's new warnings
+    
+    * src/util.c (get_funky_string): Adjust comment so that GCC 7's
+    -Wimplicit-fallthrough recognizes it.
+    * src/diff3.c (main): Cast boolean MERGE to "int" to avoid this:
+    diff3.c:341:25: error: '~' on a boolean expression \
+    [-Werror=bool-operation]
+
+commit ff2b22a8b3fafe6407ecebd95ddc41a13551879b
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 30 12:41:38 2016 -0700
+
+    gnulib: update to latest
+
+commit 65185e4c62028b468ad8a0602a33561561d9d0be
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 29 20:07:16 2016 -0700
+
+    gnulib: update to latest, to port to upcoming GCC 7
+    
+    This fixes compilation errors when using gcc-7-to-be that were
+    due to missing backslashes in gnulib's intprops.h and an API
+    change in functions like __builtin_add_overflow.  This ports
+    to GCC 7's newer built-in overflow-checking functions.
+
+commit 688f4fb211b603050ef7efd6cbe1db63b31f2fd7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 28 16:46:34 2016 -0700
+
+    diff: don't assume ptrdiff_t <= long long int
+    
+    * src/system.h (printint, pI): Port to (theoretical) platforms
+    where ptrdiff_t is wider than long long int (Bug#24311).
+
+commit f2712fcddff9c7ff571b19ace30d0d3a195ebde8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Aug 27 14:59:13 2016 -0700
+
+    diff: port line numbers to mingw64
+    
+    Problem reported by Peter Rosin (Bug#24311).
+    * src/system.h (printint, pI): New typedef and macro.
+    All uses of 'long int' and "%l" in printf format replaced by
+    'printint' and "%"pI respectively.
+    * src/ifdef.c (do_printf_spec): Don't assume pI is length 1.
+
+commit 34823e7e6770042ec5d7349218efdb34307349e9
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 20 22:23:28 2016 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit d1145efd81ffbcc0b00f138ede826d3d6f640200
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 20 22:21:26 2016 -0700
+
+    version 3.5
+    
+    * NEWS: Record release date.
+
+commit 24792668f02cb915a170a8098d945da325287288
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 16 22:20:28 2016 -0700
+
+    build: arrange to build with -fno-common, when possible
+    
+    * configure.ac (WERROR_CFLAGS): Add -fno-common, when possible.
+    This would have prevented the duplicate definition of
+    presume_output_tty that was fixed in v3.4-10-gc2dc91f.
+
+commit c2dc91f1968c6ccd8ba623f9fa391f529ab800ab
+Author: Hanno Böck <hanno@hboeck.de>
+Date:   Tue Aug 16 22:02:13 2016 -0700
+
+    diff: avoid duplicate definition of presume_output_tty
+    
+    * src/util.c (presume_output_tty): Remove this definition.
+    The other is in diff.h.  Reported in https://bugs.gnu.org/24248
+
+commit d6474c4c512d9196d7d9a6086a96eac6813a5c19
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Aug 14 17:16:59 2016 -0700
+
+    gnulib: update to latest
+
+commit c61efccd23c827a03bdd1d41211c70479a632b86
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Aug 14 22:25:49 2016 -0700
+
+    tests: diff3: work around missing seq on some systems
+    
+    * tests/diff3 (seq): Provide a seq replacement function,
+    since at least AIX, SunOS 5.10, OpenBSD-5.8 lack it.
+    Reported by Assaf Gordon in https://bugs.gnu.org/24227#8
+
+commit edd942ca27d570a33d612b12eecaa33a76640e46
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Aug 12 21:40:29 2016 -0700
+
+    diff3: fix leaks, for real
+    
+    * src/diff3.c (struct diff_block)[lint]: Add member, n2.
+    (free_diff_block, next_to_n2): New functions.
+    * tests/diff3: Add more test coverage.
+
+commit b3def738f3b435cbe6f2a8406bae5a71175a0b80
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Aug 12 11:17:26 2016 -0700
+
+    maint: require that commit messages be of a certain form
+    
+    * bootstrap.conf (bootstrap_epilogue): Merge from coreutils, so that
+    a local commit hook will now help enforce consistent commit messages.
+    * Makefile.am (check-git-hook-script-sync): New rule, largely copied
+    from coreutils.
+    * scripts/git-hooks/commit-msg: New file, from coreutils, but
+    with adapted list of program names.
+    * scripts/git-hooks/applypatch-msg: New file, from git.
+    * scripts/git-hooks/pre-applypatch: Likewise.
+    * scripts/git-hooks/pre-commit: Likewise.
+
+commit 1a0df4396ebe3b9a58b882bb976cfce3f50d3cac
+Author: Bastian Beischer <bastian.beischer@rwth-aachen.de>
+Date:   Sat Aug 13 18:53:36 2016 -0700
+
+    diff3: fix heap use-after-free; add minimal diff3 test coverage
+    
+    Commit v3.3-42-g3b74a90, "FIXME: src/diff3: plug a leak" added an
+    invalid use of free, leading to use-after-free in nearly any invocation
+    of diff3.  Revert that commit.
+    * NEWS (Bug fixes): Mention it.
+    * tests/diff3: New file, to add minimal test coverage.
+    * tests/Makefile.am (TESTS): Add it.
+    Reported by Bastian Beischer in http://bugs.gnu.org/24210
+
+commit 88d911dbc717494febee4b0ebc790808054fefff
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 13 19:40:20 2016 -0700
+
+    build: ignore texinfo build artifacts
+    
+    * .gitignore: Ignore texinfo artifacts in doc/.
+
+commit 1b3907f976df79e45063901d5f7de76e3f1c7f43
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 13 19:42:57 2016 -0700
+
+    maint: diff3: remove an unreachable statement
+    
+    * src/diff3.c (main): Remove unreachable "return" after exit from main.
+
+commit 697c1f4fa93ac971c487725e9e53fc211cd3c670
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 8 18:50:15 2016 -0700
+
+    diff: disable colorization for TERM=dumb
+    
+    * src/diff.c (main): With --color or --color=auto, when TERM is
+    "dumb", disable colorization.  Suggested by Daniel Colascione.
+    * NEWS (Bug fixes): Mention it.
+    * tests/colors: Add a test that would fail without this change,
+    yet passes with it.
+
+commit 09369932527342a4fb0ccc6677184c3d3ce7fc49
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 8 10:14:00 2016 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 5ac64141edd699566edfa9a6659c0d7586f019e4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 8 10:10:51 2016 -0700
+
+    version 3.4
+    
+    * NEWS: Record release date.
+
+commit 05476e882f0aa6b032d7cf3859214210a5ccc1fb
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 6 13:50:06 2016 -0700
+
+    gnulib: update to latest
+
+commit 91d23408864f70ce2da19d0b272b298e72fad018
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 6 11:19:07 2016 -0700
+
+    tests: tweak built_programs definition
+    
+    * tests/Makefile.am (built_programs): Adjust to work around what
+    may be a problem due to interaction between Solaris 10's /bin/sh
+    and an old version of GNU make. Reported by Dagobert Michelsen
+    in https https://bugs.gnu.org/24137.
+
+commit a37c5846867defe109e1eefe550793cd8947fbb2
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 2 19:09:20 2016 -0700
+
+    gnulib: update to latest
+
+commit 38e3a1dd49d6a2793eb990da60efae25a2ba1fcf
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 2 09:30:06 2016 -0700
+
+    tests: skip a /proc/self-dependent test on the Hurd
+    
+    * tests/brief-vs-stat-zero-kernel-lies: The Hurd's /proc/self
+    is not useful, so detect that and skip the test that requires it.
+    Reported by Assaf Gordon in https://debbugs.gnu.org/24121#29
+
+commit df14e616b3d497c611edb04d6071b09565f65434
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 1 09:23:03 2016 -0700
+
+    tests/colors: fix portability problem with touch --date
+    
+    * tests/colors (epoch): Don't use GNU touch's --date=$epoch option.
+    Use the portable -t 197001010000.00.
+    Reported by Assaf Gordon in https://debbugs.gnu.org/24121#8
+
+commit 47f84d5a75bd46822c000ceab4abea5c11079d17
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 1 08:03:22 2016 -0700
+
+    build: Solaris 9: avoid link failure due to isblank use
+    
+    * bootstrap.conf (gnulib_modules): Add isblank, to avoid a link
+    error on Solaris 9 Sparc.  Reported by Dagobert Michelsen.
+
+commit b43e6fed25d5fbd0243224753e14be2f4eb00b7e
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jul 31 21:29:21 2016 -0700
+
+    test: improve test infrastructure
+    
+    * tests/envvar-check: New file, copied from grep, with the addition
+    of the EDITOR and GREP_OPTIONS envvar names.
+    * tests/Makefile.am (EXTRA_DIST): Add it.
+    (TESTS_ENVIRONMENT): Revamp, to be more like that of grep.
+
+commit e974118719b9f79adf36454151b13eb2622faa93
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jul 31 17:46:17 2016 -0700
+
+    maint: remove gl/lib/reg*.c.diff; no longer needed
+    
+    * gl/lib/regcomp.c.diff: Remove file, now that gnulib's
+    regcomp.c compiles regex.c with -Wno-unused-parameter.
+    * gl/lib/regex_internal.c.diff: This file induced a change to ensure
+    that the "Idx" type was unsigned and to remove a few "VAR < 0"
+    comparisons.  These days, it is probably fine to stay in sync with
+    gnulib/glibc's copies
+    of these files, so remove these patches, too.
+    * gl/lib/regexec.c.diff: Likewise.
+    Prompted by a report by Assaf Gordon and a suggestion from Paul Eggert.
+
+commit 55596fcd4846a802da9bce831547a9a01e4cbe15
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jul 31 17:33:34 2016 -0700
+
+    tests: colors: fix a portability problem and work around a shell bug
+    
+    * tests/colors (e): Fix a portability bug: use printf '\033'
+    rather than '\e' to generate the required byte sequence, since
+    for some shells (at least dash 0.5.8), the latter doesn't work.
+    Work around a shell bug whereby "local tab=$(printf '\t')"
+    would result in an empty value for "$tab": hoist each "tab"
+    definition up/out of its function to global scope.
+    Reported by Assaf Gordon in http://debbugs.gnu.org/24116#8
+
+commit 0353af91a02d1bd14b18d10293f1ef27dd6c0a58
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Jul 23 16:33:35 2016 -0700
+
+    gnulib: update to latest; and tests/init.sh
+    
+    * gnulib: Update to latest.
+    * init.sh: Update from gnulib.
+
+commit a10ff125c8ff7fbaf1100cd41ea4e8ac0d594c82
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Apr 2 18:42:19 2016 -0700
+
+    maint: arrange for "make distcheck" to work with unreleased automake
+    
+    * dist-check.mk (my-distcheck): Remove all .deps directories
+    before performing the recursive comparison.
+
+commit 752679190cf610ea32c54d625c368bb87da156fc
+Author: Glenn Morris <rgm@gnu.org>
+Date:   Tue May 24 19:51:36 2016 -0700
+
+    doc: fix a reference to emacs' emerge node
+    
+    * doc/diffutils.texi (Interactive Merging): Correct a reference to
+    emacs' emerge node: s/emerge/Emerge/.
+    This addresses http://debbugs.gnu.org/23613
+
+commit 8c19e4a18ef037b97054f6ea4aefa94f62ac9dbc
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Apr 30 19:23:24 2016 +0100
+
+    maint: arrange for better URLs in generated announcement message
+    
+    * cfg.mk (url_dir_list): Define.  I had been correcting the generated
+    URLs by hand, just before the announcement.  This is better.
+
+commit 5a485511d77a23d144a05266482ce89171249156
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Mar 15 10:38:23 2016 -0700
+
+    maint: don't ignore gitlog-to-changelog failure
+    
+    * Makefile.am (gen-ChangeLog): Don't ignore failure of
+    gitlog-to-changelog. This syncs to coreutils' copy of this rule.
+
+commit 17e2698bcbee30a6cc282d61ad6242a64ba9c7cf
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Feb 1 09:58:52 2016 +0100
+
+    diff: --color: fix an infinite recursion bug
+    
+    * src/diff.h (presume_output_tty): New extern variable.
+    * src/diff.c (PRESUME_OUTPUT_TTY_OPTION): New enum.
+    (group_format_option): Add '-presume-output-tty'.
+    (main): Handle PRESUME_OUTPUT_TTY_OPTION.
+    * src/util.c: New variable `presume_output_tty'.
+    (check_color_output): Handle presume_output_tty.
+    (set_color_context): Call process_signals only when color_context is
+    not RESET_CONTEXT.
+    * tests/colors: Check that diff doesn't crash when interrupted
+    in the middle of a color sequence.
+    
+    Reported by Gisle Vanem in http://debbugs.gnu.org/22067
+
+commit 3d8affcc9dd85da0de0121e95a6f932d68feb5fa
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 31 18:01:27 2016 -0800
+
+    maint: update prereq version of gettext
+    
+    * configure.ac: Increase designated gettext version to 0.19.2
+    * bootstrap.conf (buildreq): Likewise.
+    Remove now-unnecessary code to remove gettext-provided files.
+
+commit a19bcfd9e7eec512abb774797da33c630b632082
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 31 16:53:39 2016 -0800
+
+    gnulib: update to latest
+
+commit 3b74a905c5460e7979c53273ac90345860d001a7
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Jan 1 18:24:25 2016 -0800
+
+    FIXME: src/diff3: plug a leak
+
+commit 7346a030108e032b0e8523f381f1a95b91806890
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Jan 1 15:06:05 2016 -0800
+
+    maint: update copyright year, bootstrap, init.sh
+    
+    Run "make update-copyright" and then...
+    
+    * gnulib: Update to latest.
+    * tests/init.sh: Update from gnulib.
+    * bootstrap: Likewise.
+
+commit a3ea9cd5cb911a0319c81b01e205b24c92a8535c
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Nov 28 18:02:05 2015 -0800
+
+    diff --brief no longer mistakenly reports diff. with 0-sized /proc/ files
+    
+    Normally, it is safe to assume two regular files are different when
+    their st_size values are different.  However, that assumption may
+    be invalid if either value is zero, as happens with files on Linux
+    /proc and /sys file systems. Since skipping this optimization will
+    usually cost very little (one read syscall, to read zero bytes),
+    it is fine to accommodate those unusual files.
+    * src/analyze.c (diff_2_files): Do not assume regular files differ
+    just because their st_size values differ when one or more is 0.
+    * src/diff.c (compare_files): Likewise.
+    * tests/brief-vs-proc-stat-zero: New test.
+    * tests/Makefile.am: Add it.
+    * NEWS (Bug fixes): Describe it.
+    Reported by Stephan Müller in http://debbugs.gnu.org/21942
+
+commit a1140dd45845d838401425f9a3c0af944abb5795
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Dec 6 10:38:17 2015 -0800
+
+    tests: arrange to print any skipped-test explanation to tty, too
+    
+    I noticed that when a test was skipped, the reason was not printed.
+    This fixes it.  In coreutils, this variable is set in init.cfg,
+    but there is no point in putting the definition so far from the
+    code that chooses the file descriptor number in tests/Makefile.am.
+    * tests/Makefile.am (TESTS_ENVIRONMENT) [stderr_fileno_]: Define
+    here (to 9), right next to the companion "9>&2".
+
+commit d77f95f8dcbfa6e160d74e07cbd5f7def737975e
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Nov 28 19:29:37 2015 -0800
+
+    build: add gperf to the list of required programs
+    
+    * bootstrap.conf (buildreq): Add gperf to the list.
+    Reported by Stephan Müller in http://debbugs.gnu.org/21945
+
+commit 875ca7183bd4b098f2d8fb71b10553df2d4d2d11
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Nov 2 19:05:10 2015 +0000
+
+    tests: Add tests for --color and --palette
+    
+    * tests/colors: New file.
+    * tests/Makefile.am (TESTS): Add colors.
+
+commit 0e72de47952beead69e44a4a8c9b4994992ef8ac
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Nov 2 19:03:32 2015 +0000
+
+    doc: mention --color and --palette in NEWS
+
+commit 04f6d57177fb6c9e7bbcf716c521bc323936a9a5
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Oct 19 10:29:41 2015 +0200
+
+    diff: add --palette
+    
+    * bootstrap (gnulib_modules): Add 'argmatch'.
+    * doc/diffutils.texi: Add documentation for --palette
+    * src/diff.h (set_color_palette): New prototype.
+    * src/diff.c (set_color_palette): New function.
+    (color_palette): New variable.
+    * src/utils.c: Include "argmatch.h".
+    (struct bin_str): New struct.
+    (struct color_ext_type): New struct.
+    (color_indicator): New array.
+    (indicator_name): New array.
+    (indicator_no): New enum.
+    (parse_state): New enum.
+    (put_indicator): New function.
+    (get_funky_string): New function. Copied from coreutils ls.
+    (parse_diff_color):  New function. Copied from coreutils ls
+    "parse_ls_color" function.
+    (set_color_context): Use put_indicator instead of directly
+    outputting the sequence.
+    * po/POTFILES.in: Add 'lib/argmatch.c'
+
+commit c0fa19fe92da71404f809aafb5f51cfd99b1bee2
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Sun Mar 8 22:45:11 2015 +0100
+
+    diff: add support for --color
+    
+    * doc/diffutils.texi (diff Options): Add documentation for --color.
+    Copied from coreutils ls --color.
+    * src/context.c (pr_unidiff_hunk): Set the color context.
+    (print_context_header): Likewise.
+    (pr_context_hunk): Likewise.
+    * src/diff.h (enum colors_style): New enum to record when to use colors.
+    (colors_style): New variable to memorize the argument value.
+    (set_color_context): Add function definition.
+    * src/diff.c: : Define COLOR_OPTION.
+    (specify_colors_style): New function.
+    (longopts): Add --color.
+    (main): Handle --color argument.
+    (option_help_msgid): Add usage string for --color.
+    * src/normal.c (print_normal_hunk): Set the color context.
+    * src/side.c (print_1sdiff_line): Likewise.
+    * src/util.c (print_1_line_nl): New function.
+    (print_1_line): Make it a wrapper of 'print_1_line_nl'.
+    (colors_enabled): New boolean variable.
+    (begin_output): Call check_color_output once the output file is
+    configured.
+    (output_1_line): Periodically call `process_signals'.
+    (caught_signals): New sigset_t.
+    (colors_enabled): New boolean variable.
+    (interrupt_signal): New sig_atomic_t.
+    (stop_signal_count): New sig_atomic_t.
+    (check_color_output): New function.
+    (install_signal_handlers): Likewise. Copied from coreutils ls.
+    (process_signals): Likewise.  Copied from coreutils ls.
+    (set_color_context): New function.
+    (sighandler): Likewise.  Copied from coreutils ls.
+    (stophandler): Likewise.  Copied from coreutils ls.
+
+commit b4efca9de418c0166f0b106fef068a594b4ab483
+Author: Andreas Grünbacher <agruen@gnu.org>
+Date:   Thu Sep 24 07:36:31 2015 -0700
+
+    diff: Improve help text of option --label
+    
+    * src/diff.c (option_help_msgid): Improve help text of option --label.
+
+commit 2cd4ff3a5ff52d89b6b992d158f389b757f4faf4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 31 23:12:43 2015 -0700
+
+    build: correct man-page generation rule
+    
+    The PATH was set incorrectly, so that the diff used by
+    help2man was the one from $PATH, rather than the just-built
+    one.
+    * man/Makefile.am (bin_dir): New variable, to...
+    (dist_man1_MANS): ...prepend ../src to PATH, not just "..".
+    Also, add a test to ensure that each $(bin_dir)/$$base is
+    executable, so this doesn't happen again.
+    In http://debbugs.gnu.org/21023, Rodrigo Valiña
+    Gutiérrez reported that diff.1 from the diffutils-3.3 tarball
+    contained no description of the then-new --no-dereference option.
+
+commit 5801f8add854c842e8065225d261f459089d7ac8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Jul 10 09:55:43 2015 -0700
+
+    doc: --no-dereference: improve wording/description
+    
+    * doc/diffutils.texi (Comparing Directories): Correct grammar.
+    (diff Options) [--no-dereference]: Say a little more.
+
+commit 29e8de4885e0d9f2b4fd2ed9acc09d4a41267329
+Author: Jim Meyering <meyering@fb.com>
+Date:   Thu Jan 1 22:17:39 2015 -0800
+
+    maint: update copyright year ranges to include 2015; update gnulib
+
+commit ec60c3b6d1754ad88ffd7fc2f00b72ae835f9ca8
+Author: KO Myung-Hun <komh@chollian.net>
+Date:   Tue Jul 15 11:50:53 2014 +0900
+
+    diff: skip test if seek is not possible on OS/2 kLIBC
+    
+    This fixes the problem that 'diff - file' and 'cat file | diff - file'
+    fail due to a seek failure with a message 'diff.exe: -: Invalid seek',
+    because seek does not work on stdin and a pipe on OS/2 kLIBC.
+    
+    * src/io.c (sip): Set skip_test to true if seek is not possible on
+    OS/2 kLIBC.
+
+commit ecf6a420586272e618652a33074bc38de75052dc
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Dec 9 06:51:03 2014 -0800
+
+    gnulib: update to latest
+
+commit 3ef90a7e7cc5f318ff7b4e674d717e1cb6dc2d1d
+Author: KO Myung-Hun <komh78@gmail.com>
+Date:   Tue Dec 9 06:49:25 2014 -0800
+
+    build: double-quote use of $PATH
+    
+    * man/Makefile.am (dist_man1_MANS): On OS/2, PATH_SEPARATOR is ';',
+    but unquoted, that is interpreted as the shell's statement
+    terminator.  Quote it.
+
+commit 1fa6140faacb29e44f2d666c74529ed27b0abb5a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 27 19:53:08 2014 -0700
+
+    diff: fix integer overflow problem with --tabsize
+    
+    Reported by Tobias Stoeckmann in: http://bugs.gnu.org/18857
+    * src/diff.c (main): Don't overflow if INTMAX_MAX / 2 < tabsize.
+    * tests/bignum: New file, to test for this bug.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit df3af29627a92495a740da13cb8bb0d4fcc1bf84
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 3 16:02:35 2014 -0700
+
+    doc: mention diff -B fix in NEWS
+
+commit d2fd9d4683ef60c259a3b426f71cef1b89ff383d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 3 15:58:03 2014 -0700
+
+    diff: fix bug with diff -B and incomplete lines
+    
+    Reported by Navin Kabra via Eric Blake in:
+    http://bugs.gnu.org/18402
+    * src/util.c (analyze_hunk): Don't mishandle incomplete
+    lines at end of file.
+    * tests/no-newline-at-eof: Test for the bug.
+
+commit 7bdd6479ce43d6b45803fd0bc4b363370975ceab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 3 15:25:21 2014 -0700
+
+    diff: fix performance bug with prefix computation
+    
+    * src/io.c (find_identical_ends): Fix performance bug:
+    the test for when the prefix was needed messed up by
+    the 2002-02-28 integer-overflow fixes, causing performance to be
+    worse than it needed to be.
+
+commit b6e691277288c4e8d53b1d2577137d265008d13e
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 23 14:10:20 2014 -0700
+
+    gnulib: update to latest, as well as bootstrap
+
+commit cfcba8735034e5aa4dae7fa4b3290ef25b0c3c52
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jun 8 19:10:24 2014 -0700
+
+    maint: update copyright year range in texinfo documentation
+    
+    * doc/diffutils.texi: Update copyright.
+
+commit 667864f2844c417090149b7948052fbd757d3b48
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Dec 23 07:06:41 2013 -0800
+
+    maint: update bug-reporting address
+    
+    * README: Change bug-gnu-utils@... to bug-diffutils@gnu.org.
+    * doc/diffutils.texi: Likewise.
+    Reported by Jamie Landeg Jones.
+
+commit f6f1b1b49c5dc1c8265f457012cdd78fe71ad4f5
+Author: Paul Eggert <eggert@penguin.cs.ucla.edu>
+Date:   Wed Mar 26 11:12:12 2014 -0700
+
+    diff: fix two "..." typos in --help output
+    
+    * src/diff.c (option_help_msgid): Remove two "..." typos (Bug#17102).
+
+commit fee3cad6b7e039e7bba524c3264f368af69396cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 25 17:55:26 2014 -0700
+
+    doc: improve documentation about reading and stdin
+    
+    See Bug#17075.
+    * doc/diffutils.texi (Comparison): Say that files need not be read.
+    (Invoking diff): Remove confusing remark about 'diff - -'.
+    It's not that useful, and it's not portable anyway.
+
+commit ed8975e7de513e0edaf77ea3f15dcce3f39b8d97
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Feb 24 21:56:21 2014 -0800
+
+    diff, sdiff: minor integer overflow fixes
+    
+    * src/context.c (find_hunk):
+    Simplify, now that 2 * context + 1 cannot overflow.
+    * src/diff.c (main):
+    * src/sdiff.c (interact):
+    Don't rely on undefined behavior on signed integer overflow.
+    * src/diff.c (main): Don't let contexts exceed CONTEXT_MAX.
+    * src/system.h (CONTEXT_MAX): New macro.
+
+commit c26334b7df5a10a70447d762711380c693fdc2a7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Feb 24 21:38:02 2014 -0800
+
+    diff: fix bug with -I and overlapping hunks
+    
+    Problem reported by Vincent Lefevre in <http://bugs.gnu.org/16864>.
+    * src/context.c (find_hunk): Threshold is CONTEXT only if
+    the second change is ignorable.
+    * tests/ignore-matching-lines: New test.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 9b48bf3d3ed002e32fad5de5f539745bc861a104
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 23 22:49:27 2014 -0800
+
+    diff: remove TOO_EXPENSIVE heuristic
+    
+    Problem reported by Vincent Lefevre in <http://bugs.gnu.org/16848>.
+    The simplest solution is to remove the TOO_EXPENSIVE heuristic
+    that I added to GNU diff in 1993.  Although appropriate for
+    circa-1993 hardware, these days the heuristic seems to be more
+    trouble than it's worth.
+    * NEWS: Document this.
+    * doc/diffutils.texi (Overview): Modernize citations.
+    Remove mention of TOO_EXPENSIVE heuristic.
+    * src/analyze.c (diff_2_files): Adjust to TOO_EXPENSIVE-related
+    API changes in gnulib's diffseq module.
+
+commit bc51e4bcb4a843998c3cd89f8c2ba00e73bb5381
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 23 16:23:17 2014 -0800
+
+    build: update gnulib submodule to latest
+
+commit bc4b4b2bbf699267bab167af0484336780791953
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jan 31 17:15:26 2014 -0800
+
+    diff: exit with status 1, not 2, when binary files differ
+    
+    Problem reported by Vincent Lefevre in <http://bugs.gnu.org/16608>.
+    * NEWS:
+    * doc/diffutils.texi (Binary, Invoking diff): Document this.
+    * src/analyze.c (briefly_report): Return void, not int.
+    All uses changed.  Do not futz with exit status.  Simplify.
+    * tests/binary: Adjust to match new behavior.
+
+commit 1875453ee6e1021d67c6856c46e7024bcecdbea8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 26 12:20:00 2013 -0700
+
+    build: omit -Wsuggest-attribute=pure for lib
+    
+    * configure.ac (WARN_CFLAGS): Omit -Wsuggest-attribute=pure
+    when compiling the lib subdirectory.  Reported for Fedora 19
+    by Eric Blake in <http://bugs.gnu.org/15463>.
+
+commit 59f4ef95f8a9c0583d1560ef447eab9d44e32cd1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 22 15:45:56 2013 -0700
+
+    cmp, diff, sdiff: tune by using rawmemchr
+    
+    On my platform (AMD Phenom II X4 910e, Fedora 17 x86-64), this sped up
+    'cmp -n 8GiB /dev/full /dev/zero' by a factor of 3.8, and
+    'cmp -sn 8GiB /dev/full /dev/zero' by a factor of 1.8.
+    * bootstrap.conf (gnulib_modules): Add rawmemchr.
+    * src/cmp.c (cmp): Optimize the common case where buffers are the same,
+    by using count_newlines rather than block_compare_and_count.
+    (block_compare_and_count): Remove.
+    (count_newlines): New function.
+    * src/cmp.c (count_newlines):
+    * src/io.c (prepare_text):
+    * src/sdiff.c (lf_copy, lf_skip, lf_snarf):
+    Use rawmemchr instead of memchr, for speed.
+
+commit 9350980d5dd0d922845bcbb225207a775cf40697
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 12 16:24:01 2013 -0700
+
+    cmp: tune 'cmp a b' for GCC x86
+    
+    Performance problem reported by David Balažic in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2013-08/msg00013.html
+    * src/system.h (word): Make it size_t, not uintmax_t.
+    This sped up plain cmp 90% on my tests (GCC 4.8.1, x86).
+
+commit 8f248489ebcc39c9e553f749c90b4bbdf19eb5bd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jul 6 17:41:19 2013 -0700
+
+    build: update gnulib submodule to latest
+
+commit d1d1df8e369b0f31e5e6f2784dbfa35d7ddc3647
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Fri May 3 12:10:32 2013 +0200
+
+    build: enable 'subdir-objects' automake option
+    
+    The future major Automake version (2.0, ETA at least one year from now)
+    might enable that option unconditionally, so better get prepared in due
+    time.
+    
+    * configure.ac (AM_INIT_AUTOMAKE): Adjust.
+    (AM_PROG_CC_C_O): New, required by Automake up to 1.13.x when the
+    'subdir-objects' is in use.
+
+commit 1280234016e4eece403b72fc69f53e13044df5ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Apr 28 20:48:44 2013 -0700
+
+    build: update gnulib submodule to latest
+
+commit 4825b8d70cff23f6ebe0dfa0ab181bc8401007a5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 3 08:20:31 2013 -0700
+
+    diff: fix bug with Asian file names
+    
+    Problem reported by Errembault Philippe in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2013-03/msg00012.html
+    * NEWS: Document this.
+    * src/dir.c (compare_names): Fall back on file_name_cmp if
+    compare_collated returns 0, unless ignoring file name case.
+    (diff_dirs): Don't bother with the O(N**2) stuff unless ignoring
+    file name case.
+    * tests/Makefile.am (TESTS): Add strcoll-0-names.
+    * tests/strcoll-0-names: New file.
+
+commit 885dfcec001ba7712257e371c4af61914c64133b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 3 07:51:33 2013 -0700
+
+    diff: remove unnecessary decl
+    
+    * src/dir.c (compare_names_for_qsort): Remove declaration.
+    Not needed now that we assume C89.
+
+commit 085417c79b05afc72ef9d0333a5846da53826a8c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 3 07:48:22 2013 -0700
+
+    diff: tune compare_names_for_qsort
+    
+    * src/dir.c (compare_collated): New function.
+    (compare_names): Use it.
+    (compare_names_for_qsort): Use it.  This is a bit more efficient
+    as it can avoid a double invocation of file_name_cmp when
+    file_name_cmp returns zero.
+
+commit 417363e4ce3e0195b539a4170ff0cda91400dbc8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Mar 30 12:50:27 2013 -0700
+
+    doc: mention new option, --no-dereference in 3.3's NEWS
+    
+    * NEWS (New feeatures): Update 3.3's news to mention --no-dereference.
+    Reported by Denis Excoffier.
+    * Makefile.am (old_NEWS_hash): Update, since this modifies old, and
+    normally-immutable NEWS.
+
+commit 283d1b9528e193ac25018b542665ac5c0e53811f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 26 11:39:06 2013 -0700
+
+    tests: port to Solaris 10 /bin/sh
+    
+    * tests/Makefile.am (TESTS_ENVIRONMENT):
+    Use "FOO=val; export FOO" rather than "export FOO=val",
+    as the latter form doesn't work with Solaris /bin/sh.
+    Problem found when trying to run "make check" on Solaris 10.
+
+commit 36671926115bb6cd29876470afbd85cdda33b443
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Mar 24 11:09:13 2013 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 4544aa68fda5404835d1e0bfbfda8467d7e0d4a5
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Mar 24 11:00:34 2013 -0700
+
+    version 3.3
+    
+    * NEWS: Record release date.
+
+commit 6e68271b694fd8fd75459f613861f66ae7b9573b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Mar 23 00:26:09 2013 -0700
+
+    doc: fix menu typo
+    
+    * doc/diffutils.texi (Comparing Three Files): Fix out-of-order menu.
+    Bug caught by Texinfo 5.0.
+
+commit 0c22f56ed7990cf02cbd2ade738944dd5ea8afd5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Mar 23 00:21:45 2013 -0700
+
+    maint: update build procedure to recent gettext etc.
+    
+    * bootstrap.conf (gnulib_modules): Add vararrays.
+    (needed_gnulib_files, unnecessary_gettext_files): New vars.
+    (bootstrap_post_import_hook): New function, to implement these vars.
+    (excluded_files): Remove; 'bootstrap' no longer supports this.
+    Its function is now performed by unnecessary_gettext_files.
+    (buildreq): Update automake to 1.12.2, to avoid CVE-2012-3386.
+    * configure.ac (AM_GNU_GETTEXT_VERSION): Bump from 0.17 to 0.18.2,
+    to lessen the probability that we'll have outlandishly old files
+    during a build.
+    * m4/vararrays.m4: Remove from repository, as we now use the
+    gnulib version.
+
+commit 90fd310a7865bf4ae695aaab0f21a9ab71f849f8
+Author: Jim Meyering <jim@meyering.net>
+Date:   Fri Mar 22 04:39:25 2013 +0100
+
+    build: update gnulib to latest and adapt; update bootstrap, too
+    
+    Blindly updating to the latest from gnulib, bootstrap would
+    fail due to failure of our local patches to apply.  Hence,
+    these first two updates.
+    * gl/lib/regex_internal.c.diff: Update offsets, so this patch
+    applies to the latest from gnulib.
+    * gl/lib/regex_internal.h.diff: Remove file.  No longer needed.
+    * bootstrap: Update from gnulib.
+
+commit b2f1e4bc555073d43b664c4389569a195ff040e3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 6 08:30:39 2013 -0800
+
+    tests: port to hosts lacking fmt, make -C
+    
+    * tests/Makefile.am (built_programs): Don't assume fmt works.
+    Don't rely on 'make -C', either.
+
+commit 118d732ab2f414f9964377b4663598fa4a3ac3a6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 6 08:25:05 2013 -0800
+
+    maint: update .gitignore for recent gnulib
+    
+    * .gitignore: Add tests/*.trs and several *.h and *.sed files in lib,
+
+commit 45716f1cabffe46278c22b91a6399d7970639fef
+Author: Jim Meyering <jim@meyering.net>
+Date:   Fri Jan 4 11:19:17 2013 +0100
+
+    build: update gnulib submodule to latest
+
+commit a0483cb2fc67ce559033a28e98b310e8ceaa9fd0
+Author: Jim Meyering <jim@meyering.net>
+Date:   Fri Jan 4 11:13:02 2013 +0100
+
+    maint: update all copyright year number ranges
+    
+    Run "make update-copyright".
+
+commit 01d92dba155d9ad87eaf0378876e0c67285c2075
+Author: Eric Blake <eblake@redhat.com>
+Date:   Tue Oct 23 11:06:48 2012 +0200
+
+    build: default to --enable-gcc-warnings in a git tree
+    
+    Anyone building from cloned sources can be assumed to have a new
+    enough environment, such that enabling gcc warnings by default will
+    be useful.  Tarballs still default to no warnings, and the default
+    can still be overridden with --disable-gcc-warnings.
+    * configure.ac (gl_gcc_warnings): Set default based on environment.
+
+commit 42f6244ee028dfbc535934e21028e6aa582256e7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Oct 3 21:57:21 2012 -0700
+
+    * doc/diffutils.texi (cmp Options): Document -l format better.
+
+commit 221383bcb1f9de839727b6ffd1b5a2b725314779
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Sep 10 12:18:59 2012 +0200
+
+    maint: use xasprintf in place of xmalloc+sprintf
+    
+    * bootstrap.conf (gnulib_modules): Add gnulib's xvasprintf module.
+    * src/util.c: Include "xvasprintf.h".
+    (begin_output): Use xasprintf in place of xmalloc+sprintf.
+
+commit e17295dc5529b252c269f12e081184bbde42d575
+Author: Andreas Gruenbacher <agruen@gnu.org>
+Date:   Tue Aug 14 00:30:46 2012 +0200
+
+    diff: encode file names with special characters
+    
+    * src/util.c (c_escape_char): New function.
+    (c_escape): New function.
+    (begin_output): Escape file names when needed.
+    * src/context.c (print_context_header): New names parameter.
+    (print_context_label): New name parameter.
+    * src/diff.h (print_context_header): Change prototype.
+    * tests/filename-quoting: New file.
+    * NEWS: Document this change.
+
+commit baeaa83e31da3a1a36d2a1f76140b67ff76859fe
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 30 07:52:22 2012 -0700
+
+    diff: silence GCC warning instead of slowing down
+    
+    * src/dir.c (find_dir_file_pathname): Use 'IF_LINT (volatile)' to
+    silence the gcc warning, rather than using 'volatile', as the
+    warning appears to be bogus.
+
+commit f6ac439e484731a8a910bcd91e45039a3fa39c59
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Aug 28 09:39:53 2012 +0200
+
+    diff: avoid possible longjmp-triggered misbehavior
+    
+    * src/dir.c (find_dir_file_pathname): gcc 4.8.0 20120825 reported
+    that a local variable's value might be clobbered.  Declare "match"
+    to be volatile.
+
+commit 6c273a4db62c4f7b0667545c31a5ad24b913598a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Aug 28 08:47:27 2012 +0200
+
+    build: update gnulib, bootstrap and init.sh to latest
+
+commit 5cb0eea638e5db4de66bcf99d9ce4f6fd974e04e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Aug 28 10:58:48 2012 +0200
+
+    maint: avoid new syntax-check failure due to @xref use
+    
+    * doc/diffutils.texi: Change several "; @xref{..." to ".  @xref{...",
+    since @xref should start a sentence.
+
+commit 1f281b36801627601f8a92f26e8ac6a0a7e36526
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 15 14:01:53 2012 -0700
+
+    maint: remove ms subdirectory
+    
+    diffutils is now designed to build with Cygwin or MinGW.
+    The old DJGPP stuff probably doesn't work anyway.
+    * Makefile.am (SUBDIRS): Remove ms.
+    * NEWS: Document this.
+    * configure.ac (AC_CONFIG_FILES): Remove ms/Makefile.
+    * ms/Makefile.am, ms/README, ms/config.bat, ms/config.sed:
+    * ms/config.site: Remove.
+
+commit bca6d67e3f92b9c358e96098d7cd9b841dc16604
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 23:24:49 2012 -0700
+
+    maint: update bootstrap from gnulib
+    
+    * bootstrap: Update from gnulib.
+
+commit 3549f733b9cd2c7fd5dd1e4a273151e2da01a00b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 23:07:13 2012 -0700
+
+    main: port subcommands to mingw
+    
+    Problem reported by Eli Zaretskii in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2012-05/msg00013.html>.
+    Approach suggested by Bruno Haible as option (4) in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2012-05/msg00036.html>.
+    * bootstrap.conf (gnulib_modules): Add system-quote.
+    * src/diff3.c, src/sdiff.c, src/util.c:
+    Include <system-quote.h>, not <sh-quote.h>.
+    * src/diff3.c (read_diff):
+    * src/sdiff.c (main, edit):
+    * src/util.c (begin_output):
+    Use system_quote_argv, for portability to Mingw.
+    * src/sdiff.c (NUM_SIGS, handler_index_of_SIGINT): Now enum
+    values, not macros; this is cleaner and avoids a GCC warning if
+    !HAVE_WORKING_VFORK.
+    * src/util.c (begin_output) [! HAVE_WORKING_FORK]: Do not use -f,
+    for consistency with the HAVE_WORKING_FORK code.
+
+commit de512b8345de9d501b21a5c1bc446e28d50ebf8c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 22:13:21 2012 -0700
+
+    maint: update bootstrap from gnulib
+    
+    * bootstrap: Update from gnulib.
+
+commit 98985d32063135ab0e584fafb6e9edcf45869ec9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 22:12:21 2012 -0700
+
+    maint: m4/gnulib-cache.m4 is not under version control
+    
+    This is like what coreutils does, and suppresses 'git status' chatter.
+    * .gitignore: Add /m4/gnulib-cache.m4.
+
+commit e537e2c86632dca0ba3abe2b6e2d7d7cac189b2c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 13 19:30:56 2012 -0700
+
+    Use binary mode when testing for binary files.
+    
+    This reverts the 2006-01-05 change and modernizes to the current API.
+    Idea suggested by Eli Zaretskii in:
+    http://lists.gnu.org/archive/html/bug-gnu-utils/2012-05/msg00066.html
+    * src/cmp.c (main):
+    * src/diff.c (main, compare_files):
+    Use set_binary_mode rather than SET_BINARY.
+    * src/diff.c (compare_files): Omit unnecessary use of O_BINARY.
+    * src/io.c (sip): Sample unknown files in binary mode, to see
+    whether they are binary.
+    (read_files): Read binary files in binary mode.
+
+commit aa7a1de25ab798fc7c45a68df41556b1f9f17fb2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 10:10:21 2012 -0700
+
+    build: update gnulib submodule to latest
+
+commit 5f295d6115179216d13b78a768c97e873f493da9
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Sun May 13 19:46:30 2012 -0700
+
+    build: omit obsolete AM_PROG_CC_STDC macro
+    
+    The Automake-provided macro 'AM_PROG_CC_STDC' has been superseded by
+    the Autoconf-provided one 'AC_PROG_CC' since October 2002, and will
+    be removed in the next major automake version.
+    * configure.ac (AM_PROG_CC_STDC): Drop it.
+
+commit 3c19ca08b1cf7aaaae72393073affaa082928ae4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat May 5 15:51:25 2012 +0200
+
+    diff: fix a typo that was always disabling the same_special_file macro
+    
+    * src/system.h (same_special_file): Correct cpp guard expression:
+    s/HAVE_ST_RDEV/HAVE_STRUCT_STAT_ST_RDEV/.  Reported by Eli Zaretskii.
+
+commit 6cb7786fd85a503bfcbe8f28dd34a92902736825
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Jan 26 12:25:27 2012 +0100
+
+    maint: update bootstrap from gnulib
+    
+    * bootstrap: Update from gnulib.
+
+commit 2f108d7405ab121ebbec88ee9865bac8657f7218
+Author: Eric Blake <eblake@redhat.com>
+Date:   Wed Mar 7 09:13:10 2012 -0700
+
+    usage: improve wording of --ignore-matching-lines
+    
+    * src/diff.c (option_help_msgid): Tweak wording.
+
+commit c7560370da8ff0d7b48b75989b8f46cb619fbfd8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 4 13:19:55 2012 -0800
+
+    doc: explain -I RE better in --help output
+    
+    * src/diff.c, src/sdiff.c (option_help_msgid): For -I RE,
+    change "whose lines all match" to "all whose lines match" to avoid
+    unintended interpretation.  Reported by Danijel Tasov in
+    <http://bugs.debian.org/648411>.
+
+commit b2892140d83cbc05881440a2fdbc13bb24b6cd76
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 12 13:08:26 2012 -0800
+
+    sdiff: remove dependency on sigprocmask
+    
+    * bootstrap.conf (gnulib_modules): Remove sigprocmask.
+    * src/sdiff.c (temporary_file): No need to invoke sigprocmask
+    here, since the signal handler merely sets a flag.
+
+commit 7f2f4bb36593c0d2ed3284b3b8be2951fa6d5008
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Feb 4 22:10:40 2012 -0800
+
+    diff: -N, --unidirectional-new-file now compare to "-" too
+    
+    * NEWS: Document this.
+    * doc/diffutils.texi (Comparing Directories): Likewise.
+    Also, document that these options work at the top level.
+    * src/diff.c (compare_files): Treat EBADF like ENOENT, to handle
+    the case where "-" is closed.  Allow the other file to be
+    STDIN_FILENO, in case it's "-".
+    * tests/Makefile.am (TESTS): Add new-file.
+    * tests/new-file: New file.
+
+commit 62ca21c8c1a5aa3488589dcb191a4ef04ae9ed4f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 25 23:46:16 2012 -0800
+
+    maint: quote 'like this' or "like this", not `like this'
+    
+    This is in response to a recent change in the GNU coding standards,
+    which now suggest quoting 'like this' or "like this", instead of
+    `like this' or ``like this''.
+    * HACKING, NEWS, README, README-hacking, TODO, doc/diagmeet.note:
+    * doc/diffutils.texi, ms/config.bat, ms/config.site:
+    * src/analyze.c, src/cmp.c, src/context.c, src/diff.c:
+    * src/diff.h, src/diff3.c, src/dir.c, src/ifdef.c, src/io.c:
+    * src/sdiff.c, src/side.c, src/system.h, src/util.c:
+    * tests/help-version:
+    Quote 'like this' or "like this" in commentary.
+    * cfg.mk (old_NEWS_hash): Adjust to reflect new NEWS quoting.
+    * man/help2man: Update to 1.40.4 version, with quoting fixed as above.
+    * po/en.po: Remove translation involving `, as it's no longer needed.
+    * src/cmp.c (try_help, specify_ignore_initial, usage, main):
+    * src/diff.c (main, try_help, option_help_msgid, specify_value)
+    (compare_files):
+    * src/diff3.c (main, try_help, option_help_msgid, usage)
+    (read_diff):
+    * src/dir.c (compare_names):
+    * src/sdiff.c (try_help, usage, check_child_status, main):
+    * src/util.c (finish_output):
+    * tests/help-version:
+    Quote 'like this' in output.
+
+commit 70eafb8038cb866ca62ef96ff4dda217d408ce7e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 25 16:11:46 2012 -0800
+
+    build: update gnulib submodule to latest
+
+commit 301a23cdbba22ad208e4014d277eb8eb600d2d0e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Jan 12 13:57:05 2012 +0100
+
+    build: accommodate newer bootstrap from gnulib
+    
+    * bootstrap.conf (gnulib_tool_option_extras): Add both --symlink
+    and --makefile-name=gnulib.mk.  Also remove now-obsolete $bt/ prefix.
+    * bootstrap: Update from gnulib.
+    * tests/init.sh: Update from gnulib.
+    * lib/Makefile.am: Initialize numerous variables, so that
+    generated code in gnulib.mk may use += to append to them.
+
+commit 6e51ccfb4eccfdb6672e69c982723f633fb0f099
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Jan 12 14:04:17 2012 +0100
+
+    maint: avoid new syntax-check failure
+    
+    * src/diff.c (compare_files): Use STREQ, not strcmp.
+
+commit e3324651cc1f9f116754a4713e08bfb0bac50150
+Author: Bruno Haible <bruno@clisp.org>
+Date:   Sat Jan 7 00:57:29 2012 +0100
+
+    New option --no-dereference.
+    
+    * src/diff.h (no_dereference_symlinks): New variable.
+    * src/diff.c: Include xreadlink.h.
+    (longopts): Add --no-dereference option.
+    (main): Accept --no-dereference option.
+    (option_help_msgid): Mention the --no-dereference option.
+    (compare_files): If no_dereference_symlinks is true, use lstat()
+    instead of stat(). Compare symbolic links by comparing their values.
+    * bootstrap.conf (gnulib_modules): Add lstat, stat, xreadlink.
+    * doc/diffutils.texi (Comparing Directories, diff Options): Mention the
+    --no-dereference option.
+    * tests/no-dereference: New file.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 45110a7927df633cb3235d4fee3d84b0b6d26a96
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 1 09:32:41 2012 +0100
+
+    maint: update all copyright year number ranges
+    
+    Run "make update-copyright".
+
+commit c88c3b6b2ae94bf5d72a04dd4fb797cb386fcb07
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Dec 14 14:28:47 2011 +0100
+
+    build: update to latest gnulib and adapt
+    
+    * tests/binary: Reverse arguments to compare to avoid failure of
+    new syntax-check rule.
+    * configure.ac: Use -Wno-format-nonliteral.
+    Mark functions as pure of const, per recommendations enabled by
+    new gcc -W options.  Use _GL_ATTRIBUTE_PURE and _GL_ATTRIBUTE_CONST.
+    * lib/cmpbuf.h (buffer_lcm, block_compare):
+    Apply pure and/or const attributes.
+    * src/cmp.c (block_compare): Likewise.
+    * src/context.c (find_hunk): Likewise.
+    * src/diff.h (lines_differ): Likewise.
+    * src/diff3.c (skipwhite): Likewise.
+    * src/dir.c (dir_loop): Likewise.
+    * src/util.c (find_change, find_reverse_change): Likewise.
+    (translate_line_number): Likewise.
+
+commit 439286a937c2ae02374e0389ed2ccd91240a8bd8
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Dec 14 14:27:28 2011 +0100
+
+    build: stop distributing gzip'd releases;  xz is enough
+    
+    * configure.ac (AM_INIT_AUTOMAKE): Add no-dist-gzip.
+
+commit 31b43733d40d0a919e0af013f48e271f5824200e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Nov 29 17:11:59 2011 +0100
+
+    tests: use "compare exp out", not "compare out exp"
+    
+    Likewise, when an empty file is expected, use "compare /dev/null out",
+    not "compare out /dev/null". I.e., specify the expected/desired contents
+    via the first file name.  Prompted by a suggestion from Bruno Haible
+    in http://thread.gmane.org/gmane.comp.gnu.grep.bugs/4020/focus=29154
+    
+    Run these commands:
+    
+      git grep -l -E 'compare [^ ]+ exp' \
+        |xargs perl -pi -e 's/\b(compare) (\S+) (exp\S*)/$1 $3 $2/'
+      git grep -l -E 'compare [^ ]+ /dev/null' \
+        |xargs perl -pi -e 's,\b(compare) (\S+) (/dev/null),$1 $3 $2,'
+    
+    But manually convert this one:
+    
+      -compare out exp-$(echo $opt|tr ' ' _)
+      +compare exp-$(echo $opt|tr ' ' _) out
+    
+    and avoid an inappropriate change to cfg.mk.
+
+commit 5e2baecb26cede9f42456da9593bd0f15af823bb
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Wed Oct 12 11:11:23 2011 +0200
+
+    tests: use more portable fd redirection in TESTS_ENVIRONMENT
+    
+    * tests/Makefile.am (TESTS_ENVIRONMENT): Redirection with `exec 9>&2'
+    is not portable to various Korn shells, and to (at least) HP-UX 11
+    /bin/sh.  Use a more portable idiom.
+    See http://thread.gmane.org/gmane.comp.gnu.coreutils.bugs/22488 for
+    lots of discussion.
+
+commit 366adeb73d80cbe8ed4b730c46ed7864cf10eb73
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Mon Oct 10 20:30:21 2011 +0200
+
+    tests: make test runner a script, not a shell function
+    
+    All the test scripts in the diffutils testsuite are shell scripts,
+    so the current definition of TESTS_ENVIRONMENT, which adaptively
+    run tests using either perl or the shell depending on their kind,
+    is an overkill.
+    
+    Moreover, this change is required in order for the testsuite to
+    continue to work with the new testsuite harness that is planned
+    to be introduced in Automake 1.12 (which, as of the writing date,
+    is still under development and in late alpha state).
+    
+    See also related discussion on bug-coreutils:
+     <http://debbugs.gnu.org/cgi/bugreport.cgi?bug=8887>
+    
+    * tests/Makefile.am (TESTS_ENVIRONMENT): Remove definition of the
+    `shell_or_perl_' shell function, which is not required anymore.
+    (LOG_COMPILER): New, define to `$(SHELL)'.
+    * tests/binary: Make executable.
+    * tests/colliding-file-names: Likewise.
+    * tests/excess-slash: Likewise.
+    * tests/no-newline-at-eof: Likewise.
+
+commit 7508234eabe646abcea074baea83612f8115d3b9
+Author: Claudio Bley <claudio.bley@gmail.com>
+Date:   Sun Sep 4 18:01:57 2011 +0200
+
+    portability: use SET_BINARY rather than xfreopen (NULL, ...
+    
+    * src/diff.c: Include binary-io.h, not xfreopen.h.
+    (main): Use SET_BINARY (...) rather than xfreopen (NULL, X, ...),
+    because the latter doesn't work on MinGW and crashes using MSVC.
+    * src/cmp.c (main): Likewise.
+
+commit 11ef88af927a4591aa54bc86814c0ed11b6025be
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Oct 4 13:40:21 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit 57a09576e8d344c2e694ece0fc3335ca8e058edd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 17:21:07 2011 +0200
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 8f14bb909569036fe580cd639df08225f5f4e93c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 17:18:34 2011 +0200
+
+    version 3.2
+    
+    * NEWS: Record release date.
+
+commit e2ed9d279b1a9933a4225a1c952aa5c9d50b4c69
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 14:16:04 2011 +0200
+
+    build: update bootstrap and tests/init.sh from gnulib
+    
+    * bootstrap: Update from gnulib.
+    * tests/init.sh: Likewise.
+
+commit 783eca9655c2bdcae547b290909493c0a16bf598
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 00:36:24 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit 77bcc326cc252e8c4b453000a0174320dc565cd7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Sep 1 10:13:26 2011 +0200
+
+    doc: diffutils' texi-derived doc may now be in debian's "main" section
+    
+    * NEWS (Packaging): Mention the "no front/back-cover" change.
+
+commit 320355d6d4a7cbaf15a34341131e506fff8e41c2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Aug 15 07:27:14 2011 +0200
+
+    maint: avoid new "make sytnax-check" failure.
+    
+    * src/diff.h (find_dir_file_pathname): Mark declaration with "extern"
+    keyword, in order to placate the tight-scope syntax check.
+
+commit 8739d45f721feb3d05d75f5ca0afda4bacea635b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 14 22:08:16 2011 -0700
+
+    * src/io.c (find_and_hash_each_line): Refactor for brevity.
+
+commit 86a40dd6acc84e5633d2fc6b45f9193fe01b23f8
+Author: Roland McGrath <roland@hack.frob.com>
+Date:   Sun Aug 14 14:37:01 2011 -0700
+
+    diff, sdiff: new option --ignore-trailing-space (-Z)
+    
+    Derived from Roland McGrath's patch (dated June 2004!) in:
+    http://lists.gnu.org/archive/html/bug-gnu-utils/2004-07/msg00000.html
+    * NEWS:
+    * doc/diffutils.texi (White Space, Blank Lines)
+    (sdiff Option Summary, diff Options, sdiff Options): Document -Z.
+    * src/diff.h (IGNORE_TRAILING_SPACE)
+    (IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE): New constants, for -Z.
+    * src/diff.c (shortopts, longopts, main, option_help_msgid):
+    * src/sdiff.c (longopts, option_help_msgid, main):
+    * src/io.c (find_and_hash_each_line):
+    * src/util.c (lines_differ, analyze_hunk): Support -Z.
+
+commit efb0557f4cd63628957880ffbf63702b604e0ae2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Aug 13 15:11:19 2011 -0700
+
+    * bootstrap.conf (gnulib_modules): Remove timegm.
+    
+    This fixes a problem noted by Andreas Schwab in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2011-08/msg00035.html
+
+commit 70febebfe5215674079dc1c65ad966f5e404d2a8
+Author: Tim Waugh <twaugh@redhat.com>
+Date:   Sat Aug 13 13:16:32 2011 -0700
+
+    diff: --ignore-file-name-case now applies at top level too
+    
+    Derived from Tim Waugh's patch in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2011-08/msg00034.html
+    * NEWS, doc/diffutils.texi (diff Options): Document this.
+    * src/diff.c (compare_files): Implement this, by using
+    find_dir_file_pathname.
+    * src/diff.h (find_dir_file_pathname): New decl.
+    * src/dir.c: Include filenamecat.h.
+    (find_dir_file_pathname): New function.
+
+commit e3001b775aa8a3e7e30651b0f59d401ac4fe419d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Aug 13 11:28:57 2011 -0700
+
+    * .gitignore: Add lib/unistr, lib/unused-parameter.h.
+
+commit 1e340def247d7b11fe18da3a959bfeabd93d52b4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 10 12:38:04 2011 +0200
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 78524ae4ba5a726844d06b9eb24c6844c84a4c52
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 10 12:33:36 2011 +0200
+
+    version 3.1
+    
+    * NEWS: Record release date.
+
+commit 3edb801c061779b8245557f14072e8b5681986f7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 10 10:20:06 2011 +0200
+
+    build: use largefile module and update to latest gnulib
+    
+    * configure.ac: Remove AC_SYS_LARGEFILE, subsumed by ...
+    * bootstrap.conf (gnulib_modules): ...this.  Use largefile module.
+    * gnulib: Update to latest.
+
+commit 8832cf045d62a4a40e6df948e6cf8b85485653a0
+Author: Santiago Vila <sanvila@unex.es>
+Date:   Mon Aug 8 17:59:46 2011 +0200
+
+    doc: insert comma in --help line for --ignore-space-change (-b)
+    
+    * src/diff.c (option_help_msgid): Insert omitted comma between
+    "-b" and "--ignore-space-change".  (tiny change)
+
+commit 789252980fa8ef3d804372cd347898aa5c2ec7fe
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Aug 4 18:59:29 2011 +0200
+
+    doc: relax restriction on front-cover and back-cover texts
+    
+    * doc/diffutils.texi (copying): Relax restriction on front-cover
+    and back-cover texts (just as m4 did here:
+    http://git.savannah.gnu.org/cgit/m4.git/commit?id=ee1e92ec).
+    Reported by Santiago Vila.  Fix suggested by Eric Blake.
+
+commit c06794dacf66868840ea4818352929eabeec09c2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 3 18:07:33 2011 +0200
+
+    tests: update init.sh from gnulib
+    
+    * tests/init.sh: Update from gnulib.
+
+commit 1ce0b3604b88aa6ba07b7ff5c0201224465307f1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 3 14:22:24 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit 01fc077bbfea22f0759400b45bf6a04b840ee2e4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jul 3 22:44:26 2011 +0200
+
+    maint: remove inclusion of unused header, for "make syntax-check"
+    
+    * src/diff3.c: Don't include <inttostr.h>.  Not used.
+    * src/context.c: Likewise.
+
+commit c8b5b09d1393139ba443e7e239cfa6a9c3e92258
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jun 19 17:15:26 2011 +0200
+
+    build: don't require perl when building from a tarball
+    
+    But do ensure -- in all other circumstances -- that the man/*.1
+    files are rebuilt whenever the version number changes.
+    * configure.ac (SRC_VERSION_C): Define.
+    * man/Makefile.am (dist_man1_MANS): Rename from $(man1_MANS),
+    so that we distribute those pesky man/*.1 files.
+    (EXTRA_DIST): Reflect name change.
+    (MAINTAINERCLEANFILES): Define this, not DISTCLEANFILES,
+    now that these generated files are distributed.
+    ($(dist_man1_MANS)): Depend on $(SRC_VERSION_C), so we get the
+    full dependency when not building from a tarball.
+
+commit e783a23b1944d89405342f5d6a09dba26c192005
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jun 13 09:17:26 2011 +0200
+
+    doc: do not distribute generated man/*.1 man files
+    
+    * man/help2man: New file.
+    * man/Makefile.am: Use $(srcdir)/help2man.
+    Convert $(dist_man1_MANS) to $(man1_MANS), to tell automake
+    not to distribute the generated man/*.1 files.  Now they're
+    generated at build-from-tarball time.
+    ($(man1_MANS)): Depend on version.c, so that man pages are
+    regenerated whenever the version string changes.
+
+commit 7faccb437cb0c08c52ac061db66e9e028bd690a7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jun 12 11:24:57 2011 +0200
+
+    build: ccache works better without embedded version strings
+    
+    * src/Makefile.am: Generate version.c and version.h and put the
+    new symbol in a tiny library to be used by each program.
+    (LDADD): Add the new library.
+    * src/cmp.c (main): Use Version, not PACKAGE_VERSION, so the .o
+    file does not change with each commit-derived version increment.
+    * src/diff.c (main): Likewise.
+    * src/diff3.c (main): Likewise.
+    * src/sdiff.c (main): Likewise.
+    * src/system.h: Include "version.h".
+    * .gitignore: Add version.[ch]
+
+commit 929cf564727acb17435e98b6d05e9d6453f10808
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jun 12 10:14:22 2011 +0200
+
+    doc: ensure each program has a man/*.x file: add "SEE ALSO" references
+    
+    * man/cmp.x: New file.
+    * man/diff3.x: New file.
+    * man/sdiff.x: New file.
+    * man/diff.x: Add xrefs to the other three programs, and to patch.
+    * man/Makefile.am (EXTRA_DIST): List new files.
+    (cmp.1, diff3.1, sdiff.1): Depend on each .x file.
+
+commit df0a31f6110b14cce7d1b3fa5a48a38d603a4e12
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jun 11 14:06:10 2011 +0200
+
+    doc: rename diff.texi to diffutils.texi
+    
+    This makes the .texi basename the same as the package name,
+    which is consistent with most other GNU packages.
+    * doc/diffutils.texi: Rename from...
+    * doc/diff.texi: ...removed.
+    * doc/Makefile.am (info_TEXINFOS): Reflect name change.
+    (diffutils_TEXINFOS): Likewise.
+    * cfg.mk (gendocs_options_): Remove this customization.  It is no
+    longer needed, now that the .texi name matches that of the package.
+    * man/Makefile.am ($(dist_man1_MANS)): Remove now-unnecessary sed
+    filter.
+    * README: Update references to diffutils.texi etc. here, too.
+    * .gitignore: Update here, too.
+    Suggested by Karl Berry.
+
+commit a2b10ab0d6f8f11c380fdb1dedd920dfa1359a90
+Author: Karl Berry <karl@freefriends.org>
+Date:   Wed Jun 8 13:00:23 2011 +0000
+
+    cmp, diff, diff3, sdiff: edit and align --help text.
+    
+    * cmp.c (option_help_msgid, usage),
+    * diff.c (option_help_msgid, usage),
+    * diff3.c (option_help_msgid, usage),
+    * sdiff.c (option_help_msgid, usage): align descriptions in the --help
+    output and slightly edit content.
+
+commit de65c25dc103b7f4b18e0c3116c31ff7fc6d4726
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 27 23:38:40 2011 -0700
+
+    diff: don't use locales after local-specific sorting fails
+    
+    * src/dir.c (compare_names): Don't invoke strcasecmp if
+    locale-specific sorting fails, because POSIX.1-2008 says strcasecmp
+    has unspecified behavior outside the POSIX locale.  See:
+    http://lists.gnu.org/archive/html/bug-diffutils/2011-05/msg00008.html
+
+commit a3318fdbca6002d524f063ab5e98e7e59295d2a2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 27 23:34:08 2011 -0700
+
+    bootstrap: Avoid multithreading.
+    
+    * bootstrap.conf (gnulib_tool_option_extras):
+    Add "--avoid=localename --avoid=lock", because we don't want to
+    bring in the multithreading code that recent gnulib changes would
+    otherwise bring in.
+    (excluded_files): Remove m4/lock.m4; no longer needed, now that
+    we use --avoid=lock.
+
+commit 1850ea03ac1d72a4f686143463af22d2377a9f24
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 27 21:32:38 2011 -0700
+
+    build: update gnulib submodule to latest
+
+commit 0b7299f98e9ce4e10cc595414e1505f239022e36
+Author: Karl Berry <karl@gnu.org>
+Date:   Mon May 23 09:41:48 2011 -0700
+
+    maint: update README-hacking
+    
+    * README-hacking: Update a la coreutils for git, etc.
+
+commit 91d850a78b100bf78c9f77abf38c0369b877f597
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 23 19:20:05 2011 +0200
+
+    maint: update gnulib to latest with accompanying tight-scope tweaks
+    
+    * cfg.mk: Include $(srcdir)/dist-check.mk using "-include",
+    to accommodate the new sc_tight_scope rule.
+    (_gl_TS_extern): Define, to tell gnulib's tight_scope rule that
+    headers here mark externs with "XTERN".
+    * gnulib: Update to latest.
+
+commit 39213a3bbcfd86c1629c06507bfc4a761f71dbc7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 29 20:04:14 2011 +0200
+
+    maint: use gnulib's new readme-release module
+    
+    * bootstrap.conf (gnulib_modules): Add readme-release.
+    (bootstrap_epilogue): Add the recommended perl one-liner.
+    * README-release: Remove file; it is now generated from gnulib.
+    * .gitignore: Add it.
+
+commit 167d1e3125e596479dd994ebc29b833e9fd7e825
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed May 18 20:31:36 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit a531a3cff268a51848b029b3d6ba67b37a8d91ce
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 8 22:19:23 2011 +0200
+
+    maint: prepare for the tight-scope check
+    
+    * src/diff.h: Mark function declarations with "extern" in
+    preparation for the tight-scope check.
+    (ignore_white_space): Separate enum decl from declaration
+    of this variable.
+    * src/Makefile.am (diff_SOURCES): Move diff.h from here to ...
+    (noinst_HEADERS): ...here.
+    For convenience, since the tight-scope rule uses $(noinst_HEADERS).
+
+commit 0744f3339d691dbce47e5e0c9ca8652ff8f79f0b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri May 13 11:12:33 2011 +0200
+
+    maint: don't use now-removed gnulib "exit" module
+    
+    * bootstrap.conf (gnulib_modules): Remove "exit" module.
+    It no longer exists.
+
+commit 7d638238a2f3e419948a92024fb67739c61894ce
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Mar 26 13:45:52 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 8a223056984c0153638e33e074cf334a32b3fd97
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Mar 26 13:44:13 2011 +0100
+
+    * .x-sc_space_tab: Remove file.  Instead, ...
+    
+    * cfg.mk (exclude_file_name_regexp--sc_space_tab): ...define this.
+
+commit d9d3cf9f096df7c11c4453b8453f53eda53939fa
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Mar 26 12:46:26 2011 +0100
+
+    maint: fix typo in unused rule
+    
+    * cfg.mk (config-save): Fix typo: add leading "_" in variable name.
+
+commit 23d970ea5f71fc8913d7e2a4d33b575b13b43fb9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Mar 18 22:38:59 2011 +0100
+
+    doc: add a reference to wdiff(1) from diff.1
+    
+    * man/diff.x: New file, to add "SEE ALSO" reference to wdiff(1).
+    * man/Makefile.am (diff.1): Depend on diff.x.
+    ($(dist_man1_MANS)): Tell help2man to include diff.x.
+    (EXTRA_DIST): Add diff.x.
+    Suggestion from Dan Jacobson in http://bugs.debian.org/613319
+
+commit ffd622a2814e9f9d66ab3077d93107ff2f7266df
+Author: Eric Blake <eblake@redhat.com>
+Date:   Fri Mar 18 15:26:59 2011 -0600
+
+    docs: info should mention -L
+    
+    * doc/diff.texi (diff Options): Document -L.
+
+commit c549fc6c777f025a303c9f980f360a644affd65e
+Author: Eric Blake <eblake@redhat.com>
+Date:   Fri Mar 18 15:19:37 2011 -0600
+
+    docs: diff --help should mention -L
+    
+    * src/diff.c (option_help_msgid): Document -L.
+
+commit 3f2d868741b500a9817a62e3cab12a24c6615a76
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Feb 14 09:39:44 2011 +0100
+
+    doc: speak of the --test (-a) option, not "the -a or --test option"
+    
+    Convert using this command:
+    perl -pi -e \
+      's/(\@option{-.}) or (\@option{--.*?}) option/$2 ($1) option/' \
+      doc/diff.texi
+    Then convert some more with this:
+    perl -pi -e \
+        's/the (\@option{-.}) or (\@option{--.*?})$/the $2 ($1)/' \
+      doc/diff.texi
+    Then convert more manually.
+    
+    Suggested by Dan Jacobson
+
+commit 91da1da696e1d13ab7e288ede04d03fd2d12e79a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 12:27:32 2011 +0100
+
+    maint: remove all uses of vfork: use fork instead
+    
+    Our use of vfork now provokes warnings from gcc-4.6.0.
+    Also, vfork is no longer even specified by POSIX.1-2008.
+    * src/diff3.c (read_diff): Change each use of vfork to "fork".
+    Remove #ifdef'd code.
+    * src/util.c (begin_output, finish_output): Likewise.
+    * src/sdiff.c (cleanup, main, edit): Likewise.
+    (handler_index_of_SIGPIPE): Remove now-unused definition.
+    * src/system.h: Don't include <vfork.h>.
+    (vfork): Remove definition.
+    * ms/config.site: Remove reference to vfork cache variable.
+
+commit 4e0d3664c7a1a7515309b140dbf8ff27538423cf
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 16:32:00 2011 +0100
+
+    tests: avoid newer but less-portable tail option syntax
+    
+    * tests/function-line-vs-leading-space: Use sed -n '3,$p' rather than
+    tail -n+3.  Older versions of tail do not accept that newer syntax.
+    Reported by Sudhakara Peram.
+
+commit bf4003c13d75c927f5f616b2c38eef7c3d7e28c4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 13:36:17 2011 +0100
+
+    tests: fix an erroneous test
+    
+    On most systems, like-named files were compared, by luck.
+    However, on others, different-named files would be compared
+    since their names were being treated as equal -- but they had
+    different content, so the test would fail.
+    * tests/colliding-file-names: Use different sets of file names
+    in d1 and d2 so that they cannot accidentally match.
+    Put the same line in each test file.  This is required
+    when files named e.g., abc and ABC are compared.
+    This test was failing on a NixOS 86_64-darwin system.
+
+commit 7e27c1ae467d2b2d611668abcd2e86f650a2d453
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 12:34:49 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 13b0958f25f67ad1d759105921650243dfbe648c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 12:13:16 2011 +0100
+
+    tests: fix typo that silently disabled all tests
+    
+    * tests/Makefile.am (TESTS): Fix typo: s/jESTS/TESTS/
+
+commit c16c3176840de5a153186aa9f981453cac25451f
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 23 18:58:27 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 9de94f53b5b63330b7658f3b63d06021aabfc7c6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 23 18:57:50 2011 +0100
+
+    maint: avoid new syntax-check failure
+    
+    * src/diff.c (specify_value): Use !STREQ(...), not strcmp(...) != 0.
+    * src/diff3.c (main): Likewise.
+
+commit ce5367b6b3e4df909883f41f3ad6f12981f5a263
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 3 22:08:42 2011 +0100
+
+    maint: update copyright year ranges to include 2011
+    
+    Run "make update-copyright", so "make syntax-check" works in 2011.
+
+commit 7f0be31391ce956341690c85a060a541a02f8480
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 3 22:04:45 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 6fc3b9737d71c149b5198d957e993d620632d360
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 16 10:05:21 2010 -0800
+
+    bootstrap: adjust to recent gnulib changes
+    
+    * bootstrap.conf (excluded_files): Do not exclude m4/size_max.m4
+    and m4/xsize.m4 when using an external gettext, since they are
+    now needed by other gnulib modules.
+
+commit 5c65882affa003bab8b21c6f1cdfa038d51b5ca6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Dec 16 15:20:24 2010 +0100
+
+    doc: add contributor guidelines: HACKING
+    
+    * HACKING: New file, copied 99% from the one in grep's repository.
+
+commit 9026760882adce9e2a000cb9f64d3b2a2de410cc
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Oct 9 15:24:05 2010 +0200
+
+    maint: describe policy on copyright year number ranges
+    
+    * README: Mention coreutils' long-standing policy on use of M-N
+    ranges in copyright year lists.  Requested by Richard Stallman.
+
+commit 361b3b13da25366256745b7cce4ff71231ef24e9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 09:08:08 2010 +0200
+
+    maint: adjust init.sh use to conform
+    
+    * tests/help-version: Use one line: "${srcdir=.}/init.sh"; ...
+    * tests/basic: Likewise.
+    * tests/binary: Likewise.
+    * tests/colliding-file-names: Likewise.
+    * tests/excess-slash: Likewise.
+    * tests/function-line-vs-leading-space: Likewise.
+    * tests/help-version: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/no-newline-at-eof: Likewise.
+    * tests/stdin: Likewise.
+
+commit d5d4b828b46628977ec5b75d731649c65f8e1bf2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 09:04:43 2010 +0200
+
+    maint: avoid shadowing warning
+    
+    * src/dir.c (diff_dirs): Rename shadowed local cmp to "c".
+
+commit edf0032df445a519b503f72147fa3f846983df56
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 08:55:48 2010 +0200
+
+    build: use gettext-h, not gettext
+    
+    * bootstrap.conf (gnulib_modules): Use gettext-h, not gettext.
+    The latter is overkill for a package that uses
+    AM_GNU_GETTEXT([external]...
+
+commit 0d0c959471b898f18166f65dcb164c7b602a416c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 08:54:18 2010 +0200
+
+    build: update build/test tools from gnulib
+    
+    * bootstrap: Update from gnulib.
+    * tests/init.sh: Likewise.
+
+commit 0ffe188b2bc56ebeb54dcefbb24d64849f20df1b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 08:53:28 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit 53de393ca335e77f22d3789100734c87868f12b3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Aug 14 17:13:28 2010 -0500
+
+    diff -r: avoid printing excess slashes in concatenated file names
+    
+    * bootstrap.conf (gnulib_modules): Add filenamecat.
+    * src/diff.c: Include "filenamecat.h".
+    (compare_files): Use file_name_concat, rather than dir_file_pathname.
+    * src/util.c (dir_file_pathname): Remove now-unused function.
+    * src/diff.h: Remove its declaration.
+    * tests/excess-slash: New script to test for this.
+    * tests/Makefile.am (TESTS): Add it.
+    Forwarded by Santiago Vila from <bugs.debian.org/586301a>,
+    reported by Jari Aalto.
+
+commit f2ad578b241713fa81d98b3573fa42397d2ea3f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 12 17:55:05 2010 -0700
+
+    diff: avoid spurious diffs when two distinct dir entries compare equal
+    
+    Problem reported by Christoph Anton Mitterer in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2010-08/msg00000.html
+    
+    * NEWS: Mention this bug fix.
+    * src/dir.c (compare_names_for_qsort): Fall back on file_name_cmp
+    if two distinct entries in the same directory compare equal.
+    (diff_dirs): Prefer a file_name_cmp match when available.
+    * tests/Makefile.am (TESTS): New test colliding-file-names.
+    * tests/colliding-file-names: New file.
+
+commit a0e9e5e67a6a34e131eb392ddb99569bc973748e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 9 19:09:26 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit bec2cfcd8f73c81219a0f348718b01766e274621
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 9 18:39:39 2010 +0200
+
+    build: don't define macros that gnulib provides
+    
+    * bootstrap.conf (gnulib_modules): Add signal, stdint.
+    * lib/cmpbuf.c (SA_RESTART, SA_INTERRUPT): Remove definitions.
+    (SIZE_MAX, PTRDIFF_MAX): Likewise.
+    Include <stdint.h>.
+    * src/system.h (WEXITSTATUS, WIFEXITED): Remove definitions.
+    (SA_RESTART, SA_INTERRUPT): Likewise.
+
+commit 6ef1f1f7086021b90c81636de26373c3fe472e5c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 9 18:34:09 2010 +0200
+
+    build: rely on gnulib's sigprocmask module
+    
+    * src/sdiff.c: Remove #if-!HAVE_SIGPROCMASK-guarded code.
+    * bootstrap.conf (gnulib_modules): Add sigprocmask.
+
+commit 6cfdf0ab03ce32dad30460e8fd00e7ecc9db5a7b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue May 4 09:55:31 2010 +0200
+
+    doc: README-release: don't mention To:, Cc:, etc announcement headers,
+    
+    now that those are supplied automatically via gnulib's maint.mk.
+    * README-release: sync with coreutils.
+
+commit 40adeecffd03ad56e3ed0054c9ee9f31a86397dd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 23:16:56 2010 +0200
+
+    maint: teach web-doc-generating code how to do its job
+    
+    * cfg.mk (gendocs_options): Define, so that gendocs.sh knows
+    the name of our texinfo source file.
+    * gnulib: Update to latest, for new gnu-web-doc-update and maint.mk.
+
+commit e7616f6408417cca7df49c4b030047757b856d88
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 20:35:06 2010 +0200
+
+    doc: update release procedure
+    
+    * README-release: Rearrange slightly: post the announcement to
+    Savannah first, so you can include a link to that post in the email.
+    Sync a few details from coreutils' README-release.
+
+commit d03317ad6abccf98a0c6fb0f9ffb9509feee1965
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 18:52:56 2010 +0200
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 022cd5c5eb647a22a4daa5fe5cbc10af6d5a1112
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 18:49:55 2010 +0200
+
+    version 3.0
+    
+    * NEWS: Record release date.
+
+commit ee02ef075faaab2feb61a5f4a6120e11517dac8d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 08:53:31 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit 3f027ba48d26ebca62066845832e12062a1ed8b2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat May 1 08:17:06 2010 +0200
+
+    build: use gnulib's sys_wait module
+    
+    * bootstrap.conf (gnulib_modules): Use gnulib's sys_wait module,
+    now that we assume its presence.
+
+commit 5c63f4d41638b863f5c5a71401af6e1c042d223d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 30 18:46:27 2010 +0200
+
+    build: update gnulib submodule to latest
+    
+    * bootstrap: Also update from gnulib.
+    * tests/init.sh: Likewise
+
+commit 7ea9bf381b354cbf5e05ab89e0ee2009162bc09a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 30 18:56:03 2010 +0200
+
+    maint: remove now-useless #if HAVE_HEADER_H guards
+    
+    * src/system.h: Include <sys/wait.h> unconditionally,
+    now that gnulib guarantees its presence.
+    * lib/cmpbuf.c: Likewise for <unistd.h> and <inttypes.h>.
+
+commit 59669066e7771fa01912e4c2081ad80aa78d3f68
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Apr 17 08:21:32 2010 +0200
+
+    tests: use original no-newline-at-eof test, but with -U1, not -U2
+    
+    * tests/no-newline-at-eof: Revert to the smaller test, but with
+    -U1 rather than -U2, since that actually triggers the bug.
+
+commit 4ba438168d7508853e4be9f74ad6d95ac024a20a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 16 22:20:04 2010 -0700
+
+    Followon improvements for the fix for Debian bug 577832.
+    
+    * src/io.c (find_and_hash_each_line): Omit the inserted newline in
+    a simpler way.
+    * tests/no-newline-at-eof: Fix the test case so that it rejects
+    the old, buggy behavior.
+
+commit 16e65488ddd26fe0ad3f8d8ebd30709c9291e6dd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 16 11:18:10 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit 6bb3d2900866c23da01a409aa3447ecf68627fc1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 16 09:14:04 2010 +0200
+
+    tests: test for the no-newline-at-EOF bug
+    
+    * tests/no-newline-at-eof: New file.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit f444711a2639b4974ff3e720c455a1f96f1109e8
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Apr 15 23:26:22 2010 +0200
+
+    diff: fix a regression when at least one input lacks a newline-at-EOF,
+    
+    and the final hunk plus context-length aligns exactly with the end
+    of the newline-lacking file.  Diff would fail to output the required
+    "\ No newline at end of file" line, thus rendering the output invalid.
+    This bug appears to have been introduced by 2006-05-07
+    commit 58d0483b, "(find_identical_ends): Fix huge performance bug...",
+    at least to the extent that reverting that change fixes the bug.
+    Considering the stated effect of that change and lack of metrics,
+    reverting it is not an option, so here we take a more direct approach.
+    
+    Given these inputs,
+    
+        printf '\n1'>a; printf '\n0\n\n1'>b
+    
+    and running diff like this:
+    
+        ./diff -U1 a b
+    
+    for input file "b", the pointer, files[1].linbuf[4][-1], to
+    the last byte on the final line was mistakenly pointing at the
+    sentinel newline at EOF, rather than at the preceding byte.
+    
+      (gdb) p files[1].linbuf[4][-1]
+      $3 = 10 '\n'
+    
+    Thus, this test in the final print_1_line call:
+    
+      if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+        fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+    
+    would fail, because limit[-1] (which is files[1].linbuf[4][-1])
+    was mistakenly '\n', rather than the desired '1'.
+    
+    My first thought was simply to adjust the final linbuf[line] setting,
+    at the end of io.c's find_and_hash_each_line function function:
+    
+           if (p == bufend)
+    -       break;
+    +       {
+    +         if (current->missing_newline)
+    +           --linbuf[line];
+    +         break;
+    +       }
+    
+    But that would make diff misbehave with this input
+    (same as above, but with a newline appended to "a"),
+    
+        printf '\n1\n'>a; printf '\n0\n\n1'>b
+        ./diff -U1 a b
+    
+    due to the block (100 lines above) that is triggered in that case
+    (but not in the both-files-missing-newline case):
+    
+          if (p == bufend
+              && current->missing_newline
+              && ROBUST_OUTPUT_STYLE (output_style))
+            {
+              /* This line is incomplete.  If this is significant,
+                 put the line into buckets[-1].  */
+              if (ignore_white_space < IGNORE_SPACE_CHANGE)
+                bucket = &buckets[-1];
+    
+              /* Omit the inserted newline when computing linbuf later.  */
+              p--;
+              bufend = suffix_begin = p;
+            }
+    
+    Note how "p" is decremented and "bufend" adjusted.
+    When that happens, we certainly don't want to decrement
+    "bufend" yet again.
+    
+    Since there is no other way to determine at the end whether "bufend"
+    was already decremented, add a new variable to serve as witness.
+    
+    * NEWS (Bug fixes): Mention it.
+    Reported by Timo Juhani Lindfors in http://bugs.debian.org/577832.
+    Forwarded by Santiago Vila.
+
+commit 648802169a29ea096d6e9813b043b91af9342f8d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 16 08:47:28 2010 +0200
+
+    tests: update init.sh from gnulib
+    
+    * tests/init.sh: Update from gnulib.
+
+commit 4065b154b0eda7aa100bcd0a905b0f4304fbacfd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Apr 8 11:04:15 2010 +0200
+
+    build: include cfg.mk and dist-check.mk in the distribution tarball
+    
+    * Makefile.am (EXTRA_DIST): Add cfg.mk and dist-check.mk.
+
+commit 70a02578aebbc3f0fd6edea240d5c1e9e76101e3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Apr 8 11:02:32 2010 +0200
+
+    maint: update to latest gnulib
+    
+    * cfg.mk (sc_cross_check_PATH_usage_in_tests): Remove rule,
+    now that it's in gnulib's maint.mk.
+    * gnulib: Update to latest.
+
+commit 0c6d7eea33394375e0e794e72c7896508645f426
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 11:43:14 2010 +0200
+
+    tests: make new PATH-crosschecking syntax-check tighter
+    
+    * cfg.mk (sc_cross_check_PATH_usage_in_tests): Use grep's -x (match
+    entire line) option with -F.
+
+commit fe2d46d4aaa79e15d2df24ae387c032858982c3f
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 10:59:00 2010 +0200
+
+    tests: pull latest help-version from gzip
+    
+    * tests/help-version: Update from gzip.
+    * Makefile.am (TESTS_ENVIRONMENT): Export VERSION,
+    as required for this new help-version script.
+
+commit 46773b6abbfd75432387a6e28579a11c62e897d9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 10:51:19 2010 +0200
+
+    tests: add syntax-check rule to verify that tests use proper PATH
+    
+    * cfg.mk (sc_cross_check_PATH_usage_in_tests): New rule, that is
+    useful only in conjunction with the help-version script.
+
+commit 55cf264a2bac21ed6b8729bc175df421e35facf4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 10:56:06 2010 +0200
+
+    tests: use path_prepend_ consistently; remove unnecessary VERBOSE check
+    
+    * tests/basic: Likewise.
+    * tests/binary: Likewise.
+    * tests/function-line-vs-leading-space: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/stdin: Likewise.
+
+commit eb7d0cc49110157fe0a7820f39cb052371af2699
+Author: Eric Blake <eblake@redhat.com>
+Date:   Tue Apr 6 10:11:35 2010 -0600
+
+    maint: ignore generated files
+    
+    * .gitignore: Ignore recent gnulib additions.
+
+commit a7784f93efeb7609159de1217d43231a9f7a7f2f
+Author: Eric Blake <eblake@redhat.com>
+Date:   Tue Apr 6 10:03:29 2010 -0600
+
+    maint: update to latest bootstrap
+    
+    * bootstrap: Copy from gnulib/build-aux.
+
+commit adc5cf557b1f56c8ed1aff907ca3e9abf344ce86
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Apr 5 22:08:58 2010 +0200
+
+    tests: get latest init.sh from gnulib
+    
+    * tests/init.sh: Update from gnulib.
+
+commit c5b10cdca91e438acc819b0cde4ea694ce52d3d2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Apr 5 21:47:17 2010 +0200
+
+    build: update gnulib submodule to latest; adapt
+    
+    * cfg.mk (local-checks-to-skip): Add new sc_texinfo_acronym, to skip it.
+
+commit eb8258b8c6b3930e06fc20b02456448c43daeff1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Mar 18 18:10:29 2010 +0100
+
+    diff -F/-p: don't depend on locale-specific white-space definition
+    
+    * src/context.c: Include "c-ctype.h".
+    Use c_isspace, not isspace.
+
+commit f21d1195aef067e6459cca8a1b79a50498a10532
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Mar 18 17:25:50 2010 +0100
+
+    tests: exercise new behavior of -F RE
+    
+    * tests/function-line-vs-leading-space: New file.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 24cc227fa1900502d167a60a8325af576dfe5552
+Author: Yannick Moy <yannick.moy@adacore.com>
+Date:   Thu Mar 4 14:20:16 2010 +0100
+
+    with -F or -p, emit better function lines: no leading white space
+    
+    * src/diff.c (print_context_function): For languages like Ada
+    that allow local functions and procedures, the plain context
+    function line may start with enough blank characters that the
+    function name does not get completely printed in the 40
+    characters limit.  This patch solves this problem by removing
+    these useless initial blank characters.
+    * NEWS (Changes in behavior): Mention this change.
+
+commit d9c2b10e33c2fd073a10e7770c859c16001592f9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Mar 17 16:53:17 2010 +0100
+
+    build: don't require a specific version of help2man
+    
+    * bootstrap.conf (buildreq): Bootstrap can't deal with it,
+    perhaps because the command name contains a digit.
+
+commit 61fb56b31483ae1c3d483ce099d3468697d37a75
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Mar 17 15:52:05 2010 +0100
+
+    build: make bootstrap ensure that help2man is available
+    
+    * bootstrap.conf (buildreq): Add help2man.
+
+commit 1afa8038498155d2666c387547dd2c8c44ca718e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Feb 23 09:39:07 2010 +0100
+
+    tests: test for the "Binary files A and B differ" diagnostic
+    
+    * tests/binary: New script.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 3f591f4bb5776b4fc91573b940a9d845458cc617
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 18 12:59:29 2010 +0100
+
+    revert 2002 change that removed "Binary " from "files A and B differ"
+    
+    With this change, "printf '\0'|diff - /dev/null" now prints
+    "Binary files - and /dev/null differ" once again.
+    This reverts 2002-06-28 commit a352f0980,
+    "(briefly_report): Don't say "Binary files differ", ...".
+    * src/analyze.c (briefly_report): Do include the "Binary " prefix
+    in the diagnostic, when !brief.
+    * NEWS (Changes in behavior): Mention the diagnostic change.
+    Reported by Andreas Hoenen in http://bugs.debian.org/570064.
+
+commit aa56d5f6d086855785d2fe83d148cf090eabee80
+Author: Juan Manuel Guerrero <juan.guerrero@gmx.de>
+Date:   Sun Feb 14 18:16:25 2010 +0100
+
+    avoid compilation failure on systems lacking both fork and vfork
+    
+    * src/sdiff.c [!HAVE_WORKING_FORK && !HAVE_WORKING_VFORK] (main):
+    Pass the right number of arguments to shell_quote_copy.
+    * src/util.c [!HAVE_WORKING_FORK && !HAVE_WORKING_VFORK] (begin_output):
+    Likewise.
+
+commit 9999d0b8dff45ef3b093e9addebf4ff1b464d9fc
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 11 11:09:01 2010 +0100
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 66f2f2d60ab2bd66c820e255f2ce8bfdcaca34a9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 11 10:45:20 2010 +0100
+
+    version 2.9
+    
+    * NEWS: Record release date.
+
+commit fecd0079fe6e15b0f53bf953721d838d9099bf05
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 11 09:06:02 2010 +0100
+
+    doc: document the release procedure
+    
+    * README-release: New file.
+
+commit 9f735dd16ab54550329f2fad357d816f7438e7d0
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Feb 10 11:37:23 2010 +0100
+
+    maint: change use of "|" to more maintainable "||" (no semantic change)
+    
+    * src/analyze.c (diff_2_files): Using the "||" operator happens to
+    be equivalent to using "|" in this case.  It is also clearer and
+    less prone to inadvertent bug introduction, in case the variable,
+    "changes" were ever to take on a value not in {0,1}.
+    Patch by Tim Waugh, via Mike Frysinger.
+
+commit b50a16567acff496bdf3ac0004809b6dcc88c2d6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Feb 10 09:09:55 2010 +0100
+
+    portability: avoid "diff - ..." failure at least on *BSD and Solaris
+    
+    The new "stdin" test was failing on many types of systems.
+    * src/diff.c (compare_files): Guard use of xfreopen (NULL, "rb", ...
+    also with O_BINARY, so as to avoid this unnecessary call on
+    systems where it's not needed (on some it fails with "Bad address".
+
+commit b22f6671d773e326fdc9c4b096a5c056c6cd0509
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Feb 10 08:55:59 2010 +0100
+
+    tests: honor VERBOSE
+    
+    * tests/basic: Enable "set -x" if $VERBOSE.
+    * tests/help-version: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/stdin: Likewise.
+
+commit a1dcb61f03265e69a0ebd4f09deb45af3e1a56b9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Feb 5 07:46:44 2010 +0100
+
+    build: update gnulib submodule to latest
+
+commit 3c0aac1e7efa0410e913c9a5b936e5759c63901f
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 4 20:02:06 2010 +0100
+
+    sync with gnulib
+    
+    * gl/lib/regcomp.c.diff: Adjust to apply to the latest in gnulib.
+    * gnulib: Update submodule to latest.
+
+commit 6bb67138079e8ef3457ee1fa07cebcb78b6049d6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 17 11:39:00 2010 +0100
+
+    build: do not override gnulib-provided AM_CFLAGS options
+    
+    Avoid a warning from automake:
+    lib/Makefile.am:23: AM_CFLAGS multiply defined in condition TRUE ...
+    lib/gnulib.mk:30: ... `AM_CFLAGS' previously defined here
+    lib/Makefile.am:18:   `lib/gnulib.mk' included from here
+    
+    * lib/Makefile.am (AM_CFLAGS): Append $(WARN_CFLAGS) and
+    $(WERROR_CFLAGS), i.e., use "+=", not "=".
+    This was introduced via 2009-12-17 commit e58efa5b
+    "build: enable warnings and -Werror.",
+    but fortunately is not a bug, because the definition
+    it would have overridden was always empty.
+
+commit f51320402bf1342d47199f7dfe37add89092ee5b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 17 11:15:26 2010 +0100
+
+    maint: add to .gitignore
+    
+    * .gitignore: Ignore more.
+
+commit ef2251a3e5fa8bdf667cf38a9d9cbca38db1137b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 16 08:32:06 2010 +0100
+
+    doc: add to TODO
+    
+    * TODO: Add an item, suggested by Dan Jacobson.
+
+commit 07e844a96ddecc1702b847ce95d956409a75de46
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Jan 13 13:54:13 2010 +0100
+
+    tests: ensure that an argument of "-" is treated as standard input
+    
+    * tests/stdin: New test.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 2d648ae3fe10d9b554f7c2c5ee8c84371e687392
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 10 11:45:20 2010 +0100
+
+    tests: now "make distcheck" runs more tests, incl. syntax-check
+    
+    * cfg.mk: Include dist-check.mk, from coreutils.
+    * Makefile.am (distcheck-hook): Define rule, to hook to...
+    * dist-check.mk: New file.
+
+commit 617600b42265557a2d3be46e6277697ec47df90d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 9 11:48:53 2010 +0100
+
+    build: update gnulib to latest, for fixed syntax-check rule
+
+commit a5188c6f727aa4abeb414950179a27da4a2e0142
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 9 11:18:46 2010 +0100
+
+    maint: record updated NEWS hash
+    
+    * cfg.mk (old_NEWS_hash): Update to account for GFDL change.
+
+commit a9d7c6d1a52970f26741f6af4cf873730ad50c2a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Jan 8 11:35:26 2010 +0100
+
+    build: update gnulib submodule to latest
+
+commit 4e1233f063e4c3e5421cd28245b96f2607a7038b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 9 11:05:59 2010 +0100
+
+    tests: add a test of basic functionality
+    
+    * tests/basic: Start adding tests.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit cadd497e2759a208c3512b9c8c6c7fb61c5fbb22
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Jan 8 11:34:43 2010 +0100
+
+    maint: udpate GFDL license to 1.3
+    
+    * doc/diff.texi: Update to use GFDL version 1.3.
+
+commit cb251009d3ca44aca9934d87ab3a2af1c0e66f90
+Author: Eric Blake <ebb9@byu.net>
+Date:   Sat Jan 2 10:17:00 2010 -0700
+
+    build: allow compilation on cygwin
+    
+    * src/Makefile.am (cmp_LDADD): Move LIBICONV...
+    (LDADD): ...into global flags, since all programs need it.
+
+commit b20ae152dd435cd10b7bb207a948616d6b6332fd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 3 18:54:21 2010 +0100
+
+    maint: record update-copyright options for this package
+    
+    * cfg.mk: Next time, just run "make update-copyright".
+
+commit a6b73e6dd7a293316f669a8930198d140df6236b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 3 18:39:19 2010 +0100
+
+    tests: prepend ../src, not "." to PATH
+    
+    * tests/help-version: Correct PATH.
+
+commit 6a44886e245da5862051080a6c7938dd1f0a3fc3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Jan 1 16:18:27 2010 +0100
+
+    maint: update all FSF copyright year lists to include 2010
+    
+    Use this command:
+    git ls-files |grep -vE '^(\..*|COPYING|gnulib)$' |xargs \
+    env UPDATE_COPYRIGHT_USE_INTERVALS=1 build-aux/update-copyright
+
+commit 10d11122eaa135104737d462015d48041c304f1d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Dec 31 17:20:42 2009 +0100
+
+    maint: newer gnulib; don't hard-code my GPG key ID
+    
+    * cfg.mk (gpg_key_ID): Remove definition, now that maint.mk automates it.
+    * gnulib: Update to latest.
+
+commit 9fe26edf840736d3c4d6c89005b3a0c860444d4c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 28 19:36:01 2009 +0100
+
+    tests: exercise diff -p's function-name matching
+    
+    * tests/label-vs-func: New file.
+    * tests/Makefile.am (TESTS): Add label-vs-func.
+    Reported by Simon Arlott <simon@fire.lp0.eu>
+    http://article.gmane.org/gmane.linux.kernel.janitors/14260
+
+commit e0fc06c5ce4e7c370ae2366b35c5952023c537fe
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 28 19:31:46 2009 +0100
+
+    tests: use gnulib's init.sh
+    
+    * tests/Makefile.am (EXTRA_DIST): Add init.sh.
+    Remove test-lib.sh.
+    * tests/init.sh: New file.
+    * tests/test-lib.sh: Remove file.
+    * tests/help-version: Use init.sh, not test-lib.sh.
+
+commit 37abff282fc5adb392653c7a11e56bb733a672e6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 28 19:43:28 2009 +0100
+
+    maint: don't let trailing spaces in diffs perturb make syntax-check
+    
+    * .x-sc_space_tab: New file.
+
+commit e58efa5bd2f2fdab0aff6395b9d6c46e0db09fd3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 21 17:45:33 2009 +0100
+
+    build: enable warnings and -Werror.
+    
+    * src/Makefile.am (AM_CFLAGS): Enable warnings and -Werror.
+    Set to this: $(WARN_CFLAGS) $(WERROR_CFLAGS)
+    * lib/Makefile.am (AM_CFLAGS): Similarly, but use this:
+    $(GNULIB_WARN_CFLAGS) $(WERROR_CFLAGS)
+    * configure.ac (GNULIB_WARN_CFLAGS): Don't turn off -Wuninitialized.
+
+commit 8c3d25a63a2c5912170ef6e13f748f3904e6b5cf
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Nov 22 17:06:57 2009 +0100
+
+    build: avoid a warning from gnulib's sh-quote.c
+    
+    * gl/lib/sh-quote.c.diff: New file, to avoid a warning.
+
+commit f4bde95cc1eb6d36629163797a04d698d6e3b483
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 21 18:08:00 2009 +0100
+
+    maint: avoid warnings via patched versions of gnulib's regex functions
+    
+    * gl/lib/regcomp.c.diff: New file.
+    * gl/lib/regex_internal.c.diff: Likewise.
+    * gl/lib/regex_internal.h.diff: Likewise.
+    * gl/lib/regexec.c.diff: Likewise.
+
+commit f8435aeffe78d4090828937f9bedfc8290f1c1e9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 21 19:33:01 2009 +0100
+
+    build: update gnulib submodule to latest
+
+commit 4c048db1c7f64e937ae58593158714d48545fbb5
+Author: Eric Blake <ebb9@byu.net>
+Date:   Fri Nov 20 14:55:05 2009 -0700
+
+    build: ignore more files
+    
+    * .gitignore: Add config.cache, *.exe.
+    
+    Signed-off-by: Eric Blake <ebb9@byu.net>
+
+commit e5b1ef85fbc034ffc5f3a0c18fa2917fba42ec89
+Author: Eric Blake <ebb9@byu.net>
+Date:   Thu Nov 19 09:15:28 2009 -0700
+
+    build: fix test run on cygwin
+    
+    This, plus a gnulib update for xalloc-die-tests, are necessary
+    for make check to pass on cygwin.
+    
+    * tests/Makefile.am (built_programs): Ignore $(EXEEXT).
+    * src/Makefile.am (paths.h): Add missing dependency.
+
+commit 25742fce0a76d714d6f0669610cff0804ff90895
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 22:49:00 2009 +0100
+
+    maint: remove vestiges of nanosleep
+    
+    * src/Makefile.am (LDADD): Remove $(LIB_NANOSLEEP), now
+    that we no longer use the nanosleep module.
+    Spotted by Eric Blake.
+
+commit e90c254a0ebafd26a0ea07e2ec3867c539947f63
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 22:30:41 2009 +0100
+
+    maint: don't pull in gnulib's nanosleep unnecessarily
+    
+    * bootstrap.conf (gnulib_modules): Remove nanosleep.  Not needed.
+    Spotted by Eric Blake.
+
+commit 3f7fe0297caa17a2acdc97a30896dd8963b1def4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 17:07:47 2009 +0100
+
+    maint: cfg.mk: remove factored-out ftp host/dir definitions
+    
+    * cfg.mk (gnu_ftp_host-alpha, gnu_ftp_host-beta gnu_ftp_host-stable):
+    (gnu_rel_host, url_dir_list): Remove definitions.  The defaults,
+    now provided by maint.mk, are the same.
+    * gnulib: Update for latest, including those maint.mk additions.
+
+commit 2fe6784a3507be4fc1ae9d78eb5b8c6d6f759ae6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 10:36:54 2009 +0100
+
+    build: link with now-required libraries
+    
+    * src/Makefile.am (LDADD): Add gnulib-required libraries.
+    (cmp_LDADD): Add $(LIBICONV), for cmp's use of proper_name_utf8.
+
+commit 4fe5ec326f4a09060ec30097cef9ba8b547f69d5
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 10:26:48 2009 +0100
+
+    maint: lib/xfreopen.c contains translatable strings
+    
+    * po/POTFILES.in: Add lib/xfreopen.c.
+
+commit 788645f184922bce1d9851c4fd2f193458935046
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 09:58:45 2009 +0100
+
+    maint: remove hard-coded macro definitions provided by intprops.h
+    
+    * lib/cmpbuf.c: Include "intprops.h" rather than open-coding macros
+    like TYPE_SIGNED and TYPE_MINIMUM.
+
+commit 3b828e32235ebe162ec2093e56e0e0dd778b6e71
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 20:35:52 2009 +0100
+
+    maint: add gnulib's announce-gen module
+    
+    * bootstrap.conf (gnulib_modules): Add announce-gen
+
+commit 975a1e0418b41f95f67efa7fa5a5db7c8432632d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 18:51:53 2009 +0100
+
+    build: suppress warnings about bindtextdomain and textdomain
+    
+    * src/system.h (bindtextdomain, textdomain) [!ENABLE_NLS]: Define away.
+
+commit 7ebb24620d87386e5579bef6ff0e50778dff84be
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 18:10:56 2009 +0100
+
+    build: use more gnulib modules
+    
+    * bootstrap.conf (gnulib_modules): Add mktime, nanosleep, strptime
+    and timegm.
+
+commit cd10d2c30801df4abf60dd0fb54ddd4a2f9fc02a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 16:09:56 2009 +0100
+
+    use xfreopen rather than freopen
+    
+    * src/cmp.c: Include "xfreopen.h".
+    Use xfreopen in place of freopen.
+    * src/diff.c Likewise, and...
+    (main): Set exit_failure to EXIT_TROUBLE, rather than to 2.
+    * src/diff3.c: Likewise.
+    * bootstrap.conf (gnulib_modules): Add xfreopen.
+
+commit 163f2fa3e873d2dfebce2c41abc8532a9fa370f9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 15:39:47 2009 +0100
+
+    build: enable many warnings
+    
+    * configure.ac: Add support for --enable-gcc-warnings.
+    * bootstrap.conf (gnulib_modules): Add manywarnings.
+    * Makefile.am (AM_CFLAGS): Add $(WARN_CFLAGS) $(WERROR_CFLAGS)
+
+commit 3eee17bbbe3798d91b9e36f5756b0de391eb61d5
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 10:20:31 2009 +0100
+
+    build: update gnulib submodule to latest
+
+commit d837c269eac591b4fedf58deba84e00f3c6c334c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 19:43:46 2009 +0100
+
+    maint: add an assertion to suppress clang-detected warning
+    
+    The clang static analyzer reported that a NULL parent could be
+    dereferenced.  However, that cannot happen, because for all callers,
+    the parameter, parent, is always non-NULL at that point.
+    * src/diff.c: Include <assert.h>.
+    Assert that parent is not NULL.
+
+commit 7af115552a637d96a98ddd17353c6e7f94e137b4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 19:40:11 2009 +0100
+
+    maint: remove dead assignment from diff3.c
+    
+    * src/diff3.c (make_3way_diff): Remove dead assignment.
+
+commit 6be63587089728ac8dd140781ae586fb314d9ac4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 18 07:41:04 2009 +0100
+
+    build: update gnulib submodule to latest
+
+commit 2514ec69733ac7491cd80b9e4710034e6218a134
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 21:49:37 2009 +0100
+
+    maint: hide build commands behind $(AM_V_GEN)
+    
+    * src/Makefile.am (paths.h): Use $(AM_V_GEN), and split a long line.
+    * man/Makefile.am ($(dist_man1_MANS)): Use $(AM_V_GEN) here, too.
+
+commit a401664d47f17b1c7497c2a251b073de105cdbec
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 21:41:38 2009 +0100
+
+    build: let automake generate better man-installation rules
+    
+    * man/Makefile.am (dist_man1_MANS): Rename from dist_man_MANS,
+    to enable better automake-generated installation rules.
+
+commit 5f93400251fb7be08fa03ef7c2dd78b4850481ba
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 17:15:38 2009 +0100
+
+    admin: ignore all of gnulib-tests
+    
+    * .gitignore: Add gnulib-tests
+
+commit 8fbbf26925a6e2183be8211fb82a6eb518229a38
+Author: Eric Blake <ebb9@byu.net>
+Date:   Thu Nov 12 08:17:56 2009 -0700
+
+    build: avoid link failure when libsigsegv is used
+    
+    * src/Makefile.am (LDADD): Link against LIBSIGSEGV.
+
+commit 9b0a630024092f50d6c94d9d033c02dd5bdd6a5b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 09:01:57 2009 +0100
+
+    maint: define/use PROGRAM_NAME and AUTHORS; use propername module
+    
+    * bootstrap.conf (gnulib_modules): Add propername.
+    * src/cmp.c (PROGRAM_NAME, AUTHORS): Define.
+    (main): Use them in use of version_etc.
+    * src/diff.c (PROGRAM_NAME, AUTHORS, main): Likewise.
+    * src/diff3.c (PROGRAM_NAME, AUTHORS, main): Likewise.
+    * src/sdiff.c (PROGRAM_NAME, AUTHORS, main): Likewise.
+    * src/system.h: Include "propername.h".
+
+commit b60091684ac415bcc6efaaedc42d31dedd378a75
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 08:58:54 2009 +0100
+
+    maint: no longer define *_FILENO constants
+    
+    * src/system.h (STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO):
+    Remove definitions.  Now guaranteed by gnulib.
+
+commit 3850429db6a8582ae5f1d43fb92dd29ee9af261e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 08:17:35 2009 +0100
+
+    maint: bug-diffutils@gnu.org is the new bug-reporting address
+    
+    * configure.ac (AC_INIT): Use bug-diffutils@..., not bug-gnu-utils
+    as the bug-reporting address.
+    * NEWS (Administrivia): Mention this.
+    * src/cmp.c (usage): Remove hard-coded address.
+    Instead, use gnulib's emit_bug_reporting_address function.
+    * src/diff.c (usage, option_help_msgid): Likewise.
+    * src/diff3.c (usage): Likewise.
+    * src/sdiff.c (usage): Likewise.
+
+commit 943b8a4383375c4eb197b4e984d5bca89790c5b0
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 07:38:03 2009 +0100
+
+    sdiff, diff3: exec diff, not $(bindir)/diff
+    
+    * src/Makefile.am (paths.h): Emit a definition of DEFAULT_DIFF_PROGRAM
+    that is simply "diff" (or whatever $(transform) would convert that to,
+    e.g., "gdiff").  This makes it so that tests can work without first
+    installing diff, and so that the binaries do not hard-code $(prefix).
+    * NEWS (Changes in behavior): Mention this.
+
+commit e454c1471aaf8b3e6bead2313838aefebfe97bca
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 14 10:31:41 2009 +0100
+
+    tests: add the first script; hook up gnulib-tests
+    
+    * configure.ac (AC_CONFIG_FILES): Add tests/Makefile and
+    gnulib-tests/Makefile.
+    * tests/help-version: New file, from coreutils.
+    * tests/test-lib.sh: Likewise.
+    * tests/Makefile.am: New file, from gzip.
+    * Makefile.am (SUBDIRS): Add tests and gnulib-tests.
+    * tests/t-local.sh: New, empty(for now) file.
+
+commit 8465a94ddbb1308d0a406280d87dc432f2005e6a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 13 18:01:24 2009 +0100
+
+    build: require gettext-0.17
+    
+    * configure.ac: Require gettext-0.17; it was released two years ago.
+
+commit 0fb1003a455d9955c683e8f08eec80880c51c1db
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 13 18:00:44 2009 +0100
+
+    build: correct gettext configure-time support
+    
+    * configure.ac: Use AM_GNU_GETTEXT([external], [need-ngettext]),
+    rather than AM_GNU_GETTEXT([external], [need-formatstring-macros]).
+    Reported by Martin Jacobs in
+    http://thread.gmane.org/gmane.comp.parsers.bison.bugs/3181
+
+commit 8c265a45e54a77003ce754fac893eaf292f7cd6d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 12 09:38:34 2009 +0100
+
+    build: generalize autoheader check
+    
+    * bootstrap: Look for AC_CONFIG_HEADER as well as AC_CONFIG_HEADERS.
+
+commit 8ec1458ae90b7da54a0d2d476fc70456bf3e7816
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 12 08:21:18 2009 +0100
+
+    maint: use a git submodule for gnulib
+    
+    * .gitmodules: New file, to track gnulib.
+    * gnulib: New file, created by running this:
+    git submodule add git://git.sv.gnu.org/gnulib.git gnulib
+
+commit 8356d902509c4df69fd5dcdb4fe112cb3d57dc95
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 12 08:19:53 2009 +0100
+
+    maint: tell git what it can ignore
+    
+    * .gitignore: Ignore generated files.
+
+commit 3504236b28c6d92653675b3d80361dafed381e0d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 22:24:33 2009 +0100
+
+    build: generate ChangeLog (from git logs) into distribution tarball
+    
+    * Makefile.am (dist-hook, gen-ChangeLog): New rules.
+    (gen_start_date): Define.
+    * bootstrap.conf (gnulib_modules): Add gitlog-to-changelog.
+
+commit 9bfafb33a6fad87d9b3fc41f0d8e97f9eac8f848
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 22:10:24 2009 +0100
+
+    admin: update all copyright notices to include the year 2009
+
+commit 5b6ba5593b9425a5843986ec97af75fd7c60c6e6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:56:27 2009 +0100
+
+    maint/sc: enable the m4 quote check
+    
+    * m4/vararrays.m4 (AC_C_VARARRAYS): Quote AC_DEFINE argument.
+    * cfg.mk (local-checks-to-skip): Add sc_m4_quote_check.
+
+commit 08d9ddae59b92de9568c8efb0e4c8cd495686df9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:28:53 2009 +0100
+
+    build: rely on gnulib's progname module
+    
+    * bootstrap.conf (gnulib_modules): Add progname.
+    * cfg.mk (local-checks-to-skip): Add sc_program_name.
+    * src/cmp.c: Include progname.h.
+    (program_name): Remove declaration.
+    (main): Call set_program_name.
+    * src/diff.c (main): Likewise.
+    * src/diff3.c (main): Likewise.
+    * src/sdiff.c (main): Likewise.
+    * src/diff.h (program_name): Remove extern declaration.
+
+commit 8cbaebf3532d23cf115ecfb733caa2c0536c070d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:22:38 2009 +0100
+
+    maint/sc: enable the space-TAB check
+    
+    * doc/diagmeet.note: Use no TABs.
+    * ms/config.sed: Use TAB-space, not space-TAB in [].
+    * cfg.mk (local-checks-to-skip): Remove sc_space_tab.
+
+commit 0363ae9f0f40e492f1460440cebc5c933b482b95
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:12:48 2009 +0100
+
+    build: rely on gnulib's mbrtowc module
+    
+    * bootstrap.conf (gnulib_modules): Add mbrtowc.
+    * src/side.c [!HAVE_MBRTOWC]: Remove now-useless code,
+    since gnulib guarantees working <wchar.h> and mbrtowc.
+    * cfg.mk (local-checks-to-skip): Remove sc_prohibit_HAVE_MBRTOWC.
+
+commit 2b13b2c76a1ca2119c7e79a2b1985c504ee7a5f4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:08:44 2009 +0100
+
+    maint/sc: enable check for unmarked diagnostics
+    
+    * cfg.mk (local-checks-to-skip): Remove sc_unmarked_diagnostics.
+    * src/dir.c (diff_dirs): Mark a diagnostic for translation.
+
+commit 242183ade35ec89c28710574f77037ce8fea84ad
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:07:08 2009 +0100
+
+    maint/sc: enable two config.h-checking rules
+    
+    * cfg.mk (local-checks-to-skip): Remove sc_require_config_h and
+    sc_require_config_h_first.
+    (config_h_header): Define.
+
+commit c9893c55535136d90433b4f9abbc5e7c1e6a303e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:01:38 2009 +0100
+
+    maint/sc: enable the po check
+    
+    * cfg.mk (local-checks-to-skip): Add sc_po_check.
+    * po/POTFILES.in: Update.
+
+commit d4bfdc5340505513d702ee7b6f9eb616868662c5
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:57:13 2009 +0100
+
+    maint/sc: use STREQ, not strcmp(a,b) == 0
+    
+    Run this command:
+      git grep -l 'strcmp *([^=]*== *0'|xargs \
+        perl -pi -e 's/\bstrcmp( *\(.*?\)) *== *0/STREQ$1/g'
+    and then add the new definition.
+    * src/system.h (STREQ): Define.
+    * src/cmp.c (main): Use STREQ, not strcmp.
+    * src/diff.c (main, compare_files): Likewise.
+    * src/diff3.c (main): Likewise.
+    * src/sdiff.c (expand_name): Likewise.
+    * cfg.mk (local-checks-to-skip): Add sc_prohibit_strcmp.
+
+commit c952719219ef62b8405edd68f47716ad29d7c41d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:50:55 2009 +0100
+
+    maint/sc: enforce "file system" spelling
+    
+    * src/system.h: Spell it as two words, not one.
+    * ms/config.sed: Likewise.
+    * cfg.mk (local-checks-to-skip): Remove sc_file_system.
+
+commit 036f253976af28b3112a7b246069f73345023ded
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:48:06 2009 +0100
+
+    maint/sc: enable check for CVS keyword expansion
+    
+    * doc/diff.texi: Remove $Id$.
+    * cfg.mk (local-checks-to-skip): Remove sc_prohibit_cvs_keyword.
+
+commit e5b61431a50c0cf303ec586d139e5e4b95767abe
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:44:10 2009 +0100
+
+    maint: record previous version
+    
+    * .prev-version: New file.
+
+commit 21ebf6648ef306f055004f4411331417980d817c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:43:53 2009 +0100
+
+    maint/sc: enable check for duplicate "the"; fix one
+    
+    * NEWS: s/the the/the/.
+    Adjust style to fit what some of the hooks and release tools expect.
+    * cfg.mk (local-checks-to-skip): Remove sc_the_the.
+    (old_NEWS_hash): Update.
+
+commit f54288e8ee642ba16c57abd2252fad07625794e0
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 19:54:28 2009 +0100
+
+    maint/sc: remove cast of xmalloc return value
+    
+    * lib/prepargs.c (prepend_default_options): Remove useless cast.
+    * cfg.mk (local-checks-to-skip): Remove sc_cast_of_x_alloc_return_value.
+
+commit 90ac0e3b3bf7c069c0559c650beb5a0afa4b7614
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 19:41:53 2009 +0100
+
+    maint: rename ChangeLog to ChangeLog-2008
+    
+    * ChangeLog-2008: Rename from ChangeLog.
+    * Makefile.am (EXTRA_DIST): Add ChangeLog-2008.
+    * .gitignore: Ignore ChangeLog.
+
+commit cb0791d7a466db7406b040a2670cbb27dfc184b1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 19:36:10 2009 +0100
+
+    maint/sc: remove useless if-before-free tests
+    
+    * src/diff.c (compare-files): Remove useless if stmts.
+    * src/dir.c (diff_dirs): Likewise.
+    * cfg.mk (local-checks-to-skip): Remove sc_avoid_if_before_free.
+
+commit 8075840b3938a05d7dc931adcb6d0ca9e90d432d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 15:18:13 2009 +0100
+
+    maint: require newer automake, new non-major version string, dist-xz
+    
+    * configure.ac: Drop -cvs suffix.  Switch to git-based format.
+    Distribute xz-compressed tarballs, too.
+    Require automake-1.11.
+    Enable automake's --enable-silent-rules option.
+
+commit a9a19e94fbb30fe57846bf94d03d61f8b84f9f9e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 15:13:54 2009 +0100
+
+    build: update build/release infrastructure
+    
+    * bootstrap: Update from gnulib.
+    * bootstrap.conf (gnulib-modules): Add do-release-commit-and-tag,
+    git-version-gen, gnu-make, gnu-web-doc-update, gnumakefile, gnupload,
+    maintainer-makefile, update-copyright.
+    * gnulib-tests/Makefile.am: New file.
+    * cfg.mk: New file.
+    (local-checks-to-skip): List currently-failing tests,
+    so that "syntax-check" passes initially.
+    (manual_title): Define.
+
+commit 8fd1173dd50ff556a19d046efee0a5bbf6aaf777
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 31 00:45:01 2008 +0000
+
+    * doc/diff.texi: Update Back-Cover text to reflect new GNU wording.
+
+commit f1a0d330653ed34da99313c510fbc6ee7844b523
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 17:49:46 2008 +0000
+
+    * src/side.c [!HAVE_MBRTOWC]: Supply defns for mbstate_t and mbrtowc.
+    
+    Problem reported by Bruno Haible.
+
+commit c3b0f9e45b0660716286fc561f38abdd1019c239
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 00:02:11 2008 +0000
+
+    * src/side.c (print_half_line): Don't convert to unsigned char
+    
+    unnecessarily.
+
+commit 8983b8d9040d3b909e8a7aeda9188affa1585014
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 23 23:56:30 2008 +0000
+
+    Don't mishandle multibyte characters in side-by-side format.
+    
+    Problem reported by Erik Karlsson in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2008-01/msg00030.html>.
+    * bootstrap.conf (gnulib_modules): Add wcwidth.
+    * src/side.c: Include <wchar.h>.
+    (print_half_line): Compute number of bytes and print widths of
+    multibyte characters.  Inspired by an alternative solution from
+    Bruno Haible in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2008-01/msg00032.html>.
+
+commit e1820a76c057c2c7c5f46f51c6fc37dae8c423c1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 5 07:24:14 2007 +0000
+
+    * NEWS: New diff option --suppress-blank-empty (no longer -u default).
+    
+    * doc/diff.texi (Detailed Unified): Trailing spaces are no longer
+    omitted.
+    (Trailing Blanks): New section.
+    (diff Options) Mention new option.
+    * src/diff.h (suppress_blank_entry): New decl.
+    * src/context.c (pr_unidiff_hunk): Support --suppress-blank-empty.
+    * src/util.c (print_1_line): Likewise.
+    * src/diff.c (longopts, main, option_help_msgid): Likewise.
+    (SUPPRESS_BLANK_EMPTY_OPTION): New constant.
+
+commit d4897fbc006f1c7ff2c1b825fa86c299c46472c8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 5 07:07:22 2007 +0000
+
+    * configure.ac: Invoke gl_USE_SYSTEM_EXTENSIONS after gl_EARLY,
+    
+    since gnulib now requires this order.
+
+commit 99c5b6631d8e766cca9ec5595ae552ec34a58c00
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 5 07:01:49 2007 +0000
+
+    * bootstrap: Import from gnulib.
+
+commit 9c6f0755416965dc426cc2f60c6635f04531e35a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 17 23:37:27 2007 +0000
+
+    Fix typo in previous change; Bruno wrote the code.
+
+commit 0cb3c7ffeff111a4784185c0c791b92dc4ad2d61
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 17 23:35:48 2007 +0000
+
+    Break out diffseq.h into a separate file, so that gettext can use
+    this code.  Idea from Bruno Haible.
+    * bootstrap.conf (gnulib_modules): Add diffseq.
+    * src/analyze.c (xvec, yvec, fdiag, bdiag, too_expensive, SNAKE_LIMIT):
+    (struct partition, diag, compareseq): Remove; now in diffseq.h.
+    (ELEMENT, EQUAL, OFFSET, EXTRA_CONTEXT_FIELDS, NOTE_DELETE, NOTE_INSERT):
+    (USE_HEURISTIC): New macros.
+    Include "diffseq.h".
+    (diff_2_files): Rewrite to use new diffseq.h interface.
+
+commit 53aeb341d52b8d56cd5080d146330a6cb114d4ba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 17 23:18:56 2007 +0000
+
+    * bootstrap: Import from gnulib.
+
+commit e78fa511978bacb0948eb333a815d66b14bc0782
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Aug 15 19:33:36 2007 +0000
+
+    * doc/diff.texi (Copying This Manual): Adjust to new fdl.texi layout.
+
+commit 28c227c281a947a7ebac93f2784d9f7a0dac3ffc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Aug 15 19:32:22 2007 +0000
+
+    * src/diff.c (compare_files): Use last_component rather than base_name,
+    adjusting to gnulib API change.  This avoids a memory leak.
+    * src/sdiff.c (expand_name): Likewise.
+    * src/util.c (dir_file_pathname): Likewise.
+
+commit 4805ca767a3c9b20deede49b2e4b294e58a28325
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 19 18:26:38 2007 +0000
+
+    * doc/diff.texi (White Space): Note that newline always ends a line,
+    so -w doesn't ignore newline-related changes.  Problem reported by
+    David Kastrup.
+
+commit 7e7a52f33be97ba6ae5ffcca4c504f243ecc12eb
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 12:35:21 2009 +0100
+
+    remove many files
+    
+    Many are now obtained via bootstrap from gnulib.
+    Others (ms/) were not being maintained.
+
+commit 43e4846f1153b7fc199a46c29f5b73c1cff49757
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 19 17:45:29 2007 +0000
+
+    * COPYING: New file.
+    * AUTHORS: Update from GPLv2 to GPLv3.
+    * Makefile.am: Likewise.
+    * NEWS: Likewise.
+    * README: Likewise.
+    * README-hacking: Likewise.
+    * bootstrap: Likewise.
+    * bootstrap.conf: Likewise.
+    * configure.ac: Likewise.
+    * exgettext: Likewise.
+    * doc/Makefile.am: Likewise.
+    * lib/Makefile.am: Likewise.
+    * lib/cmpbuf.c: Likewise.
+    * lib/cmpbuf.h: Likewise.
+    * lib/prepargs.c: Likewise.
+    * m4/vararrays.m4: Likewise.
+    * man/Makefile.am: Likewise.
+    * ms/Makefile.am: Likewise.
+    * ms/README: Likewise.
+    * ms/config.bat: Likewise.
+    * ms/config.sed: Likewise.
+    * ms/config.site: Likewise.
+    * po/POTFILES.in: Likewise.
+    * src/Makefile.am: Likewise.
+    * src/analyze.c: Likewise.
+    * src/cmp.c: Likewise.
+    * src/context.c: Likewise.
+    * src/diff.c: Likewise.
+    * src/diff.h: Likewise.
+    * src/diff3.c: Likewise.
+    * src/dir.c: Likewise.
+    * src/ed.c: Likewise.
+    * src/io.c: Likewise.
+    * src/normal.c: Likewise.
+    * src/sdiff.c: Likewise.
+    * src/system.h: Likewise.
+    * src/util.c: Likewise.
+
+commit 4e45d1d3241f2dbe27d1d434b5e44077457528d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 19 17:19:39 2007 +0000
+
+    * src/ifdef.c: Fix typo: "GNU DIFF General Public License" should be
+    "GNU General Public License".  Reported by Erich Guenther.
+    * src/side.c: Likewise.
+
+commit 2e5425cc4d56407e83e931bcff395d5813ef353b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 18 22:57:12 2007 +0000
+
+    (print_context_label): Use TYPE_IS_INTEGER macro rather than rolling
+    it ourselves.
+
+commit 7f61a0561421a669321c382d79d8e83a08aad21f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 18 22:45:24 2007 +0000
+
+    * bootstrap.conf (gnulib_modules): Add inttypes.
+
+commit 2da851745e00e862d7afa4dda21276fc859d5c7f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 18 22:23:18 2007 +0000
+
+    * src/context.c (print_context_label): Don't assume that time_t
+    fits in long int, since it doesn't in FreeBSD/arm.  Problem
+    reported by Xin Li in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2007-06/msg00091.html>.
+
+commit b8c8ac122f2f060c9998d20c94d71883bd3435d7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 6 23:40:16 2007 +0000
+
+    * NEWS:  Mention new sdiff aliases 1 and 2 for l and r.
+    * doc/diff.texi (Merge Commands): Likewise.
+    * src/sdiff.c (give_help): Give help for them.
+    (edit): Support them.
+
+commit cbadd508f38bca085f94fa704b551fdca9097a6f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Apr 12 00:15:15 2007 +0000
+
+    * doc/diff.texi (Detailed diff3 Normal): "range is a singleton" ->
+    "there is only one line", for clarity.  Suggested by Jerry Peek.
+
+commit f9179e0514ce957641d6ba61225e9275d0f74c03
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 4 22:11:27 2007 +0000
+
+    * TODO: Mention possible sdiff improvement.
+
+commit c7f95e3605303a49dec2dc5a4f96b5b1c7c87518
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 4 22:08:14 2007 +0000
+
+    * bootstrap: Sync from gnulib.
+    * src/cmp.c: Don't include exit.h; no longer needed.
+    * src/diff.c: Likewise.
+    * src/sdiff.c: Likewise.
+    * src/dir.c: Don't include strcase.h; no longer needed.
+    * README-alpha: Remove, replacing with:
+    * README-hacking: New file, taken from coreutils with some changes.
+    The rename is required by the change to 'bootstrap'.
+
+commit 2f9d531901f2126e6157aed6d23df18d3509b308
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 15 09:25:48 2006 +0000
+
+    * src/analyze.c (build_reverse_script): Fix typo in comment.
+    Problem and fix reported by Daniel Hipschman.
+
+commit 2a324549cee6cb97de866694218354186922ac9a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 14 22:53:59 2006 +0000
+
+    * src/sdiff.c (sigprocmask): Don't dump core if O is null.
+
+commit 1795be71fb9db24aaa5d3ef2fd71f0f952ccb72f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 14 20:22:12 2006 +0000
+
+    Don't assume SIGPIPE exists, and that sigblock and sigsetmask
+    exist if sigprocmask does not.  Problem reported by Paul Edwards
+    for MVS 3.8.
+    * configure.ac (sigblock): Check whether this function is
+    available, if sigprocmask is not.
+    * src/sdiff.c (sigs): Omit SIGPIPE if it's not defined.
+    Put SIGINT last; all uses changed.
+    (handler_index_of_SIGPIPE): Omit if SIGPIPE is not defined.
+    (sigblock, sigsetmask) [!HAVE_SIGBLOCK]: New macros.
+
+commit 6bd6999fed54d8c9e1f95308304141663202db73
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 5 00:57:34 2006 +0000
+
+    * src/sdiff.c (sigprocmask) [! HAVE_SIGPROCMASK]: Cast 2nd arg to
+    sigset_t *, since it might be a literal 0.  Problem reported by
+    Paul Edwards for MVS 3.8.
+
+commit 10892a2dccbd79676e1da06801006e35e05e0830
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 23:02:32 2006 +0000
+
+    * NEWS: diff -u no longer outputs trailing white space unless the
+    input data has it.
+
+commit 2daf7bfa36f4f44692330e1102ebe004198bbc0f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 22:57:29 2006 +0000
+
+    Modernize bootstrap procedure to match current gnulib.
+    * bootstrap: Sync with coreutils bootstrap, except check that
+    the directory build-aux exists before trying to copy to it.
+    * bootstrap.conf: New file.
+    (gnulib_modules): Add config-h, dup2, extensions, fcntl, fdl,
+    stat-macros, unistd.
+    * configure.ac: Invoke gl_EARLY and gl_INIT rather than
+    GNULIB_AUTOCONF_SNIPPET.
+    (AC_CONFIG_HEADER): Rename config.h to lib/config.h.
+    (AC_CHECK_HEADERS_ONCE): Don't check for fcntl.h, locale.h,
+    sys/file.h, unistd.h.  We now use the fcntl and unistd modules,
+    and locale.h can be assumed for any C89 compiler.
+    (DIFFUTILS_PREREQUISITES): Remove.  No longer needed now that
+    we use the stdint module.
+    (AC_CHECK_FUNCS_ONCE): Remove dup2, which is no longer needed
+    now that we use the dup2 module.
+    (AM_GNU_GETTEXT): Use need-formatstring-macros, and ...
+    (AM_GNU_GETTEXT_VERSION): specify version 0.15 instead of 0.14.5,
+    to be consistent with coreutils.
+    * lib/Makefile.am (noinst_LIBRARIES):
+    (lib_SOURCES, libdiffutils_a_LIBADD):
+    (libdiffutils_a_DEPENDENCIES, BUILT_SOURCES, EXTRA_DIST):
+    (MOSTLYCLEANFILES): Remove; now computed automatically.
+    (noinst_HEADERS, libdiffutils_a_SOURCES): Just append
+    our special files now.
+    * lib/cmpbuf.c: Include config.h unconditionally, since we
+    no longer define HAVE_CONFIG_H.
+    * lib/prepargs.c: Likewise.
+    * src/Makefile.am (LDADD): Use $(LIBINTL), not @LIBINTL@.
+    (diff_LDADD): Use $(LIB_CLOCK_GETTIME), not @LIB_CLOCK_GETTIME@.
+    * src/dir.c (dir_read): Use _D_EXACT_NAMLEN, not NAMELEN.
+    * src/system.h (volatile): Remove, since we assume C89 or better.
+    Include stat-macros.h.
+    (S_IRWXU, S_IRWXG, S_IRWXO, S_IRUSR, S_IWUSR):
+    Remove, since we now use stat-macros.h.
+    (SEEK_SET, SEEK_CUR): Remove, since we assume C89 or better.
+    Include unistd.h unconditionally, since we use unistd.
+    Likewise for fcntl.h.
+    (dup2): Remove, since we now use dup2.
+    (O_RDONLY, O_RWDR, O_BINARY): Remove, since we now use
+    fcntl.
+    Include dirent.h unconditionally.
+    (NAMLEN): Remove, replacing with....
+    (_D_EXACT_NAMLEN): New macro.
+    Include inttypes.h unconditionally.
+    (PTRDIFF_MAX, SIZE_MAX, UINTMAX_MAX, strtoumax): Remove, since
+    we now use inttypes.
+    Include locale.h unconditionally.
+    (setlocale): Remove, since we now assume locale.h.
+
+commit a204b37fb2d871df551d9bf6fb722d8f269a0754
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 22:57:09 2006 +0000
+
+    * doc/diff.texi (Detailed Unified): Don't output trailing white
+    space unless the input data has it.
+    * src/context.c (pr_unidiff_hunk): Likewise.
+
+commit 19397f6b83f488de0e54c7ea4972e86515677752
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 14:04:57 2006 +0000
+
+    * src/context.c (print_context_function): Do not print
+    trailing white space in a context header.
+
+commit 32625c50259a94e480ab8184a9b6af674e854076
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jul 26 06:20:59 2006 +0000
+
+    (cmp Options): -l also outputs the EOF message.
+
+commit 67d3afe06ae68b181de2be258099c62400bc3b81
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 9 22:57:20 2006 +0000
+
+    * src/cmp.c (cmp): The previous fix wasn't quite right either, as
+    it mishandled 'cmp A B >/dev/null' when A is shorter than B and
+    differs before A's end-of-file, by outputting a bogus EOF message.
+    Also, it was inefficient if A and B were large.
+
+commit f0098c7f4f1c88f7f24af9b3d0ac56bee63ace82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 8 07:21:34 2006 +0000
+
+    Use Jim's wording in ChangeLog entry, mostly.
+
+commit f74bf8344446af160009ddd6f9a1bfde43092adc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 8 07:17:54 2006 +0000
+
+    Correct authorship of previous patch.
+
+commit 69aaf732ab2fbed74b3b19d9e3e0adc6b0ff372e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 8 01:41:04 2006 +0000
+
+    * src/cmp.c (cmp): Fix bug introduced in 2006-03-09 change.
+    For example, "cmp <(echo b) <(echo a) > /dev/null" incorrectly
+    succeeded.  Problem reported by Jim Meyering.
+
+commit 96e1fbe4c727ac843a4760859148378c22d52b66
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 08:16:19 2006 +0000
+
+    * src/context.c (pr_context_hunk, pr_unidiff_hunk):
+    Prefer fputs or fputc to fprintf, since it's a tad more efficient
+    with unlocked-IO on glibc.  Long ago we avoided fputs to
+    work around an ancient SunOS bug, but that's no longer relevant.
+    * src/diff3.c (output_diff3, dotlines, undotlines):
+    (output_diff3_edscript, output_diff3_merge): Likewise.
+    This also avoids a gcc -Wformat-security warning reported
+    by Jim Meyering.
+    * src/ed.c (print_ed_hunk, print_forward_ed_hunk, print_rcs_hunk):
+    Likewise.
+    * src/normal.c (print_normal_hunk): Likewise.
+
+commit e0842123160e781efcc0ddbf854dae53b7f674e2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 04:07:58 2006 +0000
+
+    find_identical_ends and doc/diff.texi fixes
+
+commit 58d0483b621792959a485876aee05d799b6470de
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 04:07:41 2006 +0000
+
+    (find_identical_ends): Fix huge performance bug that I
+    introduced in the 2001-11-25 change: the code to remove the
+    identical suffix also looked at the trailing sentinel, which meant
+    the common suffix length was always incorrectly calculated to be
+    zero.  Problem and fix reported by Daniel Hipschman.  Instead of
+    his fix, revert to the (nearly-equivalent) pre-2001 code.
+
+commit bcfeb9cb38452c38234b2b783fff51c0ba529a12
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 04:06:50 2006 +0000
+
+    Switch from GFDL 1.1 to 1.2.
+
+commit 4c0c7c59d6728975d7b18dd3ca3f76c8cecd8ce8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 13 19:11:17 2006 +0000
+
+    * src/system.h (PARAMS, PROTOTYPES): Remove; no longer needed.
+    (IF_LINT): New macro, to pacify GCC.
+    * src/analyze.c (diag, compareseq): Use IF_LINT.
+    * src/cmp.c (cmp): Likewise.
+    * src/diff3.c (process_diff): Likewise.  Also, prefer NULL to 0.
+    * src/ifdef.c (do_printf_spec, scan_char_literal): Likewise.
+    * src/sdiff.c (edit): Likewise.
+
+commit a3dd61b474f62af16f8638679c8ade0ab34978cf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Mar 9 20:57:25 2006 +0000
+
+    Update code comment to match previous patch.
+
+commit dab9c7e59b283db312c08ac765ac41e2338cdaf7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Mar 9 20:54:39 2006 +0000
+
+    (main): Avoid an unnecessary system call introduced in previous patch.
+
+commit 708ba31420d0bf4dfaa37fafa566727312ecb966
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Mar 9 20:38:11 2006 +0000
+
+    * src/cmp.c (type_no_stdout): New constant.
+    (main): Use it to avoid bug when the "EOF on foo" message is
+    generated and stdout is /dev/null.
+
+commit 57253a174c8645f56d1dbe7032b8c0128ec4a68c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:33:42 2006 +0000
+
+    Handle gettext.m4 like glibc21.m4.  Don't remove po/en.po.
+
+commit f5c76109838cdf542958a88020bd34e2f54f97a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:23:55 2006 +0000
+
+    Update FSF address.
+
+commit e781e2df7cbe7794165e267a627417c906e4adbd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:15:26 2006 +0000
+
+    Describe CVS access better, using the README-alpha from GNU tar.
+
+commit 91b8605708cf2d7c49679a46a80b4039167da2cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:08:23 2006 +0000
+
+    * src/cmp.c: Don't include <setmode.h>.
+    (specify_ignore_initial): Reword to avoid gcc -W warnings.
+    (main): Use freopen instead of setmode, since freopen is in POSIX.
+    * src/context.c: Revert most 2004-09-01 changes.  Then:
+    (TIMESPEC_NS): Remove.  All uses replaced by
+    get_stat_mtime_ns.
+    Include stat-time.h, strftime.h.
+    (nstrtime): Remove decl.
+    * src/diff.c: Revert most 2004-09-01 changes.  Then:
+    Don't include <posixver.h>, <quotesys.h>, <setmode.h>.
+    Include <sh-quote.h>, <stat-time.h>, <timespec.h>.
+    All uses of quotesys replaced by sh-quote.
+    (main, compare_files):
+    Use freopen instead of setmode, since freopen is in POSIX.
+    (main): Don't complain about "diff -NUM'.
+    (main, set_mtime_to_now):
+    Adjust to stat-time.h macros when accessing nanoseconds.
+    * src/diff3.c: Include sh-quote.h rather than quotesys.  All uses
+    changed.
+    * src/dir.c (dir_read): excluded_filename renamed to
+    excluded_file_name.
+    * src/io.c: Don't include <setmode.h>.
+    (sip, read_files): Remove binary file stuff, leaving a FIXME behind.
+    A DOS expert needs to look at this.
+    * src/diff.c: Include sh-quote.h rather than quotesys.h.
+    All uses changed.
+    * src/system.h: Include verify.h.
+    (verify): Remove.  All uses changed to verify.h version.
+    Include <intprops.h>.
+    (TYPE_SIGNED, TYPE_MINIMUM, TYPE_MAXIMUM): Remove.  Now uses
+    intprops.h versions.
+    (O_BINARY): New defns, taken from coreutils.
+    * src/util.c: Include sh-quote.h rather than quotesys.h.
+    All uses changed.
+
+commit 174ab8396535806d77708990568f9817d11d5bb3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 1 15:06:09 2004 +0000
+
+    (recursive, new_file, unidirectional_new_file,
+    report_identical_files): Move into struct diffopt.  All uses changed.
+    (exclude_options, compare_files, specify_style, check_stdout):
+    New arg OPT.  All uses changed.
+    (GDIFF_MAIN): Remove.  All uses removed.
+    (function_regexp_list, ignore_regexp_list): No longer static; now
+    locals in 'main'.
+    (main): Set opt.function_regexp, opt.ignore_regexp if using regexps;
+    all other code now tests these pointers rather than inspecting fastmap
+    internals.
+    New local OPT to hold former statics; initialize it.
+    (init_regexp_list): New function, used by main.
+    (summarize_regexp_list): Now returns struct re_pattern_buffer *, and
+    assumes reglist->regexps is not NULL.  All uses changed.
+
+commit 203069b84a21bd917b6d971705fcf0480579e718
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 1 14:50:42 2004 +0000
+
+    (find_function_last_search): Move into struct diffopt.
+    All uses changed.
+    (pr_context_label, pr_context_header,
+    print_context_script, find_function, find_hunk, mark_ignorable,
+    pr_context_hunk, pr_unidiff_hunk): New arg OPT.  All uses changed.
+    (print_context_number_range,
+    print_unidiff_number_range): New arg OUT.  All uses changed.
+
+commit 3b8636727556fc88f4517e57bb65ef60ea78c8e9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 1 14:37:55 2004 +0000
+
+    Add AC_C_INLINE.
+
+commit 0d349232b335031c4ef8d8d07e2c712cf1f9ba3d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jul 21 08:58:38 2004 +0000
+
+    (print_ed_hunk): Optimize the case where an insert's
+    last line is a single-dot line.
+
+commit 61d0b7e9bd56a3999d0697a5fa2e87c4a2d170d2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jul 21 08:58:12 2004 +0000
+
+    Initial revision
+
+commit ce64bdaf0ec7aa164b1a36bbd9ec79124f08386f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 30 17:49:57 2004 +0000
+
+    Don't include <stdbool.h>, since setmode.h now does this.
+    Include setmode.h first, to catch interface errors.
+    Assume HAVE_SETMODE_DOS is defined.
+
+commit 4f8fa6adc36c096088803a9bf2654ce1a4f8b5a8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 30 17:46:07 2004 +0000
+
+    Include stdbool.h.
+
+commit 316aba17275e68e7be4d5c16ee26ca1f61a1068c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 26 18:04:04 2004 +0000
+
+    Don't remove po/en.po.
+
+commit 9080cf851154c54bef83895133f11ffcdff837a3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 22:39:49 2004 +0000
+
+    Don't generate a temporary file, as this runs afoul of "make distcheck"
+    which operates with read-only directories.
+
+commit 6a7b42e65a6f57eca1747f2571fb871d90c86431
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:56:38 2004 +0000
+
+    (EXTRA_DIST): Add bootstrap.
+    Remove config/config.rpath as it is deduced automatically these days.
+
+commit 4a1de90b3c191e6854a5f91360b50d5f9ef8e859
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:56:18 2004 +0000
+
+    Version 2.8.7.
+
+commit a76094697e04ec706d37cc5a8b7ad73048fecfef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:55:43 2004 +0000
+
+    (AM_GNU_GETTEXT_VERSION): Add.
+    (XGETTEXT): Restore from pre-2004-04-12 version.  This fixes
+    a bug that lost many msgids in doc/diffutils.pot.
+    (AC_INIT): Version 2.8.7.
+
+commit 45cc4e0358a8dc81675edf3c6c17ad0386bd4627
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:47:34 2004 +0000
+
+    Initial revision
+
+commit fefbcf76e6e9097c97b73c387db27b852c57909e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 23:07:15 2004 +0000
+
+    (AC_CONFIG_COMMANDS): Remove.
+
+commit 74bdeeafed854701b934062d66ac2363016b5f1e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 20:45:50 2004 +0000
+
+    (EXTRA_DIST): Add setmode.h.
+
+commit 2e225054695624e563061098b6ca6e03dc619d47
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 20:30:57 2004 +0000
+
+    Use inttostr module, so we needn't worry about specifying it ourself.
+
+commit a74be8d413ed08f1fd2e73499f73e453be2f6e39
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    * configure.ac: Quote various arguments better.
+    (AC_CONFIG_MACRO_DIR): Add call, specifying "m4".
+    (AC_CONFIG_HEADER): Replaces AM_CONFIG_HEADER.
+    (gl_USE_SYSTEM_EXTENSIONS): Replaces AC_GNU_SOURCE.
+    (AC_ISC_POSIX): Remove; nobody ports to ancient ISC any more.
+    (AC_PROG_CPP, AC_PROG_INSTALL, AC_C_INLINE,
+    AC_HEADER_STDBOOL, AC_HEADER_STDC, AM_GNU_GETTEXT, XGETTEXT,
+    AC_HEADER_STAT, AC_FUNC_VPRINTF, jm_FUNC_GLIBC_UNLOCKED_IO,
+    jm_FUNC_GNU_STRFTIME, jm_FUNC_MALLOC, jm_FUNC_REALLOC,
+    jm_PREREQ_C_STACK, jm_PREREQ_ERROR, jm_PREREQ_HARD_LOCALE,
+    jm_PREREQ_QUOTEARG, jm_PREREQ_REGEX, AC_FUNC_FNMATCH_GNU, jm_AC_DOS):
+    Remove; not needed here, as our files don't use them directly
+    or we rely on gnulib modules.
+    (AC_C_CONST): Remove; we assume C89 now.
+    (AC_CHECK_HEADERS): Remove libintl.h, limits.h, stdlib.h, string.h,
+    time.h.
+    (AC_CHECK_TYPE): Remove ptrdiff_t, ssize_t.
+    (AC_CHECK_FUNCS): Remove diraccess, strchr, strerror, tmpnam).
+    (AC_REPLACE_FUNCS): Remove memchr, mkstemp, strcasecmp.
+    (GNULIB_AUTOCONF_SNIPPET): Add call.  This replaces much of
+    the above.
+    (AC_CONFIG_FILES): Remove lib/posix/Makefile.
+
+commit 2ea441f7e2238c3cb0b31bf1e8f9cf308f9d4c21
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Initial revision
+
+commit b3f6204729da36e1b91222a3a37ae1b5b6183db4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Move copyright notice to end.  Defer to "configure
+    --help" for special "configure" options.  Suggest latest libiconv.      Update version numbers of Autoconf etc. to current.
+
+commit 477cd3074a36e5f5f6ea9d986f0772cf3f27cfbe
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Add news for 2.8.4, 2.8.6.
+
+commit 3f0830fef57d62a48bbfdaa868698038b7b085f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+    (lines_differ): Don't convert char * to unsigned char *;
+    just leave pointers as char *.  This lessens the number of
+    potentially-dangerous casts.
+
+commit 43adfd44c5edd962d042abb1976ad0710748d7d5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (S_IRWXU, S_IRWXG, S_IRWXO): Define if not defined.
+    (S_IXUSR, S_IXGRP, S_IXOTH): Remove.
+    Include <time.h> unconditionally, since we can assume C89 now.
+    Likewise for <stdlib.h>, <string.h>.
+    (getenv, EXIT_SUCCESS, EXIT_FAILURE, SSIZE_MAX, strchr, strrchr,
+    memcmp, memcpy): Remove decl; no longer needed.
+    (strcasecoll, strcasecmp): Define if not built in.
+    (CTYPE_DOMAIN, ISPRINT, ISSPACE, TOLOWER, _tolower, errno): Remove;
+    we now assume C89 or better.  All uses changed.
+    Include <stdbool.h> unconditionally now, since gnulib supports it
+    if the C compiler doesn't.  All boolean uses of 0 and 1 now
+    changed to false and true.
+    (lin_is_printable_as_long_int): Renamed from lin_is_printable_as_long.
+
+commit 5af1582ab885a37805191cb2a76026eb67560b1e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    minor cleanups for bool, etc
+
+commit c151c4194b162bcee131693aa82359da2b196650
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (usage): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    Adjust to latest version_etc calling conventions.
+    Include <unlocked-io.h>, <exit.h>.
+    (check_child_status): Renamed from ck_editor_status, and
+    accept a new arg MAX_OK_STATUS.  All callers changed.
+    Handle status 126/127 as per POSIX.
+    (edit): Likewise.
+    (main): Likewise.  Fix getopt typo: -E wasn't supported.
+
+commit 4cdc5fbf2b6e1dd5a38ea4b7d83e3a085ea5c549
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+    (find_and_hash_each_line): Don't convert char *
+    to unsigned char *; just leave pointers as char *.  This
+    lessens the number of potentially-dangerous casts.
+
+commit fbe4a6f698f834461143df0b2868e6545ee45702
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (next_line): Remove; replace with...
+    (next_line0, next_line1): New vars.
+    (print_ifdef_script, print_ifdef_hunk):
+    Use them to fix line-number computation bug.
+
+commit b4a6ac7a09084fc340be083ad45fb8c40c959545
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    int -> long int
+
+commit ede07ddb4d1ca04aab16088671cfae01752e83b9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Include <strcase.h>.
+    (failed_locale_specific_sorting): Renamed from failed_strcoll.
+    All uses changed.
+    (compare_names): Don't invoke strcasecmp first thing when
+    ignore_file_name_case; if locale_specific_sorting, we should
+    just use that.
+
+commit d5b0491a3196315c14597f5542234a57472dd547
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (usage): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    Adjust to latest version_etc calling conventions.
+    Include unlocked-io.h.
+    (strip_trailing_cr): New var.
+    (STRIP_TRAILING_CR_OPTION): New enum.
+    (longopts, main, option_help_msgid, read_diff):
+    Add --strip-trailing-cr support.
+    (read_diff): Exit with status 126 (not 127) if errno != ENOENT
+    after failed execvp in child.  Report this in parent.
+
+commit 70a8b49b0fb78ea910a4e3fa1fc3846227d7fc42
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Include regex.h, unlocked-io.h.
+    (struct file_data.changed): Now char *, not bool *, to save
+    space on hosts where bool takes more space than char.
+    All uses changed.
+
+commit 0b52cc41fc62fec5c6b1920930a20bf26382dfcd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+    (option_help_msgid): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    Adjust to latest version_etc calling conventions.
+    Include <exit.h>.
+    (binary): Define to true if not declared.
+    (longopts): Set tabsize flag to 1.
+    (main): Don't output nanoseconds if platform lacks them.
+    Don't treat files as binary if !binary.
+    (set_mtime_to_now): Use 0, not NULL.
+    (compare_files): Mark files as nonexistent if it looks like
+    'patch' created inaccessible regular empty files to denote
+    nonexistent backups.  Don't compare such files.
+    Clear st_* members of status of nonexistent file.
+    Remove now-unnecessary tests.
+
+commit fae8239911a876b179c0c57ace09f837aaa6541a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+
+commit 61d1ff8d5006c448ed7f257b021e48c5c2afac42
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Sort includes.  Include <exit.h>, <unlocked-io.h>.
+    (specify_comparison_type): Don't report an error if the comparison
+    type has already been specified the same way as this one.
+    (usage): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    (main): Adjust to latest version_etc calling conventions.
+
+commit 0ebd95fcbdec9f353f89378dad84e2cdb4e3c1fd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (SUBDIRS): Remove.
+    (EXTRA_DIST, noinst_HEADERS): Remove most entries.
+    (libdiffutils_a_SOURCES): Now just lib_SOURCES.
+    (lib_SOURCES): New macro.
+    (DISTCLEANFILES, MOSTLYCLEANFILES): Set to empty now.
+    (gnulib.mk): Include: this does most of the work eliminated
+    by the above changes.
+
+commit 59500c52b299db1bd589517dbc3b781cb576dcdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (set_binary_mode): Return true, not 1.
+
+commit 6fc04adf128379f0efac92966a52865fb5f87e29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (__attribute__): New macro.
+    (set_binary_mode): Define only if HAVE_SETMODE_DOS.
+    Otherwise define a dummy static char, as C89 requires
+    that we define something.
+
+commit 6243e2580a0a84026f75edb2a54edfc39d39825e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (dircategory): Change to "Text creation and
+    manipulation" from "GNU packages".
+    (Translations): New node.
+    (Overview): Improve quality of algorithm citations.
+    (Binary): -q doesn't exactly cause diff to assume files are binary.
+    (Normal): Place after Side by Side, since it's less important.
+    (Detailed Context, Detailed Unified, Detailed ed,
+    Detailed if-then-else, diff3 Hunks, Detailed diff3 Normal):
+    Place at end of menu.
+    (Detailed Unified): Mention that fractional timestamps are
+    omitted on hosts that don't support them.
+    Mention what happens when hunks contain just one line.
+    (Line Group Formats, Reject Names): Fix duplicate-word typos.
+    (Comparing Directories): Trailing white space and empty lines are
+    ignored in the -X file.
+    (diff Options): Add --strip-trailing-cr.
+    (Projects): gnu -> gvc@gnu.org.
+
+commit 16b4efacf9235515793fcc0a3e827a98219a80f9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 12 04:39:09 2004 +0000
+
+    (diag): Return void, not lin, since the return
+    value wasn't needed.  All callers changed.
+    (diag, diff_2_files):
+    Use 'true' and 'false' instead of '1' and '0', when appropriate.
+    (compareseq): Use lin const * local variables instead of lin *.
+    Don't bother checking diag's return value.
+    (shift_boundaries, build_reverse_script, build_script, diff_2_files):
+    Use char arrays, not bool arrays, since
+    sizeof (bool) might be greater than 1.
+
+commit 4ed49df5e498c76b610fc1cb86c5411efb65c090
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 8 00:03:44 2004 +0000
+
+    (Makefile.am): Don't use $<, as it doesn't work with Solaris make.
+
+commit da9e16ed92a74144ed0798aa6d7d4e2e6ad921c7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Feb 9 08:29:40 2004 +0000
+
+    (AC_FUNC_SETMODE_DOS): AC_LIBOBJ(setmode) if true.
+
+commit a6c2999cb2757182945881bc269110468be086ba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jan 12 20:52:38 2004 +0000
+
+    coreutils 5.2.0
+
+commit 55865b500d9c55b7395a89a968eed0c1583120c6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jul 28 00:57:07 2003 +0000
+
+    Use a single locale for both British and American English,
+    since we don't need to use '-ise' in Britain, says the OED.
+
+commit 74e3ee8f1939d6b2dc32410c38a103a8b906af1d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 15 03:57:20 2002 +0000
+
+    (diff3.$(OBJEXT), diff.$(OBJEXT), sdiff.$(OBJEXT)):
+    Rename from (misspelled) diff3.$(OBJECT), diff.$(OBJECT), sdiff.$(OBJECT).
+    Patch by Paul D. Smith in
+    <http://mail.gnu.org/pipermail/bug-gnu-utils/2002-October/003251.html>.
+    Bug reported by Chris Bainbridge.
+
+commit b6a7784af676924f577b305b5c15978f1e7847e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 14 04:40:20 2002 +0000
+
+    (MOSTLYCLEANFILES): Add paths.ht.
+    (paths.h): Send output to paths.ht first, and then rename to
+    paths.h at the end.  This avoids problems if the disk is full.
+    It also works around what appears to be a bug with GNU make -j
+    (3.79.1); see <http://bugs.gentoo.org/show_bug.cgi?id=8934>.
+
+commit 2b39a9397d67262ebee902483fb5bdbcfce5c2e6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 22 07:52:26 2002 +0000
+
+    (TYPE_SIGNED): Remove.
+    (INT_STRLEN_BOUND): Don't use TYPE_SIGNED; that way, the macro works
+    for either a type or an object.
+
+commit d8c6a49f1a250041d54b8551f904c91b7a2eec61
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 12 07:38:20 2002 +0000
+
+    (jm_FUNC_REALLOC): Define HAVE_REALLOC if realloc works.
+
+commit cf8a358fdf17330bd49ff8e1e0d0be74fba7e162
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 12 07:34:43 2002 +0000
+
+    (jm_FUNC_MALLOC): Define HAVE_MALLOC if malloc works.
+
+commit f7a75bc37a8d5a027f3c2a4519a4db42b5fab7d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Aug 7 09:10:36 2002 +0000
+
+    Snapshot before syncing with gnulib again.
+
+commit eb2b167bece3a06cdfea7d956796a89931e5813c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 4 11:15:53 2002 +0000
+
+    Switch to GPL.
+
+commit da7959d1e0cba81ac77d545a12c328d358f490f9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jul 1 14:19:20 2002 +0000
+
+    Include sys/time.h; from Volker Borchert.
+
+commit 6d38b808b9b4ab7d5d0685d6d21885af60c51038
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jun 28 07:00:15 2002 +0000
+
+    (AC_INIT): Version 2.8.4.
+
+commit a352f09806a8606b4bbec07048da6762ce7d9afa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jun 28 06:58:59 2002 +0000
+
+    (briefly_report): Don't say "Binary files differ", since one
+    of the files may not be a binary file.
+    Bug reported by Dan Jacobson.
+
+commit f8d4015e3620ad843e0a73649b2ba0cb91c2c5e5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jun 22 13:29:17 2002 +0000
+
+    (segv_handler, c_stack_action) [! defined SA_SIGINFO]:
+    Do not assume SA_SIGINFO behavior.
+    Bug reported by Jim Meyering on NetBSD 1.5.2.
+
+commit 932176da4ca083c0b07a60bd20d830b14a058a86
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:19:01 2002 +0000
+
+    Version 2.8.3.
+
+commit ee74fb1947e525b09250821aec95c0fdca5efae2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:15:20 2002 +0000
+
+    Add en_US.
+
+commit 5ac585d8c000be958b4c2a78f8c39d4aed769ee7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:03:37 2002 +0000
+
+    Translate "Torbjorn".
+
+commit 00ec5e4806c0645feb6c33c38e06bc58f32fcac2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:03:37 2002 +0000
+
+    Initial revision
+
+commit 886c533f81c3058448260622ab3bfbe494ce3978
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 06:45:46 2002 +0000
+
+    Include version-etc.h, not freesoft.h.
+    (copyright_notice): Remove.
+    (main): Use version_etc to print version.
+    (version_string): Remove decl.
+
+commit d6a560a408345cd86e74fe70b52aaff2dfef985f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 06:31:13 2002 +0000
+
+    Remove lib/freesoft.c.
+    Add lib/file-type.c, lib/version-etc.c, lib/xmalloc.c.
+
+commit 12e1995d935c1d981042eb5927bc7906f4addfdd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (version_string): Remove decl.
+
+commit e69f844815d144855bcb1e3d72f4aa7510d2ecd3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    Include version-etc.h, not freesoft.h.
+    (copyright_notice): Remove.
+    (main): Use version_etc to print version.
+
+commit b4b207d09d13f30957aa3febf82a9d0da06f5ad9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (cmp_SOURCES, diff3_SOURCES, sdiff_SOURCES, diff_SOURCES):
+    Remove version.c.
+    (MAINTAINERCLEANFILES, $(srcdir)/version.c): Remove.
+
+commit 4ead5e11465e00e3d5bdedaccb921abbb1354974
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (noinst_HEADERS): Remove freesoft.h.
+    Add version-etc.h.
+    (libdiffutils_a_SOURCES): Remove freesoft.c.  Add version-etc.c.
+
+commit b0ec6101bdde2c10f43c65da03539c878345892d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (version_etc): Remove package and version args.
+    (version_etc_copyright): Remove.
+
+commit cb95fdb5a348237bb84846202ce6d213f7d46327
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (version_etc): Remove package and version args.
+    (version_etc_copyright): Remove.
+    Do not include unlocked-io.h; no longer needed.
+    Include gettext.h rather than libinto.h.
+    (_): Define unconditionally.
+    (version_etc): Adjust wording to match current GNU coding standards.
+    Translate "(C)" if possible.
+
+commit 0c3f74704f4525d9a6e55b27c791688e312573c7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (Special Files): Document behavior of symlink loops.
+
+commit 588fadc48e9ab796859ac6d41928cbbc982465b1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:52:49 2002 +0000
+
+    (AC_INIT): Version 2.8.3.
+
+commit 54b2d5d20f17f17dbd7f3198fd7940573355623e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:52:49 2002 +0000
+
+    Update to automake 1.6.2.
+
+commit edd7dd52ff64c0bbb05198a7fb6cc8cd9b164ad4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 12 06:06:47 2002 +0000
+
+    (WIDE_CHAR_SUPPORT): New macro.  Use it uniformly instead of
+    (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H).  It also depends
+    on HAVE_BTOWC.
+
+commit 4b89533a437ec6309014174b534c28a9178a2777
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 12:13:01 2002 +0000
+
+    (readnum): Fix autoincrement typo.
+
+commit d327549393709d88696313ba55aece1c29861549
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:59:47 2002 +0000
+
+    Check for HAVE_SIGALTSTACK and HAVE_GETCONTEXT, too.
+
+commit faf225b9c68c5a42b6958f712336255fabfa1316
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:56:33 2002 +0000
+
+    Don't assume uintmax_t.  Check for getcontext and sigaltstack existence,
+    too.
+
+commit 536f11749bab2eee07d0e2c635ca9e6195663bee
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:22:20 2002 +0000
+
+    Don't invoke AC_FUNC_FNMATCH_GNU with an argument.
+
+commit 94bad85d38ad8570928cc6d609871a2de1c26e27
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:20:13 2002 +0000
+
+    Trim trailing white space.
+
+commit 65dbacedda1323bda3b04326110c08bed4756627
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:18:52 2002 +0000
+
+    Fix trailing white space.
+
+commit 1886715b4b613d1f049a298e6e0b808b49bc6845
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:15:03 2002 +0000
+
+    Translate (C).
+
+commit 1027af18b661bf6e24a9153dcfe5395db98351e9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (finish_output): Check for ENOEXEC.
+    (lines_differ, output_1_line): New option --tabsize=COLUMNS.
+    (analyze_hunk): If -b or -w is also specified, -B now considers
+    lines to be empty if they contain only white space.
+
+commit 4ddc54cbc5ad3e54dceaa5b53b83467a24ec2254
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    *** empty log message ***
+
+commit 0a49c9797c2f508e62fbd06541ea7664cafc7efc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (tab_from_to, print_half_line, print_1sdiff_line):
+    New option --tabsize=COLUMNS.
+
+commit d11594d81392ef8f68131fe9c6c846c106b22036
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+    (catchsig, signal_handler, initial_action): Signal handlers return void,
+    not RETSIGTYPE, since we no longer support K&R.
+    (TABSIZE_OPTION): New constant.
+    (longopts, usage, main): New option --tabsize=COLUMNS.
+    (cleanup): New arg signo.  All uses changed.
+    (ck_editor_status, main, edit): Don't worry about ENOEXEC.
+
+commit 22efb75195447a35bcdcd7c48b08edc679b55340
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    (find_and_hash_each_line): New option --tabsize=COLUMNS.
+
+commit 1572db90e55550ce98478386da6293db999c7991
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+    (skipwhite, readnum): New functions.
+    (process_diff_control): Use them.
+    (SKIPWHITE, READNUM): Remove.
+    (read_diff): Don't worry about errno == ENOEXEC.
+
+commit b4d2d2b865f4562f3c47114a7e750939802a805d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (TAB_WIDTH): Remove.
+    (tabsize): New decl.
+    (sdiff_half_width, sdiff_column2_offset): Now size_t rather than
+    unsigned int.
+
+commit 208896a9c327459761e27170ae0f293550981dbf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+    Include posixver.h.
+    (TABSIZE_OPTION): New constant.
+    (main): Allow widths up to SIZE_MAX.
+    (filetype): Move to lib/file-type.c and rename to file_type.
+    All uses changed.
+    (longopts, main, usage): New option --tabsize=COLUMNS.
+
+commit b2b34cb3be44f7e2f2a41aa890619b94cca85a78
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+
+commit 2aab82acbe56ab6fad747994b6ee7231dd3d6ce5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+
+commit a1ef5140b61e798296a87b60a0a0461e8989f462
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (noinst_HEADERS): Remove diff.h.
+    (DEFS): Remove.
+    (diff_sources): Add diff.h.
+    (MOSTLYCLEANFILES): New macro.
+    (cmp.$(OBJEXT) diff3.$(OBJECT) diff.$(OBJECT) sdiff.$(OBJECT)): Depend
+    on paths.h.
+    (paths.h): New rule.
+
+commit 5b713e8dd605e2c2b7ddc2629305009e3c755a38
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Add hu, pt_BR.
+
+commit 0d1e55b956643e0554d2fc4f075497e03b82a80d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (AC_HEADER_STDBOOL): Do not cast pointer to
+    bool in integer constant expression; C99 does not allow it.
+
+commit 70c7ef8c86d183076f9dcd80f3ddf41df8d97f25
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (jm_PREREQ_QUOTEARG): AC_MBSTATE_T -> AC_TYPE_MBSTATE_T.
+
+commit 6756cc93587506482ff6c85d4ee22cf6b3702b77
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Update to latest Autoconf CVS for AC_GNU_SOURCE
+    (renamed from AC__GNU_SOURCE).
+
+commit f4468d980da9386fd8866b038f98eaecf02d8513
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (jm_PREREQ_C_STACK): Do not AC_REQUIRE jm_AC_TYPE_UINTMAX_T.
+    Check for sys/resource.h, uccontext.h.
+    Check for decls of getcontext, sigaltstack.
+    Check for stack_t.
+
+commit aa5475b6b4e5d4e4b50c7c90c524b06b03ff9272
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include posixver.h.
+
+commit bf641a954266b8b01c44aec876777867efa49e9d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (struct patternlist.str): Size 1, not 0, as C89 requires this.
+    (NEW_PATTERN): Use offsetof, not sizeof, since str now has size 1.
+
+commit 229fb658714487a3e8de3535274dadc86bb4cde4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (AC_INIT): Version 2.8.2.
+    (AC_GNU_SOURCE): Move up, so that it affects later compilations properly.
+    (DEFAULT_DIFF_PROGRAM, AC_TYPE_SIGNAL): Remove.
+    (jm_AC_TYPE_INTMAX_T): Add.
+    (AC_FUNC_FNMATCH_GNU): Use this, instead of AC_FUNC_FNMATCH.
+    (AC_CONFIG_LINKS): regex.hin renamed from regex_.h.
+
+commit 8578be467d873454a08ba86e3c840f0dda48ae90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    Incorporate contents from INSTALLME.  Upgrade to help2man 1.28.
+
+commit d67b77f4306960b8233ef75ee32f95d92eb29801
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    Version 2.8.2.
+
+commit 1fe83a59f8a6c6c48cd842ead12dc70663067998
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (EXTRA_DIST): Remove INSTALLME.
+
+commit bb9cc01d988adfbf8928d040fbd29d6b953fe158
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (EXTRA_DIST): Add fnmatch_loop.c.
+    (noinst_HEADERS): fnmatch_.h renamed from fnmatch.hin.
+    regex_.h renamed from regex.hin.
+    Add file-type.h.
+    (libdiffutils_a_SOURCES): Add file-type.c.
+    (DISTCLEANFILES): Remove fnmatch.hno, regex.hno.
+
+commit 9e4cdf9d2ceac4e2599c50523c14f544e0015a6d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (__const): Do not define to empty, as this breaks
+    Sun cc.  The code doesn't work with K&R anyway.
+
+commit 871e480cf6d7be4c0ffa60703cb8e558b55e5944
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (alloca, __builtin_expect): Define for non-GCC hosts.
+    <strings.h>: Include only if HAVE_STRINGS_H.
+    <stddef.h>: Include if we include stdlib.h.
+    Do not comment out all code if ! HAVE_FNMATCH_GNU.
+    (getenv): Do not declare if HAVE_DECL_GETENV.
+    (__strchrnul, __wcschrnul): Remove; not used.
+    (MEMPCPY): Use mempcpy if not _LIBC; use memcpy if neither _LIBC
+    nor HAVE_MEMPCPY.
+    (FOLD) [HANDLE_MULTIBYTE]: Do not pass wide char to ISUPPER.
+    (STRLEN, STRCAT, MEMPCPY) [HANDLE_MULTIBYTE && !defined _LIBC]:
+    Use wcslen rather than __wcslen, and likewise for wcscat, wmempcpy.
+    (MEMPCPY) [HANDLE_MULTIBYTE]: Use wmempcpy if not _LIBC; use wmemcpy
+    if neither _LIBC nor HAVE_WMEMPCPY.
+
+commit a9a0f5a47ba0a86cbdbaccb17951a7b612741bf5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (siginfo_t, c_stack_die): Remove decl.
+
+commit 88ead7550596dfef16049c68f65b5e70bd1395cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (__attribute__): New macro.
+    (EOVERFLOW): Define if not defined.(stack_t): Define to struct sigaltstack if not defined or declared.
+    Include <sys/resource.h>, <ucontext.h> if available.
+    Include <stdio.h> if DEBUG.
+    Do not include <inttypes.h> or <stdint.h>.
+    (c_stack_die): Remove info and context args.  All uses changed.
+    (segv_action): Likewise.
+    (alternate_signal_stack): Change uintmax_t to long, to ease porting.
+    (get_stack_location, min_address_from_argv, max_address_from_argv,
+    null_action): New functions.
+    (stack_base, stack_size): New vars.
+    (segv_handler): context arg may not be used.
+    Use global stack_base, stack_size if
+    ! HAVE_XSI_STACK_OVERFLOW_HEURISTIC.
+    Add debug code.
+    Invoke die (rather than segv_action) to exit.
+    (c_stack_action): Accept new argv arg, and simpler handler arg.
+    All uses changed.  Move code into new functions above.
+    Allow null action.
+    [! (defined SA_ONSTACK && defined _SC_PAGESIZE)]: Assume all segvs
+    are stack overflows.
+    (main) [DEBUG]: Describe what output should be like.
+
+commit 6cce27301e62cc6ce0aa6896ffcc1fba43a10b39
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    Reword "@option{-f} and @option{--foo}" to "@option{-f} or @option{--foo}".
+    Use @acronym instead of @sc where appropriate.
+    (Specified Lines): Renamed from Specified Folding.
+    (Comparison, Blank Lines):
+    Clarify wordings for Blank Lines and Specified Lines nodes.
+    (Binary): Mention --verbose and --print-bytes.
+    (Tabs, sdiff Option Summary, diff Options):
+    New option --tabsize=COLUMNS.
+
+commit 3c8ae4bdc186ef5ee25ebe47d2718c8e7227d008
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 10 08:04:33 2002 +0000
+
+    Convert to new autoconf.
+
+commit 735b377bbdb5385c533fbd910359b9b5fbb8ba9b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 25 10:34:07 2002 +0000
+
+    (jm_PREREQ_EXCLUDE): Use AC_FUNC_FNMATCH_GNU.
+    (jm_PREREQ_QUOTEARG): AM_C_PROTOTYPES -> AC_C_PROTOTYPES.
+
+commit a1fdcabe77b73cf3131c7c9372755c6dd280b20e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 10 11:20:06 2002 +0000
+
+    Initial revision
+
+commit e2e1c72458808505888bfd037e030be0c6a1fc64
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Apr 25 21:55:16 2002 +0000
+
+    Check for false and true values in preprocessor expressions.
+
+commit b68181fadb5995369e4eb5258f11dcc263ebd8c7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Apr 21 04:35:32 2002 +0000
+
+    Update to Automake 1.6.1.
+
+commit 3977399600bd39600c19f76410ac485eade0ab04
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 9 17:55:36 2002 +0000
+
+    Initial revision
+
+commit 384ece6125c1d7f941c9afdc5420c1e0f8c5eb3d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 8 18:56:39 2002 +0000
+
+    (__restrict_arr): Define for GCC 3.1 and up.
+
+commit 23447f11cd30a9146194535cd24dbfd326702ea6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (AC_INIT): Version 2.8.1.
+    (AC_HEADER_STDBOOL): Add.
+    (AC_CHECK_HEADERS): Remove stdbool.h.
+
+commit 52dd0175b9162ac5de7fb0f7743982b586800d41
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Add Ulrich Drepper.
+
+commit 4921a4ab37be351e7b0e6b6f8fa95692a0394e5e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Doc fixes in 2.8.1.
+
+commit a07c16a6f30ee48431a3d983cbb76cbd7faac2c5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (SSIZE_MAX): Define if limits.h doesn't.
+
+commit 869386e545a4569fec82ea14efceefe1976d097c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Include cmpbuf.h.
+    (read_diff): Use block_read instead of read, to work around Tru64 5.1 bug.
+
+commit e3c53fd2ffd9ce6038a435af784da55b785ffae6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (cmp): Use block_read instead of read, to work around Tru64 5.1 bug.
+
+commit 4f9d18c728e3c5161ffa3f34c91e3dc12f12229b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Assign PTRDIFF_MAX - 1 to a size_t variable, just in case there's a problem
+    with ptrdiff_t versus size_t.
+
+commit 0be3e22c88468137b418c833b1ef6a31fa9290b3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (datadir, INCLUDES): Remove.
+    (AM_CPPFLAGS): New macro.
+
+commit bea637acb3fd1df8bb51634bd05c0c3cae1e3d8a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Initial revision
+
+commit c7448142e8cfbc6c458b9f70b6bad67b097a49ad
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (jm_PREREQ_EXCLUDE): Use AC_HEADER_STDBOOL rather than AC_CHECK_HEADERS(stdbool.h).
+    (jm_PREREQ_HASH): Likewise.
+
+commit a758e82c032307554e827eae4d017113cab4b1f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (errno): Remove declaration; K&R C is obsolete.
+    Include limits.h.
+    (SIZE_MAX, SSIZE_MAX): Define if standard headers don't.
+    (MIN): New macro.
+    (block_read): Do not attempt to read more than SSIZE_MAX bytes, as the
+    resulting behavior is implementation-defined.  Work around bug in
+    Tru64 5.1, which can't read more than INT_MAX bytes at a time.
+
+commit e21807a095fb6db7ce208b43e54f7d6cc8762247
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Use new @copying directive.  Work around incompatibility with Debian
+    install-info.
+    Put @contents first, not last, since Texinfo now suggests this.
+    Fix bug in -w documentation noted by Karl Berry.
+    Mention links for speedup.
+    New node "Speedups" for future speedups.
+    Just say "Index", not "Concept Index".
+
+commit 9ca86332609254e0ad957e7524d25b442ff60ec2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Mention GNU texinfo.
+
+commit 8074c424b524873712e3cce26a1ca302b7927f9e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 25 04:58:36 2002 +0000
+
+    (sip): Do not mishandle buffered count when reverting to text mode.
+
+commit 79a1780c886394cf7a423606ff1230fa04bdc1ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:50:25 2002 +0000
+
+    Upgrade the description of `patch' to GNU patch 2.5.4, and revamp
+    the documentation accordingly.
+
+commit a888728c15b0d5b1a9edb63c281ead02938542cc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:48:39 2002 +0000
+
+    (AC_INIT): Version 2.8.
+    (AC_PREREQ): 2.53.
+
+commit a9d6b567a0d30c144d003a93321891f736bdef31
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:46:58 2002 +0000
+
+    Diffutils 2.8.
+
+commit d3a786ee18774379e976c3c8fde2fd1cadf472ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:40:52 2002 +0000
+
+    Upgrade to gettext 0.11.1 and help2man 1.27.
+
+commit 78899f4efb372cba80dca7f970c6744b1eb4f4c4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:36:37 2002 +0000
+
+    (c_stack_die) [!HAVE_SIGINFO_T]: Don't use info.
+    Bug reported by Eli Zaretskii.
+
+commit f581b40bf9c058223186ed2bb554ae8d5ad87a35
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:35:28 2002 +0000
+
+    (main): Fix typo that prevented diff -y from working.  Bug reported by
+    Mitsuru Chinen.
+
+commit 855c8786ae73c5078b5248f7c26c97d816f944ed
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 15 22:07:58 2002 +0000
+
+    Tweak editing of install-info-am target.
+
+commit 10baaae888f0f9e70ef7e7665ea33c20591e1617
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 13:08:22 2002 +0000
+
+    (cmp): Fix typos in previous change.
+
+commit 7bbd6de9bca5f9be4122984dbc6ccc6754c91765
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 13:03:58 2002 +0000
+
+    Use "byte" rather than "char" if a translation for "byte" is available.
+
+commit 3115963776ec53e46ba6da6a1fd8f7df01a8e039
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 07:17:13 2002 +0000
+
+    Bring back --horizon-lines.
+
+commit 89b6f2d6e560f2cf3e16c1dbc1c7fdbe0700f33d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 07:16:19 2002 +0000
+
+    cmp -l -s and cmp -s -l are not allowed.  Use cmp -s or cmp -l instead.
+    Deprecate diff -h, -H, -L, -P, --inhibit-hunk-merge.
+
+commit c19f0389186ef8990657d3fb253e72641c9ea2d3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 07:14:31 2002 +0000
+
+    (option_help_msgid): Bring back --horizon-lines documentation.
+
+commit fa03d1fdfbcb50aa07445b5df7cdbb14b496f342
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:50:10 2002 +0000
+
+    (AC_INIT): Version 2.7.10.
+    (jm_PREREQ_HARD_LOCALE): Add.
+
+commit d950765db33214a06f0a9512396e5f8cf532f2f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    -L -> --label
+
+commit d8a86d88b2d0777d3d13e4bf76e52202974b4f48
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (option_help_msgid): Do not document -L, -P, --horizon-lines,
+    --inhibit-hunk-merge, -H.
+
+commit 9f0dae504667a7369cfdb1d8bcfd69bbeec78659
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (specify_comparison_type): New function.
+    (check_stdout): "indices and codes" -> "byte numbers and values"
+    (main): Use specify_comparison_type to detect option clashes.
+
+commit 1d63e8c4d1574ceddfd86ded8da35fca45af577d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (jm_PREREQ): Add jm_PREREQ_HARD_LOCALE.
+    (jm_PREREQ_HARD_LOCALE): New macro.
+
+commit 0d3dcc25e737e4429adcc663b39b3a876f84657e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (alloca): Remove.
+    Include stdlib.h if available, for malloc.
+    (hard_locale): Use malloc, not alloca.  Test for storage allocation failure.
+
+commit 8fe985d9880461be41f90f60672daea5eed736cf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (Overview): byte != character.
+    (Detailed Context, Detailed Unified, Alternate Names, diff Options): Do not document diff -L.
+    (Comparing Directories): Do not document diff -P.
+    (Making Patches, diff Options): Likewise.
+    (diff Performance, sdiff Option Summary, diff Options, sdiff Options): Do not document diff -H.
+    (diff Performance, diff Options): Do not document --horizon-lines.
+    (cmp Options): Prefer -b to -c.
+    (cmp Options, diff Options, diff3 Options, sdiff Options): Put short
+    options next to the similar long options.
+    Document --help, and use the same wording for --verbose on all commands.
+    (diff3 Options): Fix typo in description of -E, which used wrongly used
+    "-e" instead of "-E".
+    (patch Options): Put short options next to the similar long options.
+
+commit 2839f50782cc5757a03caa671bb82028edb0a0f2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:37:01 2002 +0000
+
+    Do not distribute shar file.
+
+commit db6505cbe52329d36717f52d1ba013dbf30dd61b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:23:30 2002 +0000
+
+    Initial revision
+
+commit 91bee6760695a602ba855ffd3e1339f6056e7865
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (option_help_msgid, usage): Reword for help2man.
+
+commit 68f96e5cd777642bec7b1d9e0fd5345796c95586
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    Remove trailing white space.
+
+commit 4f981362a7a3074f1216cfb8060075b256b1cda1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (option_help_msgid): Reword for help2man.
+
+commit d001fbedbe556f6ad3139d86350a502ab3dee29b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (usage): Reword for help2man.
+
+commit dbea9821b7e9fe612becb6ce2041e7f7720e2c05
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (AUTOMAKE_OPTIONS): Remove.
+
+commit 796ad2bc350bb9d5c6d57870e2450d0a37d694b5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    Add zh_TW.
+
+commit b3dabc957103be5a3ec304696bd558ec940fd670
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (AUTOMAKE_OPTIONS): Remove gnits.
+
+commit 6d9d2036a21790ec48b34948a1099c8b20718e24
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (AC_SYS_XSI_STACK_OVERFLOW_HEURISTIC): Change wording of message.
+    Do not check for stdbool.h or ucontext.h, or for ucontext_t or
+    sigaction or sigaltstack.
+
+commit 1e15bf9664e3d40ced7875a46fc00bd3a35b6296
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    Include <errno.h>
+    (ENOTSUP): Define if errno.h doesn't.
+    (SA_NODEFER, SA_ONSTACK, SA_RESETHAND, SA_SIGINFO, SIGSTKSZ, _SC_PAGESIZE,
+    ALTERNATE_STACK_SIZE, stack_t, sigaltstack): Remove; we now assume them
+    all when HAVE_XSI_STACK_OVERFLOW_HEURISTIC, so we don't need substitutes.
+    (<ucontext.h>): Include only if HAVE_XSI_STACK_OVERFLOW_HEURISTIC.
+    (alternate_signal_stack): Now of size SIGSTKSZ, not ALTERNATE_STACK_SIZE.
+    (segv_handler): Simplify, under the assumption that
+    HAVE_XSI_STACK_OVERFLOW_HEURISTIC is nonzero.
+    (c_stack_action): Likewise.
+    (exit_failure) [DEBUG]: Initialize to 0, not 1.
+    (recurse, main) [DEBUG]: Remove main args.
+
+commit 1ada67d90b1f55e10dfe2f4ea646855b963a9274
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:09:22 2002 +0000
+
+    (AC_INIT): Change package name from diff to diffutils.  Bump version
+    to 2.7.9.
+    (AM_INIT_AUTOMAKE): Use new form, with options gnits dist-shar,
+    rather than old from that duplicated AC_INIT.
+    (AM_MISSING_PROG): Add help2man.
+    (REGEX_MALLOC): Define.
+    (AC_CONFIG_FILES): Add man/Makefile.
+
+commit f88dc3e8ed068be29a0f96c1213f143ead9c61e8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:08:45 2002 +0000
+
+    Add man pages.
+
+commit 3ec1124c9faf779d7bf99dac29aa09f88ec98417
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:07:05 2002 +0000
+
+    (AUTOMAKE_OPTIONS): Remove.
+    (SUBDIRS): Add man.
+
+commit f28f42d6d6f29b5835cdb7c4c91701cfb6e56f62
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:07:05 2002 +0000
+
+    Update to autoconf 2.53, automake 1.6, help2man 1.25 with patch.
+     .
+
+commit b89a1f4f2cba1a0f1d5357fd7fb11666b35f9eed
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Mar 2 11:56:17 2002 +0000
+
+    Tweak editing of install-info-am and
+    uninstall-info-am targets, to include 8+3-butchered names of Info
+    files.
+
+commit a0303415a5f3500f2246f5fb36748fe2eeb5f50c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 1 19:46:11 2002 +0000
+
+    Remove trailing white space
+
+commit 6e1f365f51d8d682047721b5041d362ce0914563
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 1 07:42:20 2002 +0000
+
+    Initial revision
+
+commit be90df3756ef94bb38b8256078fd9fb99303bf78
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 08:05:12 2002 +0000
+
+    Include <xalloc.h>.
+
+commit 56e47cdf45fd4cfe528d9bb802d7535fd895493f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 08:05:12 2002 +0000
+
+    (LONG_OPTION, GROUP_FORMAT_OPTION, LINE_FORMAT_OPTION): Remove.
+    (longopts): Revert to prevision version.
+
+commit 145637ede6ef151716c0ed602f17ed6f3b02f994
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 07:35:36 2002 +0000
+
+    Reword to put POSIX first.
+
+commit aa3a3c3a118c8869416a3c39ab4851bb9881e030
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 07:26:14 2002 +0000
+
+    diff -NUM is now deprecated.
+    diff now takes the maximum of the specified contexts.
+    Conflicting options now cause an error again.
+    "Microsoft OSes" -> DGJPP
+
+commit 2fb91b7373594ad082b9362944e34249f20bfe82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 06:32:34 2002 +0000
+
+    (AC_INIT, AM_INIT_AUTOMAKE): Version 2.7.8
+    (AC__GNU_SOURCE): Add this, replacing AH_VERBATIM of _GNU_SOURCE.
+    (AM_GNU_GETTEXT): Add external arg, from gettext 0.11.
+    (tempname): Use AC_LIBOBJS, not LIBOBJS=, as now required by autoconf.
+    (jm_PREREQ_C_STACK): Add.
+    (AC_CONFIG_FILES): Remove intl/Makefile.
+
+commit de95c16082c62034ac0b034e71684b43ddc499f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    2 -> EXIT_TROUBLE.
+    Adopt POSIX convention for ENOEXEC and exit status 126.
+    unsigned -> unsigned int
+
+commit 52fbd2fdd450db3285b5df0754a537e81f16e057
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    Don't use alloca or include <alloca.h>.
+    unsigned -> unsigned int
+    (EXIT_SUCCESS, EXIT_FAILURE, EXIT_TROUBLE): Define if not defined.
+    Include signal.h.
+    (SA_RESTART): Define if not defined.
+    (SIGCHLD): Likewise.
+
+commit 3064374e471e327d5e298176f9606fcbd9197b73
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    unsigned -> unsigned int.
+
+commit 0d7a3eb7ac6f51ac0e4484f9c4fce89d008905ec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    Include c-stack.h, exitfail.h.  Do not include signal.h.
+    0 -> EXIT_SUCCESS, 1 -> EXIT_FAILURE, 2 -> EXIT_TROUBLE.
+    (ck_editor_status): New function.
+    (main): Check for stack overflow.
+    Adopt POSIX convention for subsidiary programs not found.
+    (diffarg): Check for integer overflow to avoid core dumps.
+    (trapsigs): Remove SA_INTERRUPT special case; now done by header.
+    (SIGCHLD): Likewise.
+    (edit): Adopt POSIX convention for subsidiary programs not found.
+
+commit 4179042755cc919ce8d9b8043cd7e60515f36b30
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    (sip): Avoid integer overflow and core dumps if buffer alignments are
+    preposterously incompatible.
+    (slurp): Do not dump core if the file is growing as we read it.
+    If a regular file grows, keep reading until we catch up with its EOF.
+    (find_and_hash_each_line): Check for integer overflow to avoid core dumps.
+    (GUESS_LINES): Remove.
+    (guess_lines): New function.  Avoid integer overflow.
+    (find_identical_ends): Use it.
+    Avoid integer overflow and possible core dumps.
+
+commit 9d39ee103c4ba56fc584ee877a800e3a57312183
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    (format_group, print_ifdef_lines): Avoid core dumps with
+    bad formats.
+    (do_printf_spec): Avoid alloca.
+
+commit 1ae253c28bd45fb808e3ba5d5a27d7a7781fdf86
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    (dir_read): Ignore st_size of directories: POSIX says it's garbage.
+    Check for integer overflow to avoid core dumps.
+    (diff_dirs): 0 -> EXIT_SUCCESS, 2 -> EXIT_TROUBLE.
+
+commit 309c90b06bd95d1b1a9dc3f418d60b0c01ad8dd8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    Include c-stack.h, exitfail.h.
+    (ALLOCATE): Remove.  All uses changed to xmalloc, or to xmalloc plus
+    an overflow check.
+    (myread): Remove.
+    (main): Check for stack overflow.
+    0 -> EXIT_SUCCESS, 1 -> EXIT_FAIULRE, 2 -> EXIT_TROUBLE.
+    (try_help): Likewise.
+    (process_diff): Check for integer overflow, to avoid core dumps.
+    2 -> EXIT_TROUBLE.
+    (read_diff): Exit with status 126 if the file is not executable,
+    for compatibility with POSIX 1003.1-2001.
+    Accommodate ancient AIX hosts that set errno to EINTR after uncaught
+    SIGCONT.
+    Check for integer overflow to avoid core dumps.
+    (fatal, perror_with_exit): 2 -> EXIT_TROUBLE.
+
+commit 8a8172ed6d1018777adcf0a4d8e542c89b62a2db
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    Include c-stack.h, exitfail.h.
+    Do not include signal.h.
+    (specify_style, specify_value): Bring these routines back, as POSIX
+    requires that the order of options not matter.
+    (shortopts): New constant.
+    (group_format_option, line_format_option): New constants.
+    (LONG_OPTION, GROUP_FORMAT_OPTION, LINE_FORMAT_OPTION): New macros.
+    (longopts): Use them.
+    (main): 0 -> EXIT_SUCCESS, 1 -> EXIT_FAILURE, 2 -> EXIT_TROUBLE.
+    Ensure that order of options does not matter.
+    Check for stack overflow.
+    If contexts overflow, substitute LIN_MAX, as that's good enough.
+    If multiple contexts are specified, use their maximum.
+    -c is equivalent to -C 3 now, instead of having an implicit context;
+    likewise for -u and -U 3.
+    Use specify_style and specify_value.
+    (SIGCHLD): Do not define; now done in a header.
+    Use new style time stamp format for -u / -U.
+    Reject numeric-string options if operating in POSIX 1003.1-2001 mode.
+    Avoid overflow problems with tab width.
+    Simplify from-file and to-file code.
+    (usage): Do not mention obsolete options.
+    (filetype): Do not mention whether a file is executable.
+    Add typed memory objects.
+    (compare_files): 0 -> EXIT_SUCCESS, 1 -> EXIT_FAILURE, 2 -> EXIT_TROUBLE.
+
+commit c959ef623200eb155fd7b3922b45d6a05473d627
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:48:46 2002 +0000
+
+    (pr_context_hunk): Do not dump core if an enormous context causes an
+    arithmetic overflow.
+    (pr_unidiff_hunk): Likewise.
+    (find_hunk): Likewise.
+
+commit 4aae6ffeaf06ddbe087ab7240f004a21d29053ff
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:48:46 2002 +0000
+
+    Include c-stack.h, exitfail.h.
+    (hard_locale_LC_MESSAGES): Depend on ENABLE_NLS.
+    (try_help, check_stdout, main, cmp): 2 -> EXIT_TROUBLE.
+    (main): Check for stack overflow.
+    0 -> EXIT_SUCCESS.
+    1 -> EXIT_FAILURE.
+    (cmp): Likewise.
+    Accommodate ancient AIX hosts that set errno to
+    EINTR after uncaught SIGCONT.
+
+commit e53339d2dc48207afa94f48d24c3d2aba979b467
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (diff_2_files): Avoid arithmetic overflow in buffer size calculation.
+
+commit 1035ed370de10d17eb8740297c7e5f869bba309b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (datadir): @DATADIRNAME@ -> share.
+    (INCLUDES): Remove intl.
+    (LDADD): Change INTLLIBS to LIBINTL.  No need to link libdiffutils.a twice.
+
+commit e7d9579f6a33b24bab7b5f4c797d116968534448
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Add lib/c-stack.c, src/dir.c.
+
+commit 58166227e9ce53b408123ec4a56603df61a0de6b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Add cs, ja.
+
+commit 07c7dac163b39bdfc849c3c44e503548f7e1ca0e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (AC_FUNC_SETMODE_DOS): Check for fcntl.h and unistd.h unconditionally.
+
+commit 570f74da59f3403ea25d43e9d8413a240da40a98
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (jm_PREREQ): Add jm_PREREQ_POSIXVER.
+    (jm_PREREQ_POSIXVER): New macro.
+
+commit 9f0eff52c22275bc86d26a562a679812c5dd7cdb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Initial revision
+
+commit 8d9e3b29bf92b6c9d622475e3eb000e2c62d42cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (buffer_lcm): New arg LCM_MAX.
+
+commit 47b633e3cfc658faf4c0e5ab0aa9990c14c64e87
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Include errno.h.
+    (errno): Declare if !STDC_HEADERS.
+    Include signal.h.
+    (SA_RESTART): Define if not already defined.
+    Include <inttypes.h>.
+    (PTRDIFF_MAX): Define if not already defined.
+    (TYPE_SIGNED, TYPE_MINIMUM, TYPE_MAXIMUM): Likewise.
+    (block_read): Accommodate ancient AIX hosts that set errno to EINTR
+    after uncaught SIGCONT.
+    (buffer_lcm): Return a reasonable size if the multiple is too large.
+    New arg LCM_MAX.  All callers changed.
+
+commit a44befd50b332e152c4beae97fdac417cd214ffa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (noinst_HEADERS): Add c-stack.h, exitfail.h.
+    (libdiffutils_a_SOURCES): Add c-stack.c, exitfail.c, quotesys.c.
+    (INCLUDES): Remove.
+
+commit 2e507ad1c092735de058e7e7b7066ecac50269a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Include exitfail.h.
+    (xalloc_exit_failure): Remove; subsumed by exit_failure.
+    All uses changed.
+
+commit b89fe19666dfdbf512fb5c9d24db924fd31b468c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (xalloc_exit_failure): Remove; subsumed by exit_failure.
+
+commit 8eb1bae7000c49615c8ccde9bab35c50070396f9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Include "hard-locale.h".
+    (hard_locale): Ignore ENABLE_NLS, since we want to operate on
+    locales other than LC_MESSAGES.
+
+commit 3561657de9831ea2750619b86935d18430a27065
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Add vr index.
+    Update copyright to 2002.
+    (Standards conformance): New chapter.
+    (Binary): Differing binary files are trouble unless the user asked for
+    brief output.
+    (Detailed Context): Prefer new time stamp format in discussion.
+    (Less Context): Likewise.  (Also use short option).
+    (Detailed Unified): Likewise.
+    (Alternate Names): Separate option from arg.
+    (Pagination): Prefer new time stamp format in discussion.
+    (Making Patches): Mention -U 2.
+    (diff Options): Deprecate -LINES, as POSIX 1003.1-2001 does not allow it.
+
+commit 5fcad7569e7edea859fe050d60ca8f1bac5607bb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:18:53 2002 +0000
+
+    (SUBDIRS): Remove intl.
+
+commit 9fefe1c55909e3aef526522c29d9646812523a4a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:18:53 2002 +0000
+
+    Update advice for Solaris installation problems.
+    We no longer use a test version of gettext.
+    Autoconf test version updated from  2.52f to 2.52h.
+    POSIX 1003.1-2001 patch for Automake.
+
+commit 38231fc04f4ed6581db50bbd68d22f45a7d7c91d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Feb 16 05:30:19 2002 +0000
+
+    Initial revision
+
+commit 3121d568e22a84e44e7508f3b116185bed77e38c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:48:10 2002 +0000
+
+    Warn about libiconv problems.
+
+commit 0f9e8c67e1c082c4b3a284002796cb0f5da8e15d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:40:17 2002 +0000
+
+    DIFF -> Diffutils
+
+commit 9c2cd387c77c5499932c7c4111dd4dee50d0d1cf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:35:06 2002 +0000
+
+    Don't say "illegal".  Fix headers to match recent gettext standards.
+
+commit 2d27ca42cda7c727cba1a70c58ff9d9c7422a0b3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (AC_INIT, AM_INIT_AUTOMAKE): Version 2.7.7.
+    (AC_INIT): Use new 3-arg form.
+    (AC_CONFIG_SRCDIR): Specify src/diff.c here, not in AC_INIT.
+    (ALL_LINGUAS): Remove: now in po/LINGUAS as per Gettext 0.11.
+    (AC_CONFIG_AUX_DIR): New macro invocation.
+
+commit 4b67faa4adaf9b8471caed288dcbbf43cecd5d2e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Mention INSTALLME.
+
+commit ffaecd082cbb558dc496f5583f53a5e14aab716e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (AC_INIT, AM_INIT_AUTOMAKE): Version 2.7.7.
+    Reformat for imminent 2.8 release.
+
+commit 6f653ba4711ea25106bdfce5946c4ee2d131a198
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (EXTRA_DIST): Add config/config.rpath, INSTALLME.
+    (DISTCLEANFILES): Remove.
+
+commit 788366578a517c465ff131c4690e7bef0149d850
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (finish_output): Ensure that werrno is initialized.
+    (lines_differ): Have an explicit do-nothing case for
+    IGNORE_NO_WHITE_SPACE, to pacify gcc -Wall.
+
+commit 17832e035de3e3a6b59ed901d87d36d156cc80a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (UINTMAX_MAX): New macro.
+    Include gettext.h, not libgettext.h.
+    (N_): Do not wrap arg in parentheses.  Fix from Bruno Haible.
+
+commit f8b1a9f4e4b845c5bab4b016213e40eace32215a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (copyright_string): Update to 2002.
+    (usage): Reformat messages to ease translation.
+    (handler_index_of_SIGINT, handler_index_of_SIGPIPE):
+    New macros.
+    (main): Do not confuse signal numbers with their indices.
+    Bug reported by Bruno Haible.
+    (edit): Cat lin to long before printing with %ld, since lin might
+    be narrow than long.
+
+commit ec7bf151d0ae5b8a92be3354f6783353adb0afd9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (file_block_read): Use SIZE_MAX instead of (size_t) -1,
+    to avoid warnings on some compilers.
+
+commit 8d25777b1af7332dfb556095d26e5c7c4724796d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Include <setjmp.h>
+    (struct dirdata): New member nnames.
+    (locale_specific_sorting, failed_strcoll): New vars.
+    (dir_read): Renamed from dir_sort.  Don't sort the dir.
+    Set new nnames member of struct dirdata.  All callers changed.
+    (compare_names): Don't check for errno after strcasecmp.
+    Use strcoll only if locale_specific_sorting is nonzero.
+    If strcoll fails, longjmp out rather than returning a value
+    that might result in an invalid comparison function that might
+    make qsort dump core.
+    (diff_dirs): Sort the directory ourselves.  Use setjmp to recover
+    from strcoll failure, falling back on native byte comparison.
+    Make local variables volatile if they need to preserve their value
+    after setjmp/longjmp.
+
+commit a76d0e1130b4d06d00ec29b237cf1f9a82bd6193
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (copyright_string): Update to 2002.
+    (usage): Reformat messages to ease translation.
+    (main): Remove unused variable.
+
+commit 89d3f55dd661b9df807fd93617c7ba4f42fa3da3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (copyright_string): Update to 2002.
+    (bytes, parse_ignore_initial, cmp): Use UINTMAX_MAX
+    instead of (uintmax_t) -1, to avoid warnings on some compilers.
+    (usage): Reformat messages to ease translation.
+
+commit 5289afd403a0c0309eaa0c2ca6cd256facd2b438
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Include <string.h>.  Reported by Bruno Haible.
+
+commit eadc9ce7d6afaee9bbdcbabde146e6a7536040a1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Fix comment.
+
+commit 75cd3e885faf8d8ab4f69b884eed11533d94abd4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (noinst_HEADERS): Add gettext.h.
+
+commit 65da723237e469bfccaf8920355d5f413a1dd044
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Move most of contents to INSTALLME.
+
+commit 39a4929c852dd49bd4bdd4c438a13cca95022868
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Initial revision
+
+commit 6580226bf62049ab531501429f2ed3d52acf8d59
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 02:10:11 2002 +0000
+
+    Initial revision
+
+commit 3f4addd972269b5f93567ed569f3cdf862485713
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 16 12:19:34 2002 +0000
+
+    Initial revision
+
+commit c30fa59166501a8529845b1b5664878cea335112
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jan 5 21:13:09 2002 +0000
+
+    Initial revision
+
+commit 879669e496b3749942de106860a1d738bfc35ad3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 31 23:05:35 2001 +0000
+
+    (interact): After extracting rlen from the editor command, test for a
+    terminating null character, not for a newline.
+
+commit 2bc51c81cb21b206b57e9466d49e84f2ed7ae5dc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 31 23:05:01 2001 +0000
+
+    Fix AC_CONFIG_LINKS for when symlinks are unavailable.
+
+commit c6228a86aff93d1374085be36f0051240afd5ece
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 31 23:04:26 2001 +0000
+
+    Allow longer source directory names without
+    overflowing the line length limits.  Create the cache in the
+    build directory, not in the source directory
+
+commit 5b9b018b29a6d76ac8c5a1d07d168618898a761f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 02:03:34 2001 +0000
+
+    * New diff3 and sdiff option: --diff-program=PROGRAM.
+    * The test-version environment variables DIFF_OPTIONS and DIFF_PROGRAM
+      have been withdrawn, as they caused compatibility problems.
+      You can use aliases or shell script wrappers instead.
+
+commit c3809af86cf16612f01b01f27bb30d7b44db97a0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:59:05 2001 +0000
+
+    (begin_output): Have child exit with status 127 rather than reporting
+    failure on its own.  Set errno to 0 before invoking popen.
+    (finish_output): Report errno on pclose failure.
+    Distinguish between subsidiary program not found, and failure.
+
+commit 1f7b77fe80d868007776e8e33d3be2bd19cae399
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:55:59 2001 +0000
+
+    (not_found, execdiff): Remove.
+    (DIFF_PROGRAM_OPTION): New constant.
+    (longopts, option_help_msgid, main): Add --diff-program=PROGRAM.
+    (check_stdout): New function.
+    (main): Remove DIFF_PROGRAM support.  Check stdout after printing version.
+    Use check_stdout after printing help.  Use execvp/perror_fatail rather
+    than execdiff.  Set errno to 0 before invoking popen.
+    Check for pclose failure properly.
+    (main, edit): If child exec fails, exit with 127 rather than trying to
+    print diagnostic.
+    Distinguish between subsidiary program failing and not being found.
+    (edit): Handle signals the same way, regardless of whether we're using
+    system or fork+exec.  Check for system returning -1.
+
+commit c3a98cfc023bb1cd00875a77f2ae35e78967c218
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:48:07 2001 +0000
+
+    (DIFF_PROGRAM_OPTION, HELP_OPTION): New constants.
+    (longopts, main): Use them.
+    (longopts, main, option_help_msgid): New option --diff-option=PROGRAM.
+    (main): Remove DIFF_PROGRAM support.
+    Check stdout after printing version.
+    (check_stdout): Report errno info if fclose fails.
+    (read_diff): Have child exit with status 127 when program is not found,
+    rather than trying to have the child report failure.  CHeck for
+    pclose returning -1.
+
+commit f16be0e2b03914a24479e5b4587dd31ccfbb3fdf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:44:21 2001 +0000
+
+    (DEFAULT_WIDTH): Remove.
+    (main): Use 130 instead of DEFAULT_WIDTH, since it's not really
+    builder-settable.  Do not prepend DIFF_OPTIONS.
+    (check-stdout): If fclose (stdout) fails, print errno info.
+    (option_help_msgid): Default context is 3, not 2.
+    (usage): Work even if ptrdiff_t is wider than int.
+
+commit aa71c5d0fd39a210285416856a782657c7be6945
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:53:12 2001 +0000
+
+    (diff Options): Remove DIFF_OPTIONS.
+    (Invoking diff3, Invoking sdiff): Remove DIFF_PROGRAM.
+    (diff3 Options, sdiff Options): Add --diff-program.
+
+commit 5400b5e9051392e46fd4438fbc5e022e63e922c9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:11:59 2001 +0000
+
+    (valid_suffixes): Add '0', to support suffixes like "MB" and "MiB".
+    (check_stdout): Don't assume that the translations of "write failed"
+    and of "standard output" lack '%'.
+    (main): Check stdout after printing version.
+
+commit e053f8c49d1a14ab45ec697502f0f3ceaa85790d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:09:16 2001 +0000
+
+    [HAVE_FCNTL_H && HAVE_SETMODE_DOS]: Include <fcntl.h>.
+    [!HAVE_SETMODE_DOS]: Do not include <unistd.h>.
+    (set_binary_mode): Return mode (not 1) if fd is a tty.
+    Do not assume that O_TEXT is zero.
+
+commit 2eb762252f7faef3208c90fffef44edf5fb07102
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:06:54 2001 +0000
+
+    (cmp Options): In byte counts, a plain suffix (without any integer)
+    is assumed to modify the integer 1.  Index terms like "kibibyte".
+    Document plain "k".
+    
+    (Reporting Bugs): Mention bug-report archive and test version
+    location.  Ask for "diff --version" in bug reports.
+
+commit ed5c8a4d3f69d096a02d850331f610c6daf1dd64
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:03:09 2001 +0000
+
+    (ALL_LINGUAS): Add tr.
+
+commit 26b18e2062458fb970aa7956e16840c7ee41ccc6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 22 01:48:53 2001 +0000
+
+    Latest version from self.
+
+commit f4501e2ec54a1a01572d275c33148107a64d76f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:30:37 2001 +0000
+
+    Fix typos.
+
+commit 25dfb088db254b39ddb21457473b76299d985999
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:26:46 2001 +0000
+
+    Fix comment.
+
+commit 08562bb5c3ac0748d5c6474d89399a73588f0fbc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:26:46 2001 +0000
+
+    Remove the split prevention of config.status.
+    Fix Sed commands for converting absolute file names into op_srcdir-relative ones.
+
+commit 510ff6559ed90ad984f5c442ff0ee054823c0325
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:26:46 2001 +0000
+
+    Initial revision
+
+commit c47d95a0840d2f0e48d0bb64e8f40d8860f674ab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 12 00:40:53 2001 +0000
+
+    Remove jm-glibc-io.m4
+
+commit b272bbb9bb27e469a99b8930e91d87ce15f161af
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:19:39 2001 +0000
+
+    Add --no-ignore-file-name-case.
+    File name case sensitivity now affects file name exclusion.
+    Fix typos.
+
+commit f1db1aefd227cf1e9d0717d72f959eca5c52e116
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:19:12 2001 +0000
+
+    diffutils 2.7.5
+
+commit c4b00134ca02faac16f6b321be5287df8558d18b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:14:20 2001 +0000
+
+    Include dirname.h.
+    (dir_file_pathname): Use base_name rather than file_name_lastdirchar.
+
+commit 05264956fc8fc4b2428e495becfdfe70b2e1652f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:13:35 2001 +0000
+
+    (S_IXUSR, S_IXGRP, S_IXOTH): New macros.
+    Include <libgettext.h> rather than rolling it ourselves.
+    (file_name_lastdirchar, HAVE_SETMODE, set_binary_mode): Remove.
+
+commit 33e8ec0f79d0de7582d315cb938fcee6d2d4a446
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:12:22 2001 +0000
+
+    Include <dirname.h>.
+    (expand_name): Use base_name rather than file_name_lastdirchar, for
+    portability to DOS.
+    (main): Initialize xalloc_exit_failure before possibly invoking any memory
+    allocator.
+
+commit 994ba2db42d306251ad663d42a702e3c7cec3c03
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:10:47 2001 +0000
+
+    Include setmode.h.
+
+commit e8398dcf9a5254d63732ff5710df7bda0cf33470
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:10:14 2001 +0000
+
+    (main): Initialize xalloc_exit_failure before possibly invoking any memory
+    allocator.
+
+commit e3b1ff596cdbafce7eebce8c5976cd005bed8ab4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:30:46 2001 +0000
+
+    Include dirname.h, setmode.h.
+    
+    (main): Later values and/or styles now silently override earlier.
+    (specify_value, specify_style): Likewise.  All callers changed.  Remove.
+    
+    (binary, main, option_help_msgid, compare_files):
+    HAVE_SETMODE -> HAVE_SETMODE_DOS.
+    (NO_IGNORE_FILE_NAME_CASE_OPTION): New constant.
+    (longopts, main, option_help_msgid): Support it.
+    (exclude_options): New function.
+    (main): Use it. Initialize xalloc_exit_failure before potentially
+    allocating memory.
+    
+    (filetype): Distinguish executable files from others, as POSIX suggests.
+    
+    (compare_files): Use base_name instead of file_name_lastdirchar.
+
+commit fe7c8fb737386c5032c08a082e8f1a6a189aecec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:20:24 2001 +0000
+
+    Include <hard-locale.h>, <setmode.h>.
+    (hard_locale_LC_MESSAGES): New macro.
+    (sprintc): Remove int width arg; it's now the caller's responsibility to pad.
+    All callers changed.
+    (stat_buf): New static var; was formerly a local var in 'main'.
+    (valid_suffixes): Add 'K', for 'KiB'.
+    (option_help_msgid): Don't confuse bytes with characters.
+    (main): Set xalloc_exit_failure before invoking anything that might
+    allocate memory.  Fix bug: -n was incorrectly ignored when optimizing
+    the case of regular files with different lengths.
+    (cmp): Use an index column wide enough to store this comparison's indexes.
+    In locales other than the POSIX locale, say "byte" rather than "char".
+
+commit d788533d5f17bd403c6d87e77f32a241905879ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:12:21 2001 +0000
+
+    pc -> ms
+
+commit d104e14d8e39ca9fc7381c448da64de088b45dc2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:11:35 2001 +0000
+
+    Initial revision
+
+commit 412c4f34362c26ceb5305d8504b1e5766e4c9220
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:09:04 2001 +0000
+
+    (noinst_HEADERS): Add dirname.h, setmode.h.
+    (libdiffutils_a_SOURCES): Add basename.c, setmode.c.
+
+commit 380d97d7b99670c6fdb7c2f8cd0df8e8af524c66
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:07:59 2001 +0000
+
+    (AM_INIT_AUTOMAKE): Version 2.7.5.
+    (PR_PROGRAM): Use AC_DEFINE_UNQUOTED, so that $PR_PROGRAM is expanded by sh.
+    (ptrdiff_t, ssize_t): Use AC_CHECK_TYPE with a default of int,
+    not AC_CHECK_TYPES.
+    (jm_AC_DOS, AC_FUNC_SETMODE_DOS): New macros.
+    (AC_CONFIG_FILES): Add ms/Makefile.
+
+commit 277dbf811b8cd5300445328436282849faa477c6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:03:58 2001 +0000
+
+    (SUBDIRS): Add ms.
+
+commit 39ac13e2120e473ef5e0c35dce345e5a73b14d17
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 14:05:54 2001 +0000
+
+    Fix copyright notice.
+
+commit 0ac2866bd3c157a355a3aa1bd82cfef8f38a2b9b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:56:28 2001 +0000
+
+    diffutils 2.7.7
+
+commit 0b98d9a71f7c825c3052aa675d9029511d80f51b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:44:47 2001 +0000
+
+    (direntry, Overview, Comparison, Binary, Invoking cmp): Use "byte"
+    rather than "character" when talking about cmp, since it compares
+    bytes, not character.
+    (Invoking cmp): New trailing operands FROM-SKIP and TO-SKIP.
+    -i or --ignore-initial now accepts FROM-SKIP:TO-SKIP.
+    New option -n or --bytes.
+    Count operands now may be in octal or hex, and may be followed by a
+    size multiplier.
+
+commit c33d179ab620a88209cad033c8d6cdd6f6d09f82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:39:54 2001 +0000
+
+    (usage): Clarify.
+
+commit d7f6b143d910dd2177be966fc485e599e0a8e31a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:39:35 2001 +0000
+
+    (AM_INIT_AUTOMAKE): version 2.7.4.
+    (DEFAULT_DIFF_PROGRAM): Define to "diff", not "$bindir/diff"
+    (which didn't work anyway).
+    (AC_CHECK_MEMBERS): Add struct stat.st_blksize, struct stat.st_rdev.
+    (AC_STRUCT_ST_BLKSIZE, AC_STRUCT_ST_RDEV): Remove; obsolescent.
+    (AC_FUNC_FORK): Use this, instead of obsolescent AC_FUNC_VFORK.
+    (AC_CONFIG_FILES, AC_CONFIG_COMMANDS): Add.
+    (AC_OUTPUT): Remove args; they were obsolescent.
+
+commit a6def20a05ca209c84a26015f2a1f3fbfd2ac19b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:37:07 2001 +0000
+
+    Test version 2.7.4.
+
+commit 129a699834531edf968287ffd74798e5b0f827dd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:22:49 2001 +0000
+
+    (setup_output, begin_output, finish_output): HAVE_FORK ->
+    HAVE_WORKING_FORK || HAVE_WORKING_VFORK.
+
+commit ca059f5bfd498ae64fb81c7446cf7a2c1bca6eed
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:20:30 2001 +0000
+
+    (STAT_BLOCKSIZE): Use HAVE_STRUCT_STAT_ST_BLKSIZE, not HAVE_ST_BLKSIZE.
+    (vfork): New macro.
+    (HAVE_FORK): Remove.
+    (set_binary_mode): New macro.
+
+commit 44e0be8f0f88fc57c67ff11b15353a4fc0a21ac6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:18:51 2001 +0000
+
+    (diffpid, cleanup, main, edit): HAVE_FORK -> HAVE_WORKING_FORK ||
+    HAVE_WORKING_VFORK.
+    (main): HAVE_VFORK -> HAVE_WORKING_VFORK.
+    (edit): Reopen the temporary file after the editor has run, in case
+    the editor operates by unlinking the old file and linking a new one.
+    (P_tmpdir): Rename from PVT_tmpdir; this fixes a typo.  All uses changed.
+
+commit 5ea1938003be6f5fd5d54c9a2ef9238815aad411
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:16:21 2001 +0000
+
+    (sip, read_files): Remove tests for HAVE_SETMODE; use set_binary_mode
+    instead of setmode.
+    (sip): Fix typo in backward lseek when reverting to text mode.
+
+commit f95e035eda1ac8ff79ea16e4c8b07aa33b1ec6ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:14:44 2001 +0000
+
+    (read_diff): HAVE_FORK -> HAVE_WORKING_FORK || HAVE_WORKING_VFORK.
+
+commit 5f0e17299fb53cd6ce420320037cc0fdeed6cba0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:13:04 2001 +0000
+
+    Initial revision
+
+commit 75ea63a2d7ffde984977953d5d604e7ce73386f0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:12:06 2001 +0000
+
+    (EXTRA_DIST): Add xstrtol.c.
+    (noinst_HEADERS): Add xstrtol.h.
+    (libdiffutils_a_SOURCES): Add xstrtoumax.c.
+
+commit 98d914fc6c4fc046cd93aaa97c27faa09983c102
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:11:04 2001 +0000
+
+    <xstrtol.h>: Include.
+    (ignore_initial): Now an array with 2 elements.  All uses changed.
+    (bytes): New var.
+    (HELP_OPTION): New constant.
+    (long_options, main): Use it.
+    (long_options, option_help_msgid, main, cmp): Add support for -n or --bytes.
+    (parse_ignore_initial): New function.
+    (option_help_msgid, main): Add -i M:N.
+    (usage, main): Add two optional trailing operands, a la BSD.
+    (main): setmode -> set_binary_mode.
+    (cmp): Report byte number of what we've seen, not of the entire file.
+    This is to be consistent with the line number, which is always relative
+    with what we've seen.
+
+commit 32164584130dc9e2bd1dd5ade4df6ef9ea4fabe2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 07:43:59 2001 +0000
+
+    (main, compare_files): setmode -> set_binary_mode.
+
+commit c99680457cfd3e1c05b85593120dc3615fac8512
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 06:23:58 2001 +0000
+
+    (__xstrtol): Don't accept 'Ki'; require 'KiB'.
+
+commit cc58a4f8063c010a61ca2aedcc0e5a12d89c863c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 05:33:58 2001 +0000
+
+    (__xstrtol): Add support for IEC 60027-2.
+
+commit 770d68dc364ebbb35a1fde71766efec8c7c9792d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 15:13:04 2001 +0000
+
+    autoconf/lib/autoconf/functions.m4
+
+commit 91a8ea4b54c8f53be5394d6380f632434ad79c53
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 08:06:19 2001 +0000
+
+    (INCLUDES): Add -I../lib, for regex.h.
+
+commit 23689a884bbf814bb7fca5fff4952109f3fa00fa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:48:26 2001 +0000
+
+    Don't set LIB_CLOCK_GETTIME to 'none required'; set it to
+    the empty string instead.
+
+commit 9b53dc875732f3df331505769fc1b414591a62d7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:36:42 2001 +0000
+
+    (EXTRA_DIST): Add strtoimax.c, strtol.c.
+
+commit 10d66dc46d700293ee9484e6da522ebe278b5ee0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:30:11 2001 +0000
+
+    (SUBDIRS): Put intl before lib, so that libintl.h exists.
+
+commit 7577cc7fb6cdf08f3b6344a5ae5351b66f8ab974
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:25:31 2001 +0000
+
+    (noinst_HEADERS): Add unlocked-io.h.
+
+commit 258ce5d07b536306e19f1efda97243df66966544
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:25:09 2001 +0000
+
+    (__EXTENSIONS__): New define, for the unlocked macros.
+
+commit a443fa483a1738694bf3b677bb60355a7e151e06
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:51:21 2001 +0000
+
+    Add copyright notice.
+    Remove stuff that doesn't apply any more.
+
+commit 6c994721a7274e8cd5964fb2b65341ac3d6777cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:33:50 2001 +0000
+
+    2.7.3 news
+
+commit 96db06389fc69f0108beeffbff22770e4fc00dd4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:32:33 2001 +0000
+
+    Initial revision
+
+commit f1d11746cab0d2175dd6136249050801adb13946
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:31:33 2001 +0000
+
+    offsets -> indices for cmp
+
+commit 814c36a2c8e714f3aae096e0cc47f57ed5cb8d4c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:31:04 2001 +0000
+
+    (option_help_msgid): offsets -> indices
+
+commit 7160e82d562025f3e95aa37ca40ab56a63a2c183
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:28:48 2001 +0000
+
+    (option_help_msgid): Don't mention --binary on POSIX hosts.
+
+commit eefb9adae1642dcb0e2ac523c79998f466e94e77
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:28:17 2001 +0000
+
+    (STRIP_TRAILING_CR_OPTION): New constant.
+    (longopts, option_help_msgid, main): Add -E, --ignore-tab-expansion,
+    --strip-trailing-cr.
+
+commit bcb8f7f3527717c5c8cd2848a8c443bb442b0be2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 05:54:30 2001 +0000
+
+    Change direcategory from Utilities to GNU Packages.
+    Add individual utilities.
+    Switch to Free Documentation License.
+    @code -> @command
+    @samp -> @option
+    GNU -> @sc{gnu}
+    GNU patch version is 2.5.4.
+    Expand tabs to spaces, except when in an example that actually uses tabs.
+    Prefer @node with just one arg.
+    Document -E or --ignore-tab-expansion, --strip-trailing-cr, --ignore-file-name-case.
+    Regular expressions are now grep style, not Emacs style.
+    cmp's -c or --print-chars option is now -b or --print-bytes.
+    Time stamps now depend on LC_TIME.
+    -p now implies ^[[:alpha:]$_].
+    Flags now include ' and 0.
+    cmp -i is an alias for --ignore-initial
+    Document --from-file, --to-file.
+    Document DIFF_OPTIONS.
+
+commit 49e3b25b41c934ca6945d94de98d747fa5cc9922
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 00:22:19 2001 +0000
+
+    (AC_CHECK_FUNCS): Add gettimeofday, clock_gettime.
+    (LIB_CLOCK_GETTIME): New subst.
+
+commit b6092f7a19c7b78a5c002a3fd80d0b8b61c3ea61
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 00:21:28 2001 +0000
+
+    Assume C89 or better.
+    (_GNU_SOURCE): Remove; config.h now defines it.
+    (alloca): Declare like coreutils does it.
+    (verify, TYPE_SIGNED, TYPE_MINIMUM, TYPE_MAXIMUM, O_RDWR, S_IRUSR, S_IWUSR):
+    New macros.
+    (STAT_BLOCKSIZE): Parenthesize definiens.
+    <inttypes.h>: Include if HAVE_INTTYPES_H.
+    (CHAR_MAX, INT_MAX): Remove.
+    (PTRDIFF_MAX, SIZE_MAX): New macros.
+    (strtoumax): New decl.
+    Include stddef.h.
+    (bzero): Remove.
+    (bindtextdomain, textdomain, N_): New macros.
+    (ISPRINT, ISSPACE): Remove ifndef wrappers.
+    (ISUPPER, ISDIGIT): Remove.
+    (TOLOWER): New macro.
+    (MIN): Renamed from min; all callers changed.
+    (MAX): Likewise, from max.
+    (lin): New type.
+    (LIN_MAX): New macro.
+    (file_name_cmp): Renamed from filename_cmp.  All callers changed.
+    (file_name_lastdirchar): Renamed from file_name_lastdirchar.
+    All callers changed.
+    (could_be_mvfs_stat_bug, could_be_nfs_stat_bug, dev_may_have_duplicate_ino):
+    Remove.
+    (HAVE_SETMODE, NULL_DEVICE): New macros.
+    (same_file): Do not check attributes.
+    (same_file_attributes): New macro.
+
+commit 7cc1ca84b34554f4c4c20c69d8bba80f9cb63fa7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 00:11:23 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    int -> size_t for sizes.
+    Use angle-brackets when including quotesys.h.
+    Include error.h, regex.h, xalloc.h.
+    (message5): sizeof -> offsetof
+    (begin_output): Invoke pr without -f.
+    (lines_differ): Renamed from line_cmp, and return bool not 3-way int.
+    All callers changed.
+    Add support for IGNORE_TAB_EXPANSION.
+    (change_letter): Now an array rather than a function.  All callers changed.
+    (translate_range): Translate line numbers to long, not lin, for convenience
+    with printf.
+    (analyze_hunk): Return enum changes instead of a count of inserts and deletes.
+    All callers changed.
+    (zalloc): New function.
+
+commit babd4445b7551da0b2eb132cbb59794a80caf229
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:59:13 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+
+commit f7ea233c667071964270b985ad52f2efa53a5eb3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:56:49 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    Use angle-brackets when including getopt.h, quotesys.h.
+    Include error.h, freesoft.h, stdio.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid, option_help_msgid): Wrap in N_().
+    
+    (tmpname): Now volatile.
+    (tmpmade): Remove.
+    (tmp): New var.
+    (private_tempnam, exists, letters): Remove.
+    (temporary_file): New function.
+    (edit): Use it.
+    (interact): Use strtoumax, not atoi.
+
+commit 7a9851bed3ee069c6d78e0526c3edf6c85315dea
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:46:37 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+
+commit 420373575c3761cc50e762084400056affb968a0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:44:22 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    int -> size_t for sizes.
+    Use angle-brackets when including cmpbuf.h.
+    Include regex.h, xalloc.h.
+    (word): Remove; now done in system.h.
+    (hash_value): New type; use it instead of 'unsigned' for hash values.
+    (file_block_read): New function.
+    (sip, slurp): Use it.  Now static.
+    (sip): Ensure block size is a multiple of word size.  Clear eof flag.
+    (slurp): Use xalloc_die to report memory exhaustion.
+    (find_and_hash_each_line): Use TOLOWER instead of _tolower.
+    Add support for IGNORE_TAB_EXPANSION.
+    (prepare_text_end): Strip trailing CR if requested.
+    (find_identical_ends): Prepare the text only once, if they're duplicates.
+    Let the compiler take advantage more of the fact that the buffers are
+    word-aligned.
+    (primes): Remove.
+    (prime_offset): New var.
+    (read_var): Use prime_offset instead of primes.
+    Use zalloc instead of xmalloc + bzero.
+
+commit 9afb404ccb9b04b4a488008cb04dd262db71b52f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 20:16:15 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+    (format_group): Use strtoumax to parse line numbers.
+    (format_group, print_ifdef_lines): Use do_printf_spec to handle printf specs.
+    (groups_letter_value): Don't use _tolower; it's locale-dependent.
+    (do_printf_spec): Renamed from scan_printf_spec; now does the printing.
+
+commit 36b388a33f2cb41d622680b81d9bf0142f542424
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 20:10:42 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers (or 'long' when that's more convenient).
+    (print_ed_hunk): Fix bug when handling double-dot inserts.
+
+commit 1c2ed8ea5b7561400ef64ce60c71181d5a1f4649
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 20:08:03 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    Include error.h, exclude.h, xalloc.h.
+    
+    (dir_sort): Return 0 on error, 1 on success.  All callers changed.
+    compare_names -> compare_names_for_qsort.
+    
+    (compare_names): Try strcasecmp if ignore_file_name_case.  Then try
+    strcoll.  Use file_name_cmp only as a last resort.  Warn about
+    strcasecmp or strcoll failure.
+    (compare_names_for_qsort): New function.
+    
+    (diff_dirs): Use compare_names rather than filename_cmp.
+
+commit a54f0db411e5cc633bf739f9e644c9d8d7da9b18
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:56:07 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    Use angle-brackets when including getopt.h, quotesys.h.
+    Include error.h, freesoft.h, inttostr.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid, option_help_msgid): Wrap in N_().
+    
+    Rename the following variables for consistency with user-visible
+    option spellings.  All uses changed.
+    (text): Renamed from always_text.
+    (initial_tab): Renamed from tab_align_flag.
+    
+    (horizon_lines): Remove.  Remove all uses.
+    
+    (main): Invoke bindtextdomain and textdomain after setlocale.
+    Rename "DIFF" to "DIFF_PROGRAM".
+    
+    Try to compare file0 to file1, because this is where changes are
+    expected to come from.  Diffing between these pairs of files is more
+    likely to avoid phantom changes from file0 to file1.
+    However, use file2 as the common file if this is a 3-way diff,
+    for backward compatibility.
+    
+    (create_diff3_block): Use xcalloc instead of malloc + bzero.
+    
+    (INT_STRLEN_BOUND): Remove; now in system.h.
+    
+    (read_diff): Always use --horizon-lines=100 rather than trying to guess it.
+    Do not pass --inhibit-hunk-merge.
+    Minimum chunk size is 1, not 8KiB.
+    Use xalloc_die to report memory exhaustion.
+    (undotlines): Use long for start, not int.
+
+commit 2efe295eb51b9c02594a473d0d55b0ea8fe599c0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:29:55 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    Don't include regex.h.
+    (enum changes): New enum.
+    (enum line_class): Remove; subsumed by enum changes.
+    (enum output_style): New constant OUTPUT_UNSPECIFIED.
+    
+    (ignore_space_change_flag, ignore_all_space_flag): Remove.
+    (ignore_white_space): New decl, subsuming the above two.  All uses changed.
+    
+    Rename the following decls for consistency with user-visible
+    option spellings.  All uses changed.
+    (text): Renamed from always_text_flag.
+    (ignore_blank_lines): Renamed from ignore_blank_lines_flag.
+    (ignore_case): Renamed from ignore_case_flag.
+    (brief): Renamed from no_details_flag.
+    (initial_tab): Renamed from tab_align_flag.
+    (expand_tabs): Renamed from tab_expand_flag.
+    (starting_file): Renamed from dir_start_file.
+    (paginate): Renamed from paginate_flag.
+    (sdiff_merge_assist): Renamed from sdiff_help_sdiff.
+    (left_column): Renamed from sdiff_left_only.
+    (suppress_common_lines): Renamed from sdiff_skip_common_lines.
+    (speed_large_files): Renamed from heuristic.
+    (minimal): Renamed from no_discards.
+    
+    (inhibit_hunk_merge): Remove.
+    
+    (strip_trailing_cr, excluded, time_format): New decls.
+    
+    (files_can_be_treated_as_binary): Renamed from ignore_some_changes.
+    
+    (group_format, line_format): Now char const *[], not char *[].
+    
+    (struct file_data): Buffer is now word*, not char*, as it's always
+    aligned and this can help the compiler.  buffered_chars -> buffered
+    (since it's a byte count, not a char count).  All uses changed.
+    New member `eof'.
+    
+    (FILE_BUFFER): New macro.
+    
+    (excluded_filename, error, free_software_msgid): Remove decls; now in
+    other .h files.
+    
+    (sip, slurp): Remove decls.
+    (file_block_read): New decl.
+    (change_letter): Now an array, not a function.
+    (lines_differ): Renamed from line_cmp.
+    (analyze_hunk): Now returns enum changes rather than two change counts.
+
+commit d7f8501f5336632c5213b4bab9a44c26523b1b11
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:12:49 2001 +0000
+
+    (diff_LDADD): New symbol.
+
+commit 2e8641a5e5c62be99544041e777c1a73dc34a16f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:10:43 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    long -> off_t for line numbers.
+    Use angle-brackets when including getopt.h, fnmatch.h, quotesys.h.
+    Include error.h, exclude.h, freesoft.h, hard-locale.h, prepargs.h,
+    regex.h, signal.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid, option_help_msgid): Wrap in N_().
+    
+    Rename the following variables for consistency with user-visible
+    option spellings.  All uses changed.
+    (binary): Renamed from binary_flag.
+    (new_file): Renamed from entire_new_file_flag.
+    (unidirectional_new_file): Renamed from unidirectional_new_file_flag.
+    (report_identical_files): Renamed from print_file_same_flag.
+    
+    (numeric_arg): Remove.
+    
+    (exclude, exclude_alloc, exclude_count, excluded_filename, add_exclude,
+    add_exclude_file):
+    Remove; now done by exclude.h.
+    
+    (BINARY_OPTION, FROM_FILE_OPTION, HELP_OPTION, HORIZON_LINES_OPTION,
+    IGNORE_FILE_NAME_CASE_OPTION, INHIBIT_HUNK_MERGE_OPTION,
+    LEFT_COLUMN_OPTION, LINE_FORMAT_OPTION, NORMAL_OPTION,
+    SDIFF_MERGE_ASSIST_OPTION, STRIP_TRAILING_CR_OPTION,
+    SUPPRESS_COMMON_LINES_OPTION, TO_FILE_OPTION,
+    UNCHANGED_LINE_FORMAT_OPTION, OLD_LINE_FORMAT_OPTION,
+    NEW_LINE_FORMAT_OPTION, UNCHANGED_GROUP_FORMAT_OPTION,
+    OLD_GROUP_FORMAT_OPTION, NEW_GROUP_FORMAT_OPTION,
+    CHANGED_GROUP_FORMAT_OPTION): New constants.
+    (longopts, main): Use them.
+    
+    (longopts, main, option_help_msgid): Add -E, --from-file, --to-file.
+    
+    (main): Invoke bindtextdomain and textdomain after setlocale.
+    Use grep syntax, not Emacs, for regular expressions.
+    Use exclude.h, not our own functions.
+    Use ISO 8601 time format in hard locales.
+    Prepend DIFF_OPTIONS.
+    Don't update ignore_some_changes.
+    Use strtoumax instead of numeric_arg.
+    Use specify_value when appropriate.
+    error -> try_help when appropriate.
+    -p now means ^[[:alpha:]$_], not ^[_a-zA-Z$].
+    Ignore --inhibit-hunk-merge.
+    Prefer changed group formats to unchanged ones.
+    Remove now-unnecessary casts.
+    Set files_can_be_treated_as_binary.
+    
+    (specify_value): Renamed from specify_format.  All uses changed.
+    
+    (specify_style): Default is now unspecified, not normal.  All uses changed.
+    
+    (set_mtime_to_now): New function.
+    (compare_files): Use it.  Use memset, not bzero.
+    Set stdin mtime to current time even when stdin is not a regular file.
+    Check for same file attributes, as well as for same file.
+    Use files_can_be_treated_as_binary.
+    "write failed" -> "standard output on output failure.
+
+commit d96c04ee417716da551c9af5ff9da185536d4557
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 14:34:53 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+    Include inttostr.h, regex.h.
+    (TIMESPEC_NS): New macro.
+    (nstrftime): New decl.
+    (print_context_label): Use nstrftime and time_format to format times.
+    Print numeric time stamp value if localtime fails.
+    (print_context_function): New function.
+    (pr_context_hunk, pr_unidiff_hunk): Use it.
+    (find_function): Use size_t for sizes, not int.
+
+commit 4de1d68d32189b44d363b3c43d77eef81b184df5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 14:16:12 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    long -> off_t for line numbers.
+    Use angle-brackets when including cmpbuf.h, getopt.h.
+    Include error.h, freesoft.h, inttostr.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid): Wrap in N_().
+    (buffer): Now word*, not char*.  All uses changed.
+    (word): Remove macro; now in system.h.
+    (long_options, option_help_msgid, main): -c --print-chars -> -b --print-bytes
+    (check_stdout): "write failed" -> "standard output"
+    (option_help_msgid): Wrap in N_().
+    (main): Invoke bindtextdomain and textdomain after setlocale.
+    Use strtoumax instead of doing the work ourselves.
+    Check for same_file_attributes as well as same_file.
+    (cmp): Use ssize_t for read returns, not size_t.
+    Do not assume that size_t is not narrower than int.
+    Do not assume that line numbers fit in 'long'.
+    (block_compare_and_count, block_compare):
+    Compiler now checks that buffers are word-aligned.
+    (block_compare_and_count): Count sizes with size_t, not long.
+    (sprintc): byte arg is unsigned char, not unsigned.
+
+commit dd1268672597e935cdd910f1adf731dc4bd3e6f1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 13:51:07 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+    int -> bool for booleans.
+    unsigned int -> size_t for sizes.
+    Use angle-brackets when including cmpbuf.h.
+    Include error.h, regex.h, xalloc.h.
+    (discard_confusing_lines, diff_2_files): Use zalloc rather than xalloc+bzero.
+    (discard_confusing_lines): unsigned int -> lin for values that are really
+    line numbers.
+    (shift_boundaries): Do not inhibit hunk merges.
+    (build_reverse_script, build_script, diff_2_files): Use |, not ||, for speed.
+    (diff_2_files): no_details_flag & ~ignore_some_changes ->
+    files_can_be_treated_as_binary.  Esure that buffer size is a multiple
+    of sizeof (word).  Use file_block_read to read buffers.
+    (diff_2_files): Abort if output style is not one of the expected styles.
+
+commit a821b5602b040227ab71a2638dca2253fb6da5c1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 18:44:41 2001 +0000
+
+    Initial revision
+
+commit f78da6466e7b2d77de2a4214fe83985ee5b7e6e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:28:32 2001 +0000
+
+    Initial revision
+
+commit 22af62a5678ea705380884bef4ec43e82e65db63
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:25:01 2001 +0000
+
+    (jm_PREREQ_READUTMP): Remove, as it gives autoheader the willies.
+
+commit cd1a913b43413da87860f557a094c398744a9e2c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:04:25 2001 +0000
+
+    Include config.h, freesoft.h rather than diff.h.
+    (free_software_msgid): Wrap contents in N_.
+
+commit e28790892e335a412aff01934a37a3a2768c1dbb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:02:42 2001 +0000
+
+    Use prototypes instead of old-style functions.
+
+commit 33d72d80bc0ccc713ba39768ef102c6dc7904074
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:02:08 2001 +0000
+
+    Don't include system.h; instead, include config.h, unistd.h.
+    Use prototypes instead of old-style functions.
+    (block_read): Don't assume that int is no wider than size_t.
+
+commit e48d1026c5f76e1795ebec078167a6c651f0fa16
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 08:05:29 2001 +0000
+
+    Initial revision
+
+commit 8b1cfebb78c02f55f91d229ecceef4284957f6db
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:54:35 2001 +0000
+
+    Define filename_cmp as an object-like macro, not as a function-like
+    macro.
+
+commit da34f9fc343796c6025e60a8f5726604d9a34b74
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:52:27 2001 +0000
+
+    Always operate in the C locale.
+    Set AWK using a method that works even with broken shells.
+
+commit abb43c1f76f48e45fcabe330a503a62eaa117db7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:46:59 2001 +0000
+
+    (AC_INIT): Use src/diff.c, not diff.h, as the source files got removed.
+    (AM_CONFIG_HEADER): Switch from AC_CONFIG_HEADER.
+    (AC_ARG_PROGRAM, AC_MINIX): Remove.
+    
+    (AC_PREREQ, AM_INIT_AUTOMAKE, ALL_LINGUAS, AC_PROG_AWK,
+    AM_PROG_CC_STDC, AC_PROG_RANLIB, AC_C_INLINE, AC_C_VARARRAYS,
+    DEFAULT_DIFF_PROGRAM, DEFAULT_EDITOR_PROGRAM, AC_STRUCT_ST_MTIM_NSEC): Add.
+    
+    (PR_PROGRAM): AC_DEFINE.
+    
+    (AC_SYS_LARGEFILE): Use instead of our homebrew version.
+    
+    (_GNU_SOURCE): Define if not defined.
+    
+    (AC_CHECK_HEADERS): Add stdbool.h, unistd.h.
+    (AC_CHECK_TYPES): Add ptrdiff_t, uintmax_t.
+    (AM_GNU_GETTEXT, XGETTEXT): Add.
+    
+    (WITH_MVFS_STAT_BUG, WITH_NFS_STAT_BUG): Remove.
+    (HAVE_MEMCHR): Remove.
+    (AC_CHECK_FUNCS): Add diraccess.
+    (AC_REPLACE_FUNCS): Add memchr, waitpid.
+    (jm_FUNC_GLIBC_UNLOCKED_IO, jm_FUNC_GNU_STRFTIME, jm_FUNC_MALLOC,
+     jm_FUNC_REALLOC, jm_PREREQ_ERROR, jm_PREREQ_QUOTEARG, jm_PREREQ_REGEX,
+     jm_PREREQ_TEMPNAME, jm_AC_PREREQ_XSTRTOUMAX, AC_FUNC_FNMATCH): Add.
+    (fnmatch.h, regex.h): Do not create these files unless we're using
+    our own fnmatch and regex.
+    (AC_OUTPUT): Add doc/Makefile, intl/Makefile, lib/Makefile, lib/posix/Makefile,
+    m4/Makefile, po/Makefile.in, src/Makefile.
+
+commit 851e78757601f74100d920fa8d1861e150309cd6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:12:27 2001 +0000
+
+    Don't translate "program" to "programme".
+
+commit 64c1b907e37d9f2eb9af94e5c2a4fec4ed1be624
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 20 19:05:44 2001 +0000
+
+    Initial revision
+
+commit 0b795bef12137f5ea8d0a7771581bf7eda28f314
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 20 05:34:44 2001 +0000
+
+    Initial revision
+
+commit 8e78630e376e1d8ed311a2bd11be0a7215efde0d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 4 01:21:33 2001 +0000
+
+    Initial revision
+
+commit 8a650ddd00a9c5130a0b67199d5578b845fee1e4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 27 00:37:40 2001 +0000
+
+    Initial revision
+
+commit ce4ac3d8f5bcfcc73e260bb5754b56ec56a1b313
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 22 08:00:19 2001 +0000
+
+    Initial revision
+
+commit 5e0ab37d1b54802075c6919eb0183a18cf3817d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 29 01:15:42 2001 +0000
+
+    Initial revision
+
+commit 37788019c290ff31f902f64fdb6b405ea0f95408
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 23 17:25:08 2001 +0000
+
+    Initial revision
+
+commit 8a81b851d53c92e845961a2881ed3d8a725064d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 12 17:11:46 2001 +0000
+
+    Initial revision
+
+commit ecad5d7b24b4bcc21f3275d2d1bb011727cfb3b6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jul 15 14:31:54 2001 +0000
+
+    Initial revision
+
+commit 688ab06db171f210dbe73dbef43bb2148e5de15f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jul 7 04:55:38 2001 +0000
+
+    Initial revision
+
+commit 42bf2924b081cda528bca0aba18d49aa983e9ed5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jul 6 04:44:39 2001 +0000
+
+    Initial revision
+
+commit 7109958ae4875dd0534e4de888a885114cc4e270
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 2 08:26:15 2001 +0000
+
+    Initial revision
+
+commit 4dcf610052023fc1b821cf6850a76327e44874cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jan 26 11:13:28 2001 +0000
+
+    Initial revision
+
+commit eb477ba9451eef62e9344ca64c0c6f072e83bc3f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 31 07:09:56 2000 +0000
+
+    Initial revision
+
+commit 0090fd30f97f695e18708ddd6c3a34c9f8e6837b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 7 15:48:18 2000 +0000
+
+    Initial revision
+
+commit 9825e0bef52904997b438ba9aac33848071574b9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 6 06:57:20 2000 +0000
+
+    From GCC repository
+
+commit 39a0766fcd5481d35e2caf3e779618353ed63469
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 12 02:27:20 1998 +0000
+
+    (lf_snarf): Fix bug when help line wrapped around the input buffer.
+
+commit 4ecee655a20f0db1be9477096f22786959b6578e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 15 22:34:53 1998 +0000
+
+    Add dircategory.
+
+commit 5c5dfca096877631f67a2a06f324beaf52b36939
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 07:27:17 1998 +0000
+
+    Include <config.h> before using "const".
+
+commit df0836e08976e3e58f6aa8420efec13d48433cca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:59:43 1998 +0000
+
+    ($D.tar.gz): Don't use ln to create distribution; it doesn't
+    work with symlinks.
+
+commit 19db0feae5268084abeabb97a96f8b3a6d102dba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (AC_PATH_PROG): Add PR_PROGRAM.
+    If available, prefer support for large files unless the user specified
+    one of the CPPFLAGS, LDFLAGS, or LIBS variables.
+    (AC_STRUCT_ST_RDEV): Add.
+    (HAVE_ST_FSTYPE_STRING): Add.
+    (--with-mvfs-stat-bug, --with-nfs-stat-bug): New options.
+    (HAVE_MEMCHR): New macro.
+    (AC_CHECK_FUNCS): Add sicprocmask.
+
+commit eb6efbf9c67a01ee7317df4ebe2db3a139920ea4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Add --with-mvfs-stat-bug, --with-nfs-stat-bug.
+
+commit 88507c4fc146befc67d9909e1b6b2c2c00dba635
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (quotesys.h): Include.
+    (PR_PROGRAM): New macro.
+    (pfatal_with_name): Abort if error returns.
+    (fatal): Likewise.
+    (print_message_queue): Free message chain after printing.
+    (currently_recursive): Renamed from current_depth, and now a boolean.
+    (begin_output): Report error if fflush does.
+    Avoid stdio and gettext in child.
+
+commit bc79aedec85808753e4d51323e2385fb1c13d7d0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (__attribute__): New macro.
+    (getenv): Don't declare if HAVE_STDLIB_H.
+    (CHAR_MAX): New macro.
+    (<locale.h>): New include.
+    (<locale.h>): Include before <libintl.h>.
+    (could_be_mvfs_stat_bug, could_be_nfs_stat_bug, dev_may_have_duplicate_ino,
+    same_special_file): New macros.
+    (same_file): Use them.
+
+commit 65e8fe11693ff0748df573053a1270e97ed09a8a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (print_half_line): Add brackets to pacify GCC -Wall.
+
+commit e72388acbd0fc8f3619e56cca431984fa571d01f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (quotesys.h): Include.
+    (DIFF_PROGRAM, DEFAULT_EDITOR_PROGRAM): Remove.
+    (free_software_msgid, editor_program, not_found): New vars.
+    (diffbin, edbin): Remove.
+    (editor_program): Renamed from edbin.
+    (edit, interact): Now take extra string arg.
+    (exiterr, fatal, perror_fatal, try_help): Add noreturn attribute.
+    (sigset_t, sigemptyset, sigmask, sigaddset, SIG_BLOCK, SIG_SETMASK):
+    (sigprocmask): New macros, if !HAVE_SIGPROCMASK.
+    (error): Now has printf attribute.
+    (longopts, main): Don't assume ASCII.
+    (try_help): New operand arg.
+    (usage): Conform to new GNU standards.
+    (main): Set static vars for editor and diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v conforms to new GNU standard.
+    Complain better about extra and missing operands.
+    If HAVE_VFORK, block SIGINT and SIGPIPE in the parent, since when
+    the child munges its handlers it may somp on the parent.
+    Pass rname to intract.
+    Translate not-found message before forking.
+    (give_help): Just output it all at once.
+    (edit): New args lname, lline, rname, rline.
+    (edit): New command 'd'.
+    (interact): New args lname, rname.
+
+commit f00d3f0a665703921f746d541d909446f1a4160e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Update FSF address.
+
+commit d81d5f9e6cb8931c2afc616fad19d0df85721b90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (cmpbuf.h): Include.
+    (slurp): Check for arithmetic overflow when computing buffer size.
+
+commit a1bec6ce6450cc45f4ff44b66ecb463c1a4352b4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Remove `#if 0'ed code.
+
+commit f2ca3a82c2205ac873d4413badad64db9bf36589
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (diff_dirs): Check for recursive directory loop.
+    Arg is now struct comparison const *.
+    (dir_loop): New function
+
+commit fd90a378218ee0687187ba44800af2ad76373d2e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (quotesys.h): Include.
+    (free_software_msgid): New decl.
+    (RANGE_START, RANGE_END): Renamed from START and END.
+    (fatal, perror_with_exit, try_help): Add noreturn attribute.
+    (error): Add printf attribute.
+    (diff_program): Now a ptr, not an array.  Initialize to DEFAULT_DIFF_PROGRAM
+    instead of DIFF_PROGRAM.
+    (longopts, main): Don't assume ASCII.
+    (main): Use DIFF environment var to specify name of diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v now reports version according to new GNU standard.
+    Report spelling of extra operand, or last operand before missing one.
+    (try_help): Now takes operand arg.
+    (option_help_ms): Fix typo: missing comma.
+    (usage): Update as per current GNU standards.
+    (environ): Remove decl.
+    (read_diff): Invoke diff with --inhibit-hunk-merge.
+    Translate `not found' message before forking.
+    Quote name of diff program.
+    Pass horizon lines.
+    `memory exhausted' -> `Memory exhausted'
+
+commit bad331bf32f5a812007ef5400b675f19507fc03a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (XTERN): Renamed from EXTERN.
+    (struct filedata): Remove dir_p arg.
+    (struct comparison): New type.
+    (diff_2_files, diff_dirs)" Ise ot/
+    (error): Add printf attribute if applicable.
+    (free_software_msgid): New decl.
+    (pr_program): New decl.
+    (fatal): Add noreturn attribute.
+    (pfatal_with_name): Likewise.
+
+commit b2bbf871e71760e99cdf6cb2d50a274840ad5930
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (authorship_msgid): New var.
+    (quotesys.h): Include.
+    (ck_atoi): Remove.
+    (function_regexp_list, ignore_regexp_list): Now static.
+    (binary_flag): Renamed from binary_I_O.
+    (entire_new_file_flag, unidirectional_new_file_flag, print_file_same_flag):
+    Now static.
+    (numeric_arg): Renamed from ck_atoi.
+    New argument specifying the argument type.
+    (longopts, main): Don't assume ASCII.
+    (longopts): Remove old aliases --file-label, --entire-new-file, --ascii,
+    --print.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Use numeric_arg to report errors.
+    Report error if -l specified but pagination is not supported.
+    Report error if -S is specified twice with conflicting values.
+    Have --version conform to the new GNU standards.
+    Add new --from-file, --to-file, --inhibit-hun,-merge options.
+    Make the horizon at least as large as the context.
+    Add casts to pacify gcc -Wall.
+    (try_help): Add operand arg.
+    (option_help_msgid): Doc fix to match above.
+    (usage): Indent option_help_msgid.
+    (compare_files): Now takes struct comparison
+    instead of two directory names and a depth.
+    (NONEXISTENT, UNOPENED, ERRNO_ENCODE, ERRNO_DECODE):
+    New macros.
+    (DIR_P): New macro.
+    Report error if fflush does.
+
+commit cd804a4efe27ad94e18a34b50d3cde70e1c0b4c0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Fix spacing.
+
+commit 563686fcd98c79e3c73d729e87da072ec9ad7fa7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (authorship_msgid): New var.
+    (free_software_msgid): New decl.
+    (error): Now has printf attribute.
+    (try_help): Likewise.
+    (long_options): Don't assume ASCII.
+    (try_help): Now accepts operand arg.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Report --ignore-initial value when complaining about it.
+    Output copyright and free software info with -v.
+    Don't assume ASCII.
+    Report last operand when one is missing.
+    Report text of extra operand.
+    Move block_read into cmpbuf.c.
+
+commit f1c356747f2a2969055ef6770d5c9bbbbed99291
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Document recent changes.
+    The patch doc still corresponds to patch 2.2, unfortunately.
+    Update GNU bug reporting address.  Omit Larry Wall's address;
+    it's obsolete and he's busy with perl.
+
+commit ddbaec7810f5ca4b230e5708d54d4514ab712273
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Fix copyright.
+
+commit ee7817ee7f07dcf291f05f9797df7bd292c02b32
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (DEFAULT_DIFF_PROGRAM): Renamed from DIFF_PROGRAM.
+    (PR_PROGRAM): All `configure' to define it.
+    (srcs): Add $(diffutils_srcs), freesoft.c, quotearg.c instead of quote.c,
+    quotearg.h.
+    (distfiles): Add acconfig.h, message/*.
+    (all): Depend on $(destfiles), not info.
+    (version.c): Parenthesize `GNU diffutils'.
+    (common_o): Add freesoft.o
+    (diff_o): quote.o -> quotearg.o
+    (diff3_o, sdiff_o): Likewise.
+    (diff.dvi): Depend on version.texi.
+    (diff.o diff3.o quotearg.o sdiff.o util.o): New dependency on quotearg.h
+    (diff3.o): DIFF_PROGRAM -> DEFAULT_DIFF_PROGRAM.
+    (sdiff.o): Likewise.
+    (messages.po): Remove.
+    (message/msgid.po, message/template.po): New rules.
+    (maintainer-clean): Renamed from realclean.
+    (install): Install from source directory, if applicable.
+    Invoke install-info if needed.
+    (install-strip): New rule.
+    (check): Set DIFF.
+    (stamp-h.in): Don't put the date into the timestamp.
+    (D_dirs): Add $D/message.
+    ($D.tar.gz): Compress with gzip -9.
+    (srcs, distfiles, diff_o, diff3_o, sdiff_o): Rename quotearg.c to
+    quotesys.c and quotearg.h to quotesys.h.
+
+commit 8a60489fa41523137624aeef82c6bd353a8a4ea9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (same_file): Add.
+
+commit 40a2ed14d8c92b5859472b0034a31bbe0bec7a5c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    Don't alter PROGRAMS.
+
+commit 7a3d2137801b5848c56cc36fa151393342b0faf8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    Update FSF address.
+    (quote_system_arg): Renamed from system_quote_arg.
+
+commit ddf93d23968097487ae48fa72c3bb87e250afdc7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (DEFAULT_DIFF_PROGRAM): Renamed from DIFF_PROGRAM.
+    When editing mkinstalldirs rule, look for exec_prefix and prefix.
+    Add .exe when installing files.
+
+commit 822edd195b0e0d752a032c171ea17fb949a25953
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (%.exe): Remove.
+    (pc-clean): Remove *.exe
+
+commit 03bd647315af7369818dbdc533e5e7ad2f71d8b4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (same_file): Remove.
+
+commit 6e9a130189c23ea1f75fd1cfe52be084e9d6957f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:26:54 1998 +0000
+
+    Initial revision
+
+commit 877cbd3f3a05e5f29cc0934a5cb57e14cd20279a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:25:27 1998 +0000
+
+    Add copyright date and update FSF address.
+
+commit 9703835363fa00fe91fbda23a565c6dd57e03a77
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:22:05 1998 +0000
+
+    (diff_dirs): Check for recursive directory loop.
+    Arg is now struct comparison const *.
+    (dir_loop): New function
+
+commit 15cb246458767a925a974aa2292ec3a41eecf469
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 23:17:39 1998 +0000
+
+    Initial revision
+
+commit 064482a2366d06a1b299c26cb6f1dd7001e1d7d5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Add --with-mvfs-stat-bug, --with-nfs-stat-bug.
+
+commit 27d11e852fec1a55420b928e75ba2cc3012ab5f1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (quotearg.h): Include.
+    (PR_PROGRAM): New macro.
+    (pfatal_with_name): Abort if error returns.
+    (fatal): Likewise.
+    (print_message_queue): Free message chain after printing.
+    (currently_recursive): Renamed from current_depth, and now a boolean.
+    (begin_output): Report error if fflush does.
+    Avoid stdio and gettext in child.
+
+commit 79532e867d0bd3f4653600485cd24b00eeed99a1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (__attribute__): New macro.
+    (getenv): Don't declare if HAVE_STDLIB_H.
+    (CHAR_MAX): New macro.
+    (<locale.h>): New include.
+    (<locale.h>): Include before <libintl.h>.
+    (could_be_mvfs_stat_bug, could_be_nfs_stat_bug, dev_may_have_duplicate_ino,
+    same_special_file): New macros.
+    (same_file): Use them.
+
+commit 7571701a555b3cf0865f496ba5c46b5a09dc12c6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (print_half_line): Add brackets to pacify GCC -Wall.
+
+commit 8e6e1bd3ac438d54c8ee50f34674e051f676fa82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (quotearg.h): Include.
+    (DIFF_PROGRAM, DEFAULT_EDITOR_PROGRAM): Remove.
+    (free_software_msgid, editor_program, not_found): New vars.
+    (diffbin, edbin): Remove.
+    (editor_program): Renamed from edbin.
+    (edit, interact): Now take extra string arg.
+    (exiterr, fatal, perror_fatal, try_help): Add noreturn attribute.
+    (sigset_t, sigemptyset, sigmask, sigaddset, SIG_BLOCK, SIG_SETMASK):
+    (sigprocmask): New macros, if !HAVE_SIGPROCMASK.
+    (error): Now has printf attribute.
+    (longopts, main): Don't assume ASCII.
+    (try_help): New operand arg.
+    (usage): Conform to new GNU standards.
+    (main): Set static vars for editor and diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v conforms to new GNU standard.
+    Complain better about extra and missing operands.
+    If HAVE_VFORK, block SIGINT and SIGPIPE in the parent, since when
+    the child munges its handlers it may somp on the parent.
+    Pass rname to intract.
+    Translate not-found message before forking.
+    (give_help): Just output it all at once.
+    (edit): New args lname, lline, rname, rline.
+    (edit): New command 'd'.
+    (interact): New args lname, rname.
+
+commit aa33c53a5189298c2a8472dc6ccf9bab1ff0b5bc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Update FSF address.
+
+commit c275147038536345976081c670b095fb030e86c5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (cmpbuf.h): Include.
+    (slurp): Check for arithmetic overflow when computing buffer size.
+
+commit a3349dc5c0641e7057981f35ae49e321f157e4ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Remove `#if 0'ed code.
+
+commit 0972f1796deefe04b688322397f930f9216adbe8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (quotearg.h): Include.
+    (free_software_msgid): New decl.
+    (RANGE_START, RANGE_END): Renamed from START and END.
+    (fatal, perror_with_exit, try_help): Add noreturn attribute.
+    (error): Add printf attribute.
+    (diff_program): Now a ptr, not an array.  Initialize to DEFAULT_DIFF_PROGRAM
+    instead of DIFF_PROGRAM.
+    (longopts, main): Don't assume ASCII.
+    (main): Use DIFF environment var to specify name of diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v now reports version according to new GNU standard.
+    Report spelling of extra operand, or last operand before missing one.
+    (try_help): Now takes operand arg.
+    (option_help_ms): Fix typo: missing comma.
+    (usage): Update as per current GNU standards.
+    (environ): Remove decl.
+    (read_diff): Invoke diff with --inhibit-hunk-merge.
+    Translate `not found' message before forking.
+    Quote name of diff program.
+    Pass horizon lines.
+    `memory exhausted' -> `Memory exhausted'
+
+commit 812d24c69ab194c30ca7d41eba95a06398217be1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (XTERN): Renamed from EXTERN.
+    (struct filedata): Remove dir_p arg.
+    (struct comparison): New type.
+    (diff_2_files, diff_dirs)" Ise ot/
+    (error): Add printf attribute if applicable.
+    (free_software_msgid): New decl.
+    (pr_program): New decl.
+    (fatal): Add noreturn attribute.
+    (pfatal_with_name): Likewise.
+
+commit 9a57dd54d693952dc3f63ed8baaf99f2fb695132
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (authorship_msgid): New var.
+    (quotearg.h): Include.
+    (ck_atoi): Remove.
+    (function_regexp_list, ignore_regexp_list): Now static.
+    (binary_flag): Renamed from binary_I_O.
+    (entire_new_file_flag, unidirectional_new_file_flag, print_file_same_flag):
+    Now static.
+    (numeric_arg): Renamed from ck_atoi.
+    New argument specifying the argument type.
+    (longopts, main): Don't assume ASCII.
+    (longopts): Remove old aliases --file-label, --entire-new-file, --ascii,
+    --print.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Use numeric_arg to report errors.
+    Report error if -l specified but pagination is not supported.
+    Report error if -S is specified twice with conflicting values.
+    Have --version conform to the new GNU standards.
+    Add new --from-file, --to-file, --inhibit-hun,-merge options.
+    Make the horizon at least as large as the context.
+    Add casts to pacify gcc -Wall.
+    (try_help): Add operand arg.
+    (option_help_msgid): Doc fix to match above.
+    (usage): Indent option_help_msgid.
+    (compare_files): Now takes struct comparison
+    instead of two directory names and a depth.
+    (NONEXISTENT, UNOPENED, ERRNO_ENCODE, ERRNO_DECODE):
+    New macros.
+    (DIR_P): New macro.
+    Report error if fflush does.
+
+commit 1a50d285b938342ab331b10f7f05bd22f6502982
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Fix spacing.
+
+commit 0aa5e6a1bc202f333432c3a4ec2d2b65e1b01a29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (authorship_msgid): New var.
+    (free_software_msgid): New decl.
+    (error): Now has printf attribute.
+    (try_help): Likewise.
+    (long_options): Don't assume ASCII.
+    (try_help): Now accepts operand arg.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Report --ignore-initial value when complaining about it.
+    Output copyright and free software info with -v.
+    Don't assume ASCII.
+    Report last operand when one is missing.
+    Report text of extra operand.
+    Move block_read into cmpbuf.c.
+
+commit fe73cbbe5d4520bc1c6b7e0d177c5911ff91b00c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (no_discards): Remove.
+    (inhibit): Remove.
+    (shift_boundaries): Don't inhibit.  If inhibit_hunk_merge is nonzero,
+    don't merge hunks.
+    (briefly_report): Now returns 2 if trouble, CHANGES otherwise.
+    (diff_2_files): Now takes struct comparison.  If briefly_report reports
+    trouble, pass it on to caller.
+
+commit f618b639bd9d535a8c38a471b8cea0e7a52f91e0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (block_read): New decl.
+
+commit c8cc5a397c65806860a5043d55373d58db7ae9e4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (block_read): Moved here from cmp.c.
+
+commit 227301f86a65a121bd18437a610955db7480888b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Document recent changes.
+    patch is still only patch 2.2, unfortuantely.
+
+commit 28adfd739abc97634b84ef6f74575e8deac2dc06
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:18:48 1998 +0000
+
+    Mention --from-file=FILE, --to-file=FILE, ed.
+
+commit dcb0b57294bac8d23515770abdee4b3e00b92103
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:18:48 1998 +0000
+
+    (DEFAULT_DIFF_PROGRAM): Renamed from DIFF_PROGRAM.
+    (PR_PROGRAM): All `configure' to define it.
+    (srcs): Add $(diffutils_srcs), freesoft.c, quotearg.c instead of quote.c,
+    quotearg.h.
+    (distfiles): Add acconfig.h, message/*.
+    (all): Depend on $(destfiles), not info.
+    (version.c): Parenthesize `GNU diffutils'.
+    (common_o): Add freesoft.o
+    (diff_o): quote.o -> quotearg.o
+    (diff3_o, sdiff_o): Likewise.
+    (diff.dvi): Depend on version.texi.
+    (diff.o diff3.o quotearg.o sdiff.o util.o): New dependency on quotearg.h
+    (diff3.o): DIFF_PROGRAM -> DEFAULT_DIFF_PROGRAM.
+    (sdiff.o): Likewise.
+    (messages.po): Remove.
+    (message/msgid.po, message/template.po): New rules.
+    (maintainer-clean): Renamed from realclean.
+    (install): Install from source directory, if applicable.
+    Invoke install-info if needed.
+    (install-strip): New rule.
+    (check): Set DIFF.
+    (stamp-h.in): Don't put the date into the timestamp.
+    (D_dirs): Add $D/message.
+    ($D.tar.gz): Compress with gzip -9.
+
+commit 78a974475e68eda02deab1e542c1561c23966a23
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:18:48 1998 +0000
+
+    Initial revision
+
+commit bf49f4aa398f198b2715a17ac2f7a90a8e13c575
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jan 3 18:53:37 1995 +0000
+
+    Define filename_cmp to stricmp (again).
+
+commit 19aa2d3c918d10bd29d80d01c8dff75d314fb84a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 10 16:46:49 1994 +0000
+
+    Adjust to emx 0.9a.
+    A few compiler options have changed, and gnuregex.dll should have been
+    stripped.
+
+commit 2fb829677f3540677513e3a86b95709147cbc52c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 10 16:42:51 1994 +0000
+
+    Adjust to emx 0.9a.
+
+commit aa8b128119182543a724dfe62c3f44aa5f47ad33
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 27 06:30:14 1994 +0000
+
+    Adjust to latest patch from eliz.
+
+commit c0a49f9f369d12183c53336dece8496422d17205
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 06:24:09 1994 +0000
+
+    (PACKAGE, VERSION, diffutils_srcs, D): New vars.
+    (version.c, version.texi, messages.po): New files.
+    messages.po is built automatically from source files and `getmsgids'.
+    Each function and macro whose first parameter is a gettext msgid
+    has had its first parameter's name changed so it ends in `msgid'.
+    All arrays of msgids have had their names changed to end in `msgid'.
+    `getmsgids' uses this to determine which strings are msgids.
+    All strings that are messages are passed through gettext once before
+    being used, so that they can be localized.
+    Several diagnostics have been changed slightly, to make them more consistent
+    and easier to translate.
+    (distfiles): Add them, pc/*, and getmsgids.
+    (diff.info): Now depends on version.texi.
+    (realclean): Clean messages.po, version.*.
+    (dist): Just build $D.tar.gz.
+    ($D.tar.gz): New file, takes over old `dist' function.
+    Don't assume $(distfiles) are all in same directory.
+
+commit 45db00459e6f2963a02ca721c7ade0393d2c7a90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:25:53 1994 +0000
+
+    Clean messages.po, too.
+
+commit a6bbb288b23575ef0d0334d78761e63f7f94b5b2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (AC_CHECK_HEADERS): Add libintl.h, locale.h.
+    (AC_CHECK_LIB): Check for -lintl.
+
+commit 5ce0e7349f49068f794c064023324fed1292442a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    2.7.1 alpha news
+
+commit 993d9f48b184bc387fc3df2a0034d10cc77aaaa9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (struct msg, message5, print_message_queue): Allocate just one block of memory
+    to save a messsage.
+
+commit 74674f3e03eaeb72158692b229d8ed49416d55dc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (gettext): Declare; use a stub if ! HAVE_LIBINTL_H.
+    (setlocale): Declare; use a stub if ! HAVE_LOCALE_H.
+
+commit caf01e2fb9559d2643a43f279e4d66bab0deb553
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (version_string): Fix typo in declaration: `const' was missing.
+    (option_help_msgid, help_msgid): New constant.
+    (usage, give_help): Use them, so message is translated one option at a time.
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    (trapsigs): Ignore sigaction failure, to be compatible with `signal'.
+
+commit a0d1e40b965340856a1a07e3adceeeae380d4cd9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    (option_help_msgid): New constant.
+    (usage): Use it, so message is translated one option at a time.
+
+commit 893aeeb7e0234f11f9153b365f785fcadfc271d8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    -D FOO now outputs `/* ! FOO */ instead of `/* not FOO */'.
+    (option_help_msgid): New constant.
+    (usage): Use it, so message is translated one option at a time.
+    (compare_files): For label, use file_label if set.
+
+commit 4f5769d660ddc9c16421ec97fb0d612b44cb2aa6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    (option_help_msgid): New constant.
+    (usage): Use it, so message is translated one option at a time.
+    (sprintc): Renamed from `printc'.  Now outputs to a buffer instead of stdout.
+    (cmp): Use new sprintc semantics.
+
+commit 3da1b0cc6a4f847d4ca8a70444fd7141f0a15290
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (briefly_report): Rewrite `message (A?"B":"C")' as
+    `if (A) message ("B") : message ("C")'; this is for getmsgids.
+    (briefly_report, diff_2_files): For label, use file_label if set.
+
+commit 204c39de358b8675209e67045ee718e460832bd8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    Use version.texi.
+    -D FOO now outputs `/* ! FOO */ instead of `/* not FOO */'.
+
+commit 629b424629fa32d92e4cd64c36cc87071b4ff2b0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    Initial revision
+
+commit e386d1b4b1a344260d02ac9f573cf7114fe97b29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (PACKAGE, VERSION, diffutils_srcs, D): New vars.
+    (version.c, version.texi, messages.po): New files.
+    messages.po is built automatically from source files and `getmsgids'.
+    Each function and macro whose first parameter is a gettext msgid
+    has had its first parameter's name changed so it ends in `msgid'.
+    All arrays of msgids have had their names changed to end in `msgid'.
+    `getmsgids' uses this to determine which strings are msgids.
+    All strings that are messages are passed through gettext once before
+    being used, so that they can be localized.
+    Several diagnostics have been changed slightly, to make them more consistent
+    and easier to translate.
+    (distfiles): Add them, pc/*, and getmsgids.
+    (diff.info): Now depends on version.texi.
+    (realclean): Clean version.*.
+    (dist): Just build $D.tar.gz.
+    ($D.tar.gz): New file, takes over old `dist' function.
+    Don't assume $(distfiles) are all in same directory.
+
+commit 8c445c7c3aeee3eaed656d65d6a3958d4e5450b1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 13 20:59:45 1994 +0000
+
+    Add HAVE_LIBINTL_H, HAVE_LOCALE_H, HAVE_LIBINTL.
+
+commit 9826645f369ae45dcae53502731b30a9762a050f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 9 17:42:44 1994 +0000
+
+    (trapsigs): Don't check signal return value, since it's bogus under djgpp.
+
+commit 49a8fa06517d91e798bf13c34bd446d55b1d401b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 9 17:22:07 1994 +0000
+
+    Include <sys/emxload.h>.  Define _REGEX_RE_COMP.
+
+commit 7e13cd4cb189a8c1903c81018f20a671eaeedace
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 9 17:22:07 1994 +0000
+
+    Remove quote.o.
+
+commit a8a1d53a240395260d8bd1be3567aa5513b1acdf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 17:04:40 1994 +0000
+
+    Fix to match autoconf 2.0 outline.
+
+commit 919d9efa7dac5ba8448c1703a8b3e4259b33c43d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (pr_program): New var.
+    (begin_output): Use system_quote_arg to compute command.
+    (analyze_hunk): ignore_regexp_list -> ignore_regexp.fastmap
+    Fix off-by-1 line length bug.
+    Match with one big regexp instead of a list of regexps.
+    Use new `trivial_length' local instead of comparing line's first byte to `\n'.
+    Help the compiler with linbuf local vars.
+
+commit 47acc0b36a848b347b06303f5a2e07e5c5f1a405
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (system_quote_arg): New function; replaces SYSTEM_QUOTE_ARG macro.
+
+commit c421d599f88317290e4b321ea44bef3230bc8ae5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (main): Use system_quote_arg to compute command.
+
+commit f1fe427f312e5fbadf22c83c785d78915aea6490
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (find_identical_ends): function_regexp_list -> function_regexp.fastmap
+
+commit 2e6f3b4f2528bdaee622ef8da7119917fb986e22
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (read_diff): Quote arguments with system_quote_arg.
+
+commit d3f8acca914ce995591af64dbc291defd2ac3606
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (function_regexp, ignore_regexp): Replace lists of compiled regexps with
+    these single compiled regexps.
+    (regexp_list, function_regexp_list, ignore_regexp_list): Moved to diff.c.
+
+commit 0bde792586cd647051d4dcb31362a09022cca9e9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (option_list): Quote options with system_quote_arg.
+    (add_regexp): Build one big regexp instead of a list of regexps.
+    (summarize_regexp_list): New function.
+    (regexp_list): Redesigned struct; moved here from diff.h.
+    (function_regexp_list, ignore_regexp_list): Likewise, for vars.
+
+commit 5b6f6d8841181216494161371b434a2e35462125
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (find_function): Simplify interface: don't return size of function line.
+    All callers changed.  function_regexp_list -> function_regexp
+    (print_context_script, pr_context_hunk, pr_unidiff_hunk):
+    ignore_regexp_list -> ignore_regexp.fastmap
+    (print_context_script, find_function): INT_MAX now denotes no previous match;
+
+commit 4d0d153b38abed7ee9c4ca5bbf461a03ad1e626e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Fix comment.
+
+commit 55ffd9714e96495ca0c309eb4b5d0d027839d9cb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (diff_2_files): ignore_regexp_list -> ignore_regexp.fastmap
+
+commit c451a2003646e9b05a649b4d86f7a09ca2364a62
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    \ -> /
+
+commit 0d75a4d1e5c382ae7dd866adcca6e92470f955ab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Remove __GNU_LIBRARY__, SYSTEM_QUOTE_ARG, system_quote_arg.
+
+commit 24bcded990501669da1107c79bfa065d36e58517
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (system_quote_arg): Compute size if first arg is 0.
+
+commit bb9307fe16533d834ef2a1181760eff97b5262f4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Quote CFLAGS= for djgpp GNU make.
+    Clean *.bat, fname.
+    Move dist to different directory.
+
+commit dbc2dc8d0c2dddbfe9ae97d1d0c9bb4103990f5b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Update version number, remove `only' typo.
+
+commit 9d37018f319b9912e6566c3a9e85172385d88023
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (srcs, diff_o, diff3_o, sdiff_o): New files quote.c, quote.o.
+
+commit 0c5e4918da08819eed4a360b28e67df68b971205
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (perror_with_name, fatal): Use GNU `error'.
+    (error): Remove.
+    (line_cmp): tolower -> _tolower
+    (xmalloc, xrealloc): Remove.
+
+commit 4ce826fb34d8011e8c021eeb14a283ccc920cec5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (_tolower): Define if not already defined.
+    (malloc, realloc): Remove unused declarations.
+
+commit 2f95916004c9c67345c8e9298d0a8a8394ff58aa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (xmalloc): Remove.
+    (diffarg): Take advantage of cleaner xrealloc semantics.
+
+commit f431aa8c700cb727f1b9b065d0f1d25c8a68f378
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (ROL): Use sizeof to make it more generic.
+    (slurp): Align buffer size to word size, in case malloc cares.
+    (find_and_hash_each_line): Don't invoke line_cmp if the length
+    differs and -i is in force.  tolower -> _tolower; this speeds
+    up diff -i considerably under some hosts (e.g. Solaris 2.3).
+    Don't assume ISSPACE ('\n') is nonzero.
+
+commit ce8a482bf4c3e4ad1ea70e55a74b96a43c8b0e7a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (groups_letter_value): tolower -> _tolower
+
+commit 1fbe4c853ce4b9fda8167ca4751b49b598492f11
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (main): Use strerror (EISDIR) instead of "Is a directory".
+    (xmalloc, xrealloc): Remove.
+    (fatal, perror_with_exit): Use `error'.
+
+commit 5b1cad81664d06f45e309032e914e3f743df3ff0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (ignore_some_line_changes): Removed.  All users changed.
+    (error): Change to GNU library standard.  All callers changed.
+    (xmalloc_exit_failure): New variable.  xmalloc and xrealloc are now taken
+    from GNU library.  All `main' programs set this variable at the start.
+
+commit 67e172c7653a143ac67d7d1fdeeee9a548206424
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (add_exclude): Can now assume xrealloc (0, ...) works.
+    (add_regexp): Free storage on failure.  Allocate storage all at one go.
+
+commit ff04d4a6b8586b52b7266bfcaa31420b99cd5a52
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (main): Align buffer size to word size, in case malloc cares.
+
+commit 9f40dabd6b4732fa4c39e4ed97d1cf3c8b9fc252
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    error caller changed
+
+commit ea3d57c64052bd50583c58ec9341fa4985c2ac12
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (common_o): New variable.  Link error.o and xmalloc.o into all programs.
+    (check): Depend on $(PROGRAMS).
+
+commit ae76071a49d024000e07435d703b2d527e22b616
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Oct 12 21:04:35 1994 +0000
+
+    (main): Set xmalloc_exit_failure.
+
+commit 67feaeb0f0dc56b39eb5323710b6a53322ab39de
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    ENV -> env
+
+commit a37fd034dd1bfb4f6e09990209f8c992f9865eeb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    ENV -> env.  Remove makefile rules.  Read pc/makefile.
+
+commit e13374d8246c1237bc4a4b09228636cba0b2e9df
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    Simplify the instructions by building a makefile.
+
+commit ac58035dd2b9f19b73316a91b1af4c53d71dd6ba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    Simplify the instructions.
+
+commit fd736c91704211b015c294d4095ecaefeeae3a5a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 06:52:06 1994 +0000
+
+    / -> \
+
+commit 5cd6116e856f71b079262ff542728239c285840c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 06:51:30 1994 +0000
+
+    / -> \.  65536, not 64*1024, in case somebody has a small int compiler.
+
+commit 6879b8f6f99fd5011f3dc6554630ccce66cb5804
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Limit to only emx-specific stuff.
+
+commit ab1150bcb901777c73ad616bb02185f438bade88
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Initial revision
+
+commit 1330271d767986819db277aa63fe5c9989dcded7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Limit to only djgpp-specific stuff.
+
+commit 6c746d1930205bb57496235eee9023141d183175
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Remove initialize_main.
+
+commit b092c9884a1cf2a55f13ab26845e7c23d80715ff
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Generalize to dgcpp.
+
+commit b85f4c403ed4e705bbf85664e240979f1ec67949
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Update for djgpp.
+
+commit 4e44a14836a44835c63c0534b5895ac47d632759
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 17:19:37 1994 +0000
+
+    diffutils 2.7 news
+
+commit 7a2d60ee66481b4fcb77274cb2dd0ef53854a759
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:24:19 1994 +0000
+
+    Update to version 2.7
+
+commit a2290f8c7f41e5e0a1b1cf564427b50ab6751078
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (AC_HEADER_SYS_WAIT): Add.
+    (AC_CHECK_HEADERS): Remove sys/wait.h.
+    (AC_CHECK_FUNCS): Add tmpnam.
+
+commit babad6e9ab0e7d3ff46f154307a473e2924dd8b0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (dir_file_pathname): Use filename_lastdirchar instead of strrchr.
+
+commit 57e35b2fe52c8727730fb758eeb17ad1fbd28e66
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (<sys/wait.h>, WEXITSTATUS): Use simpler scheme now that HAVE_SYS_WAIT_H
+    is turned off on hosts that are incompatible with Posix applications.
+
+commit 6159ec6f1a9cd96a128da3e3fd4486cdd2d3b646
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (private_tempnam): Use tmpnam if HAVE_TMPNAM; this simplifies porting.
+    (exists, letters): Omit if HAVE_TMPNAM.
+    (expand_name): Use filename_lastdirchar instead of strrchr.
+
+commit 51ee538828055feaae3ea5d6b06b5128c1df2954
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (read_diff): If STAT_BLOCKSIZE yields zero, adjust it to a more reasonable
+    value.
+
+commit 07ed0ecefeca9be0536797cec89ed07e6446d898
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 25 01:21:32 1994 +0000
+
+    Initial revision
+
+commit bf5a7b416679853f17a4b9067df5c32d176054cb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 24 20:36:40 1994 +0000
+
+    (exists, private_tempname): Adopt latest GNU libc algorithm.
+    (private_tempnam): Specialize for sdiff to avoid portability problems.
+
+commit 7189dccfb05cf4d5c6a76b6cfadf4aa1c97dd9e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 24 05:55:49 1994 +0000
+
+    Add rules for `default:' and `.SUFFIXES:'.
+
+commit 4a676345371383b8ba54148f0293d493e12b2b4b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 24 05:55:49 1994 +0000
+
+    Add io.h.
+
+commit 7e3fa69d9216db89af49fee2e36a63c88c611589
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    (AC_ARG_PROGRAM): Added.
+    (AC_OUTPUT): Add [date > stamp-h].
+
+commit 7124caf284e39d75650ebe9088f26d240abbbbeb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isspace -> ISSPACE, etc.
+    (PR_PROGRAM): Moved here from diff.h (old name was PR_FILE_NAME).
+    (begin_output): Use SYSTEM_QUOTE_ARG.
+
+commit 87791d0033ba440a562dd110c916e69c14a09929
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    <string.h>: Include if HAVE_STRING_H, too.
+    (CTYPE_DOMAIN, ISDIGIT, ISPRINT, ISSPACE, ISUPPER): New macros that
+    work around common <ctype.h> problems.
+    (O_BINARY): Remove.
+    (SYSTEM_QUOTE_ARG): New macros.
+
+commit 56ebd036789ec66bd34447b959126c4f71485543
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isprint -> ISPRINT
+
+commit 20bb7b34b24e09a2229ce5f414d3e554ec506046
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isspace -> ISSPACE, etc.
+    <ctype.h> now included by system.h.
+    (DEFAULT_EDITOR_PROGRAM): Renamed from DEFAULT_EDITOR for consistency.
+    (TMPDIR_ENV): New macro.
+    (expand_name): Change `isdir' to `is_dir' to avoid theoretical ctype
+    namespace contamination.
+    (main): Use SYSTEM_QUOTE_ARG.
+    (private_tempnam): Don't access "/tmp" directly; access it via PVT_tmpdir.
+
+commit 908dadc7b9c64bdbe7f9e22aeb8d0ccdad66f205
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isspace -> ISSPACE, etc.
+    (word): Don't define if already defined.
+    (read_files): Set mode to binary before returning 1.
+
+commit 9ea02bc7c5da7ec118bed0d7a4614fa3fb2f13f6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isdigit -> ISDIGIT, etc.
+
+commit 321868dd1585e35b2292d23bfe69f2ad69b53eab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    <ctype.h> now included by system.h.
+    (main): Give proper diagnostic if too many labels were given.
+    (read_diff): Use SYSTEM_QUOTE_ARG.
+
+commit 272b19fed95dac834234343f2be96966be004a64
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    <ctype.h> now included by system.h.
+    (PR_FILE_NAME): Rename to PR_PROGRAM and move to Makefile.in, util.c.
+
+commit 4c5217c90efc4f69a7bed6022fe09da968e977a3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Add comment.
+
+commit b53ee8d668cf8834a6a8b82db45368b5a0dd8355
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    (word): Don't define if already defined.
+    (main): Use setmode, not open(..., O_BINARY); this hits stdin too.
+    Use NULL_DEVICE instead of "/dev/null".
+    (cmp): Use %lu instead of %ld when it is more likely to give correct output.
+
+commit 2b982bf06e9a2d3b9d7676a9c77eda2a4f709701
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Initial revision
+
+commit dcbd46bfa35db430751e6504f6212a60e3857be0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Broaden name.
+
+commit 03d25aa193d61d08b384cde510238b2ee92d882d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Rewrite from scratch.
+
+commit 654e86283e81c14a294bf88fc4c3945130742ab4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Make it more like ../config.hin.
+
+commit 21a8299b8eb5607b386ed2c9c8351cd8be905290
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Revamp for more Unix-like approach.
+
+commit d970a9641829918a7e7ee822b5cb2ce16a50aef0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    (DEFAULT_EDITOR_PROGRAM, DIFF_PROGRAM, LIBOBJS, NULL_DEVICE, PR_PROGRAM,
+    PROGRAMS): New variables.
+    (check, stamp-h.in, cmp.o, util.o): New targets.
+    
+    (edit_program_name): New variable; replaces old binprefix method.
+    (install, uninstall): Use it.
+    (binprefix): Removed.
+    
+    (distfiles): Add stamp-h.in.
+    (clean): Remove stamp-h.
+    (config.hin, config.h): Use time stamp files to see whether they're up to date.
+    
+    (cmp_o): Add $(LIBOBJS).
+    
+    (install): Install info files from srcdir if they're not in `.'.
+
+commit 8e031e750eaa8342e5f7c9bef35fa365d7ab6607
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 18 00:28:22 1994 +0000
+
+    Patches from Kai Uwe Rommel
+
+commit 72cc814aef0a183c56b291f20e8d61df4f71078c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 16 21:31:04 1994 +0000
+
+    Patches from Kai Uwe Rommel
+
+commit bc5201049a73639af8aa8248ccc8d981c6e5c304
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    remove CR
+
+commit a279fecaaa46bbe8705f709cb663eb5a03ef0754
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    Remove CR and usage.  Improve / \ : detection.
+
+commit dd79db47919506ab46cdd663564077f8355ec4d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    Make it look mre like config.hin and system.h.
+    Add HAVE_SETMODE.  Remove quote_char.  Define same_file to -1.
+
+commit 9f01c902c5ca320d417cd1f88d618b6b2e62cf36
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    Initial revision
+
+commit a268b2bd9e798f6488337f65f944a76c18026225
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:49:34 1994 +0000
+
+    (program_name): Renamed from `program', for consistency.
+
+commit f19358db7aaa40289485bc06d371a51758d33a13
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:49:34 1994 +0000
+
+    (printc): Don't quote C if isprint(C).
+
+commit 110ed53bfe349fe7bf9563917867a6b1f8dd28b0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 04:25:50 1994 +0000
+
+    Initial revision
+
+commit 675bab82c354f325d81e642493282fb306087383
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 14 15:04:41 1994 +0000
+
+    entered into RCS
+
+commit 262be8ba548bb57e81deb3efee6db5fe57de9d63
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 13 18:46:43 1994 +0000
+
+    (AC_FUNC_MEMCHR): Remove.  Autoconf didn't adopt this, since we need not
+    worry about an old experimental library where memchr didn't work.
+    (AC_FUNC_MEMCMP): Not needed, since we only test for equality.
+    (AC_REPLACE_FUNCS): Add test for memchr.
+    (AC_CHECK_FUNCS): Check for memchr, not memcpy, since it'll be cached.
+    (AC_CHECK_HEADERS): Add string.h; regex.c uses on some old hosts.
+
+commit ea404e8bfb25c662a13f2754496527127babd986
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 13 18:46:43 1994 +0000
+
+    (memcmp): Define in terms of bcmp.
+    Use HAVE_MEMCHR to test for all mem* routines.
+
+commit 9bb6665825b1d7f807400fd4fe08f6997fe06fdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 13 18:46:43 1994 +0000
+
+    (srcs): Remove memcmp.c.  We use bcmp if memcmp doesn't work, since
+    we only test for equality.
+
+commit 2f93e7ee108f1f13c923edb19fa57ef45df61b67
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (line_cmp): Now takes just two arguments, and no longer optimizes
+    for common case of exact equality; the caller does that optimization now.
+    Optimize for the common case of mostly exact equality.
+    Use isupper/tolower instead of islower/toupper, for consistency.
+    (line_cmp, print_line): Use '\n' instead of line_end_char.
+
+commit d11c579336b08ac6fae564d9c08edaaf49227657
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    Use more modern autoconf approach to standard C headers.
+
+commit f51c8e0cddd964748e70cac48347cc3e80c8dd1e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    Fix copyright notice.
+
+commit db138267996a9c496249d25d67dc0cf7eaa52f3b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (binary_file_p): Assume non-broken memchr.
+    (find_and_hash_each_line): Revamp to fix some inconsistencies with -b -w -i
+    and incomplete lines.  Incomplete lines are now put into their own bucket.
+    This means line_cmp no longer needs line length arguments,
+    and equivalence classes' line length no longer need to include \n.
+    Invoke line_cmp only if memcmp fails and if ignore_some_line_changes.
+    (prepare_text_end): -B no lonter ignores missing newlines.
+    (read_files): Allocate another bucket for incomplete lines.
+
+commit 55429168429dce9d0e88798656cc3ee871e6e1d2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (ignore_some_line_changes): New variable; replaces `length_varies'.
+    (line_end_char): Removed; it wasn't being used consistently.
+    (line_cmp): Now takes just pointers to two lines.
+
+commit b86bc30b1bcfcec54b7baf97ae53121711cc1e5d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (main): Use '\n', not line_end_char.
+    (ignore_some_line_changes): New variable; replaces `length_varies'.
+
+commit 2113dba0f38db53564ebfc6de3bdee4b6a62c9ec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    entered into RCS
+
+commit f7d04f3e12be3c299d7f19de309e56f6b9f3e958
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (CPPFLAGS, DEFS, CFLAGS, LDFLAGS, prefix, exec_prefix): Default to
+    autoconf-specified strings.
+    (COMPILE): Use the defaults.
+    (srcs): Add memcmp.c.
+    (distfiles): Rename config.h.in to config.hin and install.sh to install-sh.
+    (Makefile, config.h, config.hin, config.status): Rework for compatibility
+    with Autoconf 2.
+
+commit e85eb8cb146fba69cee6d3febd3ce3fb2b42c8bb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 08:23:15 1994 +0000
+
+    Add memchr.c, waitpid.c, install.sh
+
+commit 1bc9633710949deb5fc6a273f6132298f1f49d9c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 08:08:03 1994 +0000
+
+    (srcs): Add memchr.c, waitpid.c
+
+commit 3fd81d5f8c566232232b48e3be861dd1ea90cbf2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    Revamp for Autoconf 2.
+
+commit f098afa7d2a130cf2d0a9806d7a3ee4ea26d083c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (memchr, waitpid): Remove; use new substitutes instead.
+
+commit 3dfe2ea421249d9d7aa11e0ad37e6783648439ad
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    Use Autoconf 2 style HAVE_DIRENT_H etc. macros for directories.
+
+commit 17fa709c6bbfbed7c8111fff02d08d1f2011764d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help): New function.
+    (usage): Just print usage; let caller worry about exiting.
+    (memchr, waitpid): Remove; use new substitutes instead.
+
+commit 350a6ba55235b740d03afc84562a8df2212fa389
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (dir_sort): Prefer NAMLEN (p) to strlen (p->d_name).
+    Change VOID_CLOSEDIR to CLOSEDIR_VOID for Autoconf 2.
+
+commit 66bbc88b540532674c1f3d3ef26bbb5df765fea8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help, check_stdout): New functions.
+    (usage): Just print usage; let caller worry about exiting.
+    (read_diff): Use new waitpid substitute.
+
+commit a9a3e02a8eb2398b96ee79158e57879425d79356
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help, check_stdout): New functions.
+    (usage): Just print usage; let caller worry about exiting.
+    (option_help): New variable.
+    (filetype): Add Posix.1b file types.
+
+commit 4fdea93974738df7a4b6441094475a533b596b29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help, check_stdout): New functions.
+    (usage): Just print usage; let caller worry about exiting.
+
+commit 6d47c45cbfb6acbe46683411298a929b84751ba6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    *** empty log message ***
+
+commit 23141bbc07269c4d06fbe064b14661ab1ea61bd7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (diff_o, diff3_o, sdiff_o): Add $(LIBOBJS).
+
+commit 3e4d9d4cac16150f748a35c6487174267c06de87
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 3 16:43:25 1994 +0000
+
+    *** empty log message ***
+
+commit 2d876bd5c4ff0401e0bdc6ea0b18d4753a122c0d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 3 16:37:31 1994 +0000
+
+    (distfiles): Add install.sh.
+
+commit 78d1350a8f30594109ab24a089ab0d8e38fb0d85
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 3 16:12:53 1994 +0000
+
+    Switch to new autoconf naming convention.  Add test for sys/file.h.
+
+commit 3b57b651310db7feae5bbe3b28ea80327a9b296d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 16:01:49 1994 +0000
+
+    (main): Call initialize_main first.
+    If we'll have children, make sure SIGCHLD isn't ignored.
+    (read_diff): Use popen+pclose if !HAVE_FORK.
+    (DIFF_CHUNK_SIZE): Removed.  We now get initial chunk size from STAT_BLOCKSIZE.
+    (INT_STRLEN_BOUND): New macro.
+
+commit 14cae612e4f2f21e1ba9e9f7ab35c834a2fd82ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 15:46:39 1994 +0000
+
+    (ck_fdopen): Function removed.
+    (cleanup, main, waitpid): Use popen+pclose if !HAVE_FORK.
+    (edit): Use system if !HAVE_FORK.
+    (main): Call initialize_main first.
+    (execdiff): Now assumes caller has pushed all args, plus trailing 0.
+    All callers changed.
+    (trapsigs): If we'll have children, make sure SIGCHLD isn't ignored.
+    (private_tempnam): Try TMP if TMPDIR isn't defined.
+    Fit temporary filenames into 8.3 limit.
+
+commit 160c4a9fb615e713855f6f7668967b3ce46366d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 15:36:53 1994 +0000
+
+    Include <sys/file.h> only if HAVE_SYS_FILE_H.
+    (S_IXGRP, S_IXOTH, S_IXUSR): Remove unused macros.
+    (STAT_BLOCKSIZE): Don't define if already defined.
+    (min, max): Undef if already defined.
+    (filename_cmp, filename_lastdirchar, HAVE_FORK, HAVE_SETMODE, initialize_main
+    O_BINARY, same_file): New macros, for porting to non-Posix systems like DOS.
+
+commit 4f042426fe9d274466b6e3d163907d0ddd60fa16
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 15:32:35 1994 +0000
+
+    (binary_I_O): New variable for --binary option.
+    (main, usage, compare_files): Support --binary option.
+    (main): Call initialize_main first.
+    If we'll have children, make sure SIGCHLD isn't ignored.
+    (compare_files): Use filename_cmp to compare file names.
+    Use filename_lastdirchar to find last directory char in a file name.
+    Use same_file to determine whether two files are the same.
+
+commit 5656c2c6e7a5ab0445b429d3362060b91046c853
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 06:09:57 1994 +0000
+
+    (begin_output): Use popen+pclose if !HAVE_FORK.  Check fdopen status.
+
+commit 0e014790ed7103a777f6c6b8ff5beecd98bf1060
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 05:14:12 1994 +0000
+
+    (sip): If HAVE_SETMODE, always test for binary files using binary mode.
+
+commit 1ec43a06812d6f7b40909f5052c5be09834f8b40
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 05:12:08 1994 +0000
+
+    (print_context_label): Check whether (broken) ctime yields 0.
+
+commit 883e61c62b6cb8d5bb756b938190f1e6674e781d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:01:31 1994 +0000
+
+    *** empty log message ***
+
+commit 15535d055503d8b86b917c203ceffb13523d5c7e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:47 1994 +0000
+
+    (distclean): Clean config.cache, config.log (for new autoconf).
+
+commit 8c3fba9345221724d146a265a40729bc3e910d11
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:41 1994 +0000
+
+    (main): Call initialize_main first.
+    Use filename_cmp to compare file names.
+    Use same_file to determine whether two files are the same.
+
+commit d32dfccb104b0b7d008244c546e07db940903225
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:28 1994 +0000
+
+    (compare_names, diff_dirs): Use filename_cmp to compare file names.
+
+commit d987d052d321fe4bc6a6056a1022f7fe7af42d53
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:17 1994 +0000
+
+    (format_group, groups_letter_value): Use * instead of [] in prototypes.
+
+commit 7dce49b3b5a94ced9368316d26e63f04b1e896d5
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Fri Jun 17 15:23:43 1994 +0000
+
+    (info, dvi, diff.dvi): New targets.
+    (clean): Remove TeX output files.
+
+commit 474d970822b10b7038c48706dd4569b82a469890
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jun 17 05:37:52 1994 +0000
+
+    (word): Change from typedef to #define, to avoid collision with
+    Unicos 8.0 <sys/types.h>, which also typedefs `word'.
+
+commit bc6bec73a8d99b7ffd663d9e39e89d048a2cfc1d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 15 00:53:01 1994 +0000
+
+    (print_number_range): Don't rely on promotion to make the old-style parameter
+    type agree with the prototype parameter type; this doesn't work on
+    Apollos running bsd4.3.
+
+commit 41a3344a4213e3f722216665139ecead47fa6298
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 15 00:53:01 1994 +0000
+
+    (scan_diff_line): Don't rely on promotion to make the old-style parameter
+    type agree with the prototype parameter type; this doesn't work on
+    Apollos running bsd4.3.
+
+commit 91df35595e5c48238c7f6c916101c0c3e3bcb1f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 15 00:50:09 1994 +0000
+
+    *** empty log message ***
+
+commit ea61d22f5b1f5852ca31d662d5755da6ae4faeec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jan 3 02:05:51 1994 +0000
+
+    (LDFLAGS): Remove -g.  All users changed to use $(CFLAGS) as well
+    as $(LDFLAGS).
+
+commit 5a1a95bc796eb762fbb4f56e20dd0ef7a974d4c4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 13 12:22:58 1993 +0000
+
+    diffutils 2.6
+
+commit 72db0aa2f2ba7fe24a4c6ae5d1dffdeaec81d1a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Dec 3 21:07:48 1993 +0000
+
+    (main): allow -p -u.
+
+commit d80108a9e2d9195c0d2aa9c735cbe8cb9e2f75a9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Dec 3 21:07:09 1993 +0000
+
+    *** empty log message ***
+
+commit 74651693b2a7e01cf61b3fd8545fc47c65555282
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 23 03:51:08 1993 +0000
+
+    (distclean): Remove config.h.
+
+commit c9673423c1166eb994cb3f99d646e50a14fbd631
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (AC_HAVE_HEADERS): Add unistd.h; remove AC_UNISTD_H.
+
+commit 5b318f266f7881ea5ebe765c5347716f2543adc3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    *** empty log message ***
+
+commit 3a23f3eb8afec20ffaf28cd1bfc05661316e7474
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (xmalloc, xrealloc): "virtual memory" -> "memory"
+
+commit 0ddcbc909912ca7369813cc4f5bd7e17a278466a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (usage): Send usage to stdout, not stderr.
+    (long_options, main, usage): Add `--help'.
+    (main): Send version number to stdout, not stderr.  Exit afterwards.
+
+commit d81ae65145818897ea26e6c11e1528c53afbf3f6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (word): Change to `int'; it makes a big difference on x86.
+    (sip, slurp): Put off allocating room to hold the whole file until we
+    have to read the whole file.  This wins if the file turns out
+    to be binary.
+    (primes): Omit large primes if INT_MAX is small.
+
+commit d963c582c1078b9d26243874e14ca5fb82447a6f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (usage): Send usage to stdout, not stderr.
+    (long_options, main, usage): Add `--help'.
+    (read_diff): Detect integer overflow in buffer size calculations.
+
+commit ecbe3d8f04cd6006f6f9a64b21fecdeb87281696
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (long_options, main, usage): Add `--help'.
+    (main): Send version number to stdout, not stderr.
+    (usage): Send usage to stdout, not stderr.
+    (compare_files): Initialize `inf' properly.
+
+commit 0f8c0d885e8f59efe3a9d2d2cfb2f731b0cd4ebd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (word): New type.  All uses of `long' for word-at-a-time comparisons
+    changed to `word'.
+    (long_options, main, usage): Add `--help'.
+    (usage): Send usage to stdout, not stderr.
+    (main): Add `-v'.  Send version number to stdout, not stderr.
+
+commit 4b1a69ee970f3016cb7d1b7a6424673beee6a5f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (too_expensive): New variable, for heuristic to limit the worst-case
+    cost to O(N**1.5 log N) at the price of producing suboptimal output for
+    large inputs with many differences.
+    (diff_2_files): Initialize it.
+    (struct partition): New type.
+    (SNAKE_LIMIT): New macro; merely documents already-used number 20.
+    (diag): New `minimal' arg; all callers changed.  Put results into
+    struct partition.  Apply `too_expensive' heuristic.  Tune.
+    (compareseq): New `minimal' arg; all callers changed.  Tune.
+    (shift_boundaries): Improve heuristic to also coalesce adjacent runs
+    of changes more often.
+
+commit be52c66d5ef8e0f74e555d4cbf5b22ef5ef3e62f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    Initial revision
+
+commit 7aeb973641eeae48c4d6abd1ce477858f6f90147
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    GNU diffutils 2.6
+
+commit d3079e2f6bbd367cb4e1744653d94adcf49aa0fb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (memchr): Make first arg char const *
+    to match standard.
+    (xmalloc, xrealloc): Cast malloc, realloc
+    to (VOID *) to suppress bogus warnings on some nonstandard hosts.
+
+commit 3a90d1af5a2b3b57af324ea3791de3a19dc3bc81
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (malloc, realloc): Declare only if !HAVE_STDLIB_H.
+    (memchr): Declare only if !HAVE_MEMCHR.  These changes are
+    needed to keep some nonstandard hosts happy.
+
+commit 00c73e284b4f194f44a8ef81822486dff1859924
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (xmalloc, xrealloc): Cast malloc, realloc
+    to (VOID *) to suppress bogus warnings on some nonstandard hosts.
+    (lf_copy, lf_skip, lf_snarf): Cast memchr to (char *)
+    to suppress bogus warnings on some nonstandard hosts.
+    (memchr): Make first arg char const *
+    to match standard.
+
+commit 1dcec128c62cd5fbb461cf28251a5d56210c9784
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (xmalloc, xrealloc): Cast malloc, realloc
+    to (VOID *) to suppress bogus warnings on some nonstandard hosts.
+
+commit 70b4740f3f25b4e50470d937ce9afb503423c169
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (add_exclude_file): Cast memchr to (char *)
+    to suppress bogus warnings on some nonstandard hosts.
+
+commit 38681c3055dcadafca0970ab40378c64ec99421f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (main, usage, version_string): Add --version option.
+
+commit fef4518ddad8ac816bbac963cdb45869249a22bc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (diff_2_files): Work around memcmp bug with size=0.
+
+commit d6a38aed737d9a647806d35b677507f1c1c7c516
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 06:30:18 1993 +0000
+
+    Initial revision
+
+commit c1a57a783bb54b12c1369632b89a42d960b3321c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 06:18:21 1993 +0000
+
+    GNU diffutils 2.6
+
+commit 36af5432bf4be21c0ba680d7baf483fcae5492ee
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (AC_STAT_MACROS_BROKEN): Add.
+
+commit 9f03341c093a30e7bc3c95e2876a30254a4790d1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (output_1_line): Use isprint, since some hosts lack isgraph.
+    Ensure that its argument isn't negative.
+    (xmalloc, xrealloc): Remove needless casts.
+
+commit 818c6c7ee66e1ce028f8e232737b1a384fb194ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (volatile, const): Define these before including any system headers,
+    so that they're used consistently in all system includes.
+    (S_IS{BLK,CHR,DIR,FIFO,REG,SOCK}): Fix defns if STAT_MACROS_BROKEN.
+    (getenv, malloc, realloc): Declare even if HAVE_STDLIB_H, since some
+    <stdlib.h>s don't declare them.
+    (memchr): Likewise for <string.h>.
+
+commit 96d6bc969fd6ab47cb134631fd496e3432e270d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Include "system.h" first.
+    (xmalloc): Make defn static, like declaration.
+
+commit 0398a96fe634295de3bea52ef325f88c72267eff
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Include "system.h" first.
+    (xmalloc): Now static.
+    (xmalloc, realloc): Remove needless casts.
+    (READNUM): Ensure isdigit argument isn't negative.
+
+commit 1bfc4514b097f261b98d0b1f875edfbdc5a94091
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Remove redundant "system.h" inclusion.
+
+commit bec40df88a702f41d5cc565a785f038e1ebead42
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Include "system.h" first.
+
+commit 015dc4c028bd7dd30ec001604f4676949f2d339a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (discard_confusing_lines): Make defn static, like declaration.
+
+commit a6a9150a06232636a2b7888a1d71b011811aabdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (diff3, sdiff, cmp): Do not link $(ALLOCA).
+
+commit 03ca0426698728f388ea7c13bebb4bf7d5aca397
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 17 19:27:09 1993 +0000
+
+    GNU diffutils 2.6
+
+commit a3866fa3b80f9f78d2b43823411c07ee38592a7a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 17 06:29:10 1993 +0000
+
+    GNU diffutils 2.6
+
+commit d23d2f2b18b5ce325181ebebce40c9d92d12edde
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 17 05:26:45 1993 +0000
+
+    GNU diffutils 2.6
+
+commit 5f6bfb84c7738caafd8b36660d1a8ab4b65aeda7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    #include <config.h>, not "config.h", to allow
+    configuring in a separate directory when the source directory has
+    already been configured.
+
+commit f4cd92b6ac57e931c5bf52dc13671bec6eb5152e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    (scan_char_literal): New function, for new %c'x' and
+    %c'\ooo' format specs.
+    (format_group, print_ifdef_lines): Use it.  Remove %0 format spec.
+
+commit 35aad47ae3f3310672963918c1944d339f22680c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    (cmp): Don't try to read past end of file; this doesn't
+    work on ttys.
+
+commit f9461e59e19b9fd2c458dc2f9ff536d233edf98f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    (COMPILE): New defn, with proper -I options so that
+    `#include <config.h>' works.
+
+commit a2b82541fef2ca5e61dab7fc67bdf0100a3f6b6a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    Configure HAVE_LIMITS_H, HAVE_STDLIB_H.
+
+commit c98340644e55179d1a71a77af131970e1e17b87b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (line_cmp): bcmp -> memcmp
+
+commit 24f285cec459b4f7771f4dec30da370086a58442
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (PARAMS, VOID): Define earlier so that malloc decl can use VOID.
+    (STAT_BLOCKSIZE): Simplify ersatz defn; just use 8K.
+    (dirent): Renamed from direct; dirent makes the code more standard.
+    <limits.h>, <stdlib.h>, <string.h>: Include only if corresponding HAVE_*_H.
+    (memcmp, memcpy, strchr, strrchr): Prefer these standard names to
+    traditional names.
+
+commit d03c8525fd2672121669f2b947e3850bdd49b4d1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (expand_name): rindex -> strrchr
+    (expand_name, lf_snarf): bcopy -> memcpy
+    (interact): index -> strchr
+
+commit fe1e2e9de6edad046b24aa0eb52a266f7c49d458
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (struct group): New struct.
+    (print_ifdef_lines): Use it to simplify argument passing.  Remove the
+    convention that last arg -1 signifies that the lines from file 2 are
+    the same as the lines from file 1; this convention no longer works,
+    now that line numbers might be printed out, since the line's numbers
+    may differ.  Add first FILE * argument to output to.  All callers changed.
+    Use a faster test for the single-fwrite optimization.
+    Add support for %?c, %(A=B?T:E), PRINTF_SPECn formats.
+    (format_group, scan_printf_spec, groups_letter_value): New functions.
+    (format_ifdef): 1st arg is no longer const pointer.
+
+commit e491a3556f24e7478887877eb78195748a02a7dd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (copy_stringlist, compare_line_list): bcmp -> memcmp
+
+commit 158d33010d26a6bcfa19f1df320a9d4c9975b69e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (group_format, line_format): No longer const pointers.
+
+commit 75d628023000dc17fbfde46799261a2c723a8707
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (main, longopts): Add --line-format=FORMAT option.
+    (specify_format): Args no longer const pointers.  All callers changed.
+    (compare_files): rindex -> strrchr.
+
+commit ecf2d45950b4fd7967f6b30df8aeebe5ace5376c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (diff_2_files): Use memcmp instead of bcmp.
+
+commit 10d3e0ad7bd824b5a3d6cf5f541451d5fb4c87d0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 00:27:28 1993 +0000
+
+    GNU diffutils 2.6
+
+commit 1a71453b7bc68d2cfb9aa4d737e0c9ffb47ce5df
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 3 00:21:02 1993 +0000
+
+    (compare_files): Two files with the same name must be the same file;
+    avoid a needless `stat' in that case.
+
+commit 9ca9006ee016868d47d9e203e352f3d7274885eb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 19:13:20 1993 +0000
+
+    (srcs, objs, distfiles, cmp): New files cmpbuf.[ch].
+    (distfiles): New files config.h.in, mkinstalldirs.
+    (.c.o): Add -DHAVE_CONFIG_H.
+
+commit 42326d264796c8802247ff929a9561b1d688cbdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Configure HAVE_SIGACTION, RETSIGTYPE, HAVE_VPRINTF.
+    Configure into config.h.
+
+commit 6f0c43bd7b450fe37bf6fd6d0138153183699c3c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use `const' to pacify `gcc'.
+    Use size_t, not int, when needed.  Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (struct msg, msg_chain, msg_chain_end): Moved here from diff.h.
+    (message5): New function.
+    (pr_pid): New var.
+    (begin_output): Allocate `name' more precisely.
+    Put child pid into pr_pid, so that we can wait for it later.
+    Don't check execl's return value, since any return must be an error.
+    (finish_output): Detect and report output errors.
+    Use waitpid if available.  Check pr exit status.
+    (line_cmp): Use locale's definition of white space
+    instead of using one hardwired defn for -b and another for -w.
+    (analyze_cmp): Avoid double negation with `! nontrivial'.
+    Pacify `gcc -Wall' be rewriting for-loop into do-while-loop.
+    (dir_file_pathname): New function.
+
+commit c8209e8e34843819287c1f5b1b10a7c3a7de6c98
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    (S_IXOTH, S_IXGRP, S_IXUSR,
+    SEEK_SET, SEEK_CUR,
+    STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO):
+    New macros, if system doesn't define them.
+    (volatile): Don't define if already defined.
+    (PARAMS): New macro.
+    (VOID): Move here from diff.h.
+
+commit 63170f223c8ef30650240171f171c1259a7b366f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use `const' to pacify `gcc'.
+
+commit bc7d55d1f848fb5faff8a6d3662c483eec54beb0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' to pacify `gcc'.  Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (SEEK_SET): Move to system.h.
+    (version_string): Now char[], not char*.
+    (private_tempnam): Remove hardcoded limit on temporary file names.
+    (exiterr, perror_fatal, main): When exiting because of a signal,
+    exit with that signal's status.
+    (lf_refill, main, skip_white, edit, interact): Check for signal.
+    (ignore_SIGINT): Renamed from `ignore_signals'.
+    (NUM_SIGS, initial_handler): New macros.
+    (initial_action, signal_received, sigs_trapped): New vars.
+    (catchsig, trapsigs): Use sigaction if possible, since this closes the
+    windows of vulnerability that `signal' has.  Use RETSIGTYPE not void.
+    When a signal comes in, just set a global variable; this is safer.
+    (checksigs, untrapsig): New functions.
+    (edit): Pacify `gcc -Wall' with a useless assignment.
+    Respond to each empty line with help, not to every other empty line.
+    (private_tempnam): Remove hardcoded limit on temporary file name length.
+    Don't assume sizeof (pid_t) <= sizeof (int).
+
+commit f2b587677b4cb5d1ae5a9596df8d2efa90384843
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.
+    (change_letter, print_number_range, find_change): Move decls to diff.h.
+    (print_normal_hunk): Now static.
+
+commit d002fe98187824364679e45b69e2104f18512284
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    (line_cmp): Move declaration to diff.h.
+    (textchar): Remove.
+    (find_and_hash_each_line): Use locale's definition of white space
+    instead of using one hardwired defn for -b and another for -w.
+
+commit 46775cfbd9a47eea0c51c74935bbeac8b2e185e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.
+
+commit 2bb476a6039ce1ae3715bfc13f59ed23ff4eaa8c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    (struct dirdata): Rename `files' to `names' to avoid confusion
+    with external struct file_data `files'.
+
+commit 96a2e40dd0d57c2f845943fb246ecfdda29349bb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (VOID): Move to system.h.
+    (version_string): Now char[].
+    (usage): Sort options.
+    (process_diff): Pacify `gcc -Wall' with a useless assignment.
+    (read_diff): pid is of type pid_t, not int.  Use waitpid if available.
+    (output_diff3): Simplify test for `\ No newline at end of file' message.
+
+commit 86596683e8c1b41a8ac9e5c2b4e497ef2fd8fb7c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    (Is_space, textchar): Remove.
+    (struct msg, msg_chain, msg_chain_end): Move to util.c.
+    (VOID): Move to system.h.
+    (line_cmp, version_string, change_letter, print_number_range,
+    find_change): New decls.
+
+commit 1c96aecf2aab2b5225373e4e41bb94b80914638e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (usage): Sort options.
+    (filetype): New function.
+    (compare_files): Set stdin's st_mtime to be the current time.
+    Leave its name "-" instead of changing it to "Standard Input";
+    to test whether a file is stdin, we must compare its name to "-" instead
+    of its desc to 0, since if it's closed other file descs may be 0.
+    When comparing standard input to a file, and using a shortcut (e.g.
+    looking at file sizes or inode numbers), take the lseek offset into
+    account before deciding whether the files are identical.
+    Pretend that nonexistent files have the same filetype as existing files.
+    Rename `errorcount' to `failed', since it's boolean.
+    In directory comparisons, if a file is neither a regular file nor a
+    directory, just print its type and the other file's type.
+
+commit 92b99a4ef582665c45a17e15f8b3fc96bae740e5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    (print_context_label): Standard input's st_mtime is no longer a special case
+    here, since `compare_files' now sets it to the current time.
+
+commit e8095a8ed1b3cc3fe41e2f09da655917c4845fbf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.  Use 0, not NULL, for portability.
+    Make globals static when possible.
+    
+    (file): Now a 2-element array; replaces `file1' and `file2'.
+    (file_desc, buffer): Likewise, for file[12]_desc and buf[12].
+    (main): Likewise, for stat_buf[12].  Index these variables with `i'.
+    
+    (ignore_initial): New var.
+    (long_options): Now const.  Add `--ignore-initial'.
+    (usage): Sort options and add `--ignore-initial'.
+    (main, cmp): Add `--ignore-initial' support.
+    
+    (main): `cmp - -' now succeeds.  Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    When comparing standard input to a file, and using a shortcut (e.g.
+    looking at file sizes or inode numbers), take the lseek offset into
+    account before deciding whether the files are identical.
+    Avoid mentioning `dev_t', `ino_t' for portability to nonstandard hosts.
+    Use l.c.m. of files' buffer sizes, not 8 * 1024.
+    ferror (stdout) does not imply errno has a useful value.
+    If 2nd file is "-", treat it first, in case stdin is closed.
+    
+    (cmp): Always compute `char_number', `smaller' for speed and simplicity.
+    Say `cmp: EOF on input', not `/usr/gnu/bin/cmp: EOF on input',
+    as per Posix.2.
+    
+    (block_compare_and_count): Increment line_number argument.
+    Remove end_char argument; it's always '\n'.  All callers changed.
+    Do not assume sizeof(long) == 4; this isn't true on some 64-bit hosts.
+    (block_compare): Minimize differences with block_compare_and_count.
+    
+    (block_read): Coalesce `bp += nread's.
+    
+    (printc): Remove `FILE *' arg; output to stdout.  All callers changed.
+
+commit 3b9709d3f4b322a0a64ec9d33cbf9bbfd170f02c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    (diag): Pacify `gcc -Wall' with a useless assignment.
+    (diff_2_files): Use l.c.m., not max, of files' buffer sizes.
+
+commit a9dde9e085845faef1566af34651dfe0410be1fc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Initial revision
+
+commit 3e492ee56afd89ed6216e00148b6378026f50473
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 23 05:44:15 1993 +0000
+
+    GNU diffutils 2.7
+
+commit 495c25447365aabb888d317a7934403dd08feaf8
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Fri Jul 30 00:44:17 1993 +0000
+
+            * Makefile.in (config.status): Run config.status --recheck, not
+            configure, to get the right args passed.
+
+commit 3a50fa0f0210e037d0b5583ccb7c12d52066f9e6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 22 10:46:30 1993 +0000
+
+    (dist): Replace `if [ ! TEST ]; then ACTION; fi' with `[ TEST ] ||
+    ACTION || exit' so that the command exits with proper status for `make'.
+
+commit bd8d4cc978484a29f6782808a36bfa95bc679278
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Thu Jul 8 23:47:51 1993 +0000
+
+    new targets
+
+commit 308a124880a6cdce4dfc1b895e767adb2fbdfb79
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jul 4 00:00:00 1993 +0000
+
+    Attempt to do a better job with three two-way diffs.
+    This was a file labeled diff3.c.new-notdone,
+    dated 1992-04-27, with user name `randy'.
+
+commit 72e9b3762de6101d10eb7378a7f996ad8643e4f5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jun 5 23:10:40 1993 +0000
+
+    (dist): Switch from .z to .gz.
+
+commit 7efcf6d1879dea4682d57ed29b75b5727be04a53
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    Change NULL to 0.
+
+commit 47b8d868a96ed6ab769c5b144c6b6faf5bd3d634
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (print_sdiff_common_lines_print_sdiff_hunk): Cast args to pointer types, for traditional C.
+
+commit 9c0b359b91b2411a8bbdb8589768fb42361e195a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (longopts, private_tempnam): Change NULL to 0.
+
+commit 50a3709b577ada7869b303b0ccb92628e7187b5c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (longopts): Change NULL to 0.
+
+commit f0c10d063072e6f9238808348a5a404ffd256864
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (main): Cast args to compare_files, for traditional C.
+
+commit 73e929cbb6eb24bf3e64238c1484c872d34d5369
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (diff_2_files): Change NULL to 0.
+
+commit 9a8361c3c5e613a32811e630c2d1a33687fc6d58
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 25 15:36:38 1993 +0000
+
+    (compare_files): Don't use the file size shortcut if
+    ignore_some_changes is nonzero, since the file size may differ
+    merely due to ignored changes.
+    (briefly_report): New function.
+    (main):  Set ignore_some_changes if we might ignore some changes.
+    Remove unsystematic assignment of 0 to static vars.
+
+commit 6e652af429e2d422531cd323b7165d7ccb75be43
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 25 14:54:05 1993 +0000
+
+    (tab_align_flag): New variable, for new -T option.
+    (main, usage, output_diff3): Add support for -T.
+
+commit c0d57c083342e7ab4cb795aa4f4129082b33d9da
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Sun May 23 19:25:41 1993 +0000
+
+    entered into RCS
+
+commit 1f60a522de41a36a8dd546ec5f75d2bc08b9e3d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 22:15:29 1993 +0000
+
+    (read_files): New argument PRETEND_BINARY says whether to
+    pretend the files are binary.
+
+commit da390dd91151a90327bfd1272b85cadf712a81bc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 22:15:29 1993 +0000
+
+    (ignore_some_changes): New variable.
+
+commit 63455a47c89f1ba65ba7d41f84c6ad1a304b2cec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 22:15:29 1993 +0000
+
+    (diff_2_files):  With -q, do not report that files differ
+    if all their differences are ignored.
+
+commit 78ec03a882b95cd29d36835ee428f88a48b3736e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 19:33:55 1993 +0000
+
+    entered into RCS
+
+commit 706124a32837bc01a160b73bb0271b9a041fb0d1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 21 20:38:19 1993 +0000
+
+    entered into RCS
+
+commit e86eac7b5fae39d4fb8243af9c25ebac661a4b2e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 23 17:18:44 1993 +0000
+
+    entered into RCS
+
+commit 8a5351c2de9e0f6464a981b2fb1973e03aa93e2f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 23 17:18:44 1993 +0000
+
+    *** empty log message ***
+
+commit 3319a943fbae0182341e75dc65721333a96dfc90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Apr 4 21:25:20 1993 +0000
+
+    Initial revision
+
+commit da717e72f7cc581ea23937ee7aface42e9857834
+Author: Roland McGrath <roland@gnu.org>
+Date:   Mon Mar 22 21:16:22 1993 +0000
+
+    *** empty log message ***
+
+commit 8aaab4f3e19e7bc4a92ded306ce665eca48cb776
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Fri Mar 5 05:20:07 1993 +0000
+
+    *** empty log message ***
+
+commit 4aaf705f814fac541e8789c4092b77371f8c6cf2
+Author: Roland McGrath <roland@gnu.org>
+Date:   Thu Feb 25 20:27:03 1993 +0000
+
+    *** empty log message ***
+
+commit 6ddf7e686bb00d6da06aa438a8106f8a8b635266
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Mon Feb 22 20:04:42 1993 +0000
+
+    *** empty log message ***
+
+commit ad75085c057c58ec6756f98fc5c086ae1cd7c477
+Author: Roland McGrath <roland@gnu.org>
+Date:   Mon Feb 22 17:56:35 1993 +0000
+
+    *** empty log message ***
+
+commit 1818943fac21d52fa810717c8f174ef137677b90
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Sun Feb 21 00:18:53 1993 +0000
+
+    *** empty log message ***
+
+commit 4cea33c405f2d9c1d0e91ab16c5b93fa17073526
+Author: Roland McGrath <roland@gnu.org>
+Date:   Fri Feb 19 22:39:37 1993 +0000
+
+    *** empty log message ***
+
+commit d1157d9215cb261635f663eba9c98b6434646fd2
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Thu Feb 11 18:48:31 1993 +0000
+
+    *** empty log message ***
+
+commit 6734c1e0ffd9014fe623192f651beb5543af6229
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Thu Feb 11 08:39:43 1993 +0000
+
+    entered into RCS
+
+commit 00e5d088e3627870d9574824de59a2272e50f4c7
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Thu Feb 11 08:36:08 1993 +0000
+
+    *** empty log message ***
+
+commit e5fb154b0cc6e9d24a7cdb62ff405eb497b823a8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 31 02:49:15 1993 +0000
+
+    entered into RCS
+
+commit 0448e625aeec1f3f5f1268411db0c1d20d204315
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jan 8 22:31:41 1993 +0000
+
+    *** empty log message ***
+
+commit a7544e448c174339ede7c11a70a3185ad5e0ee39
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 23 18:44:33 1992 +0000
+
+    *** empty log message ***
+
+commit 0689ff7f2b83e20fced9dbba9837d9478423f9ce
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 18 20:40:28 1992 +0000
+
+    *** empty log message ***
+
+commit be75ee024b368eb6cc359d64a0766baa2f5bad82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 17 20:10:49 1992 +0000
+
+    *** empty log message ***
+
+commit a07432e950d609619697805aaebe5434e673c779
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Nov 12 16:02:18 1992 +0000
+
+    entered into RCS
+
+commit 95ed3464570329da521604082b082e3bf832239e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Nov 12 16:02:18 1992 +0000
+
+    *** empty log message ***
+
+commit 8f4db99c5fe1b1bc0f9cb522e10289592acec0e0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 9 03:59:56 1992 +0000
+
+    *** empty log message ***
+
+commit ea33d3b33abaf4c10f0e8d49ac566ae92aa3e409
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 19 04:33:05 1992 +0000
+
+    entered into RCS
+
+commit 98b3abbdf5ba0b7e016209bb304eef5d1f6976c0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 10 01:53:56 1992 +0000
+
+    Initial revision
+
+commit f1e137e3dc5256b19dce9bc8492c841e1aaefacf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 5 05:18:46 1992 +0000
+
+    *** empty log message ***
+
+commit b98227d8eb71c53f9d3e12537e8410ebde0bf86e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 30 09:21:59 1992 +0000
+
+    entered into RCS
+
+commit 0bc4206adad21d679d7cadb7a578402b0e2b0a0a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 30 09:21:59 1992 +0000
+
+    *** empty log message ***
+
+commit 22548858bc47c5851f4d0c44ec7d8c6e8f281300
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 28 04:51:42 1992 +0000
+
+    *** empty log message ***
+
+commit bba40d01965c3af009b5bf033013f8cb529346bd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 27 05:38:13 1992 +0000
+
+    *** empty log message ***
+
+commit 5e96cefa2872848f2076694db7d77293eae56a14
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 24 15:18:07 1992 +0000
+
+    *** empty log message ***
+
+commit c8780b481ad26b919f3630079fc67d745edc8ce3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 24 05:54:14 1992 +0000
+
+    *** empty log message ***
+
+commit eecd1662a18c7b69f5521534c68d81652af33517
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Sep 15 03:59:44 1992 +0000
+
+    entered into RCS
+
+commit 9113c022e956cbee58d980f862cf265cfe031610
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Sep 15 03:15:49 1992 +0000
+
+    *** empty log message ***
+
+commit 639733d782e6cf581728ab4a924829eafc414cab
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Sat Sep 12 05:32:31 1992 +0000
+
+    *** empty log message ***
+
+commit 1ef94913174bad28ddbd4be07605bf7efd5e54a0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 23:00:36 1992 +0000
+
+    *** empty log message ***
+
+commit de7b7cb54a75a0331fb3edffbc4f07d085fc8ab1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 07:19:49 1992 +0000
+
+    *** empty log message ***
+
+commit 096465ae0dfe8bbc04e072a5503aee95896342ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 04:35:52 1992 +0000
+
+    *** empty log message ***
+
+commit 8ab03a75052de0f5b80d8f7d72160ff80eb0e453
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 04:35:52 1992 +0000
+
+    entered into RCS
+
+commit 01bd70f34606d248b4499dc7a081fff728874cd8
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Fri Sep 4 19:32:07 1992 +0000
+
+    *** empty log message ***
+
+commit 5f9f2a0445fe5059066ec49c15eb93ea057e1dfe
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Thu Sep 3 19:30:55 1992 +0000
+
+    *** empty log message ***
+
+commit 8f5a93cad7aab2a3a95c972546ae6eb778991048
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Fri Aug 14 07:38:17 1992 +0000
+
+    *** empty log message ***
+
+commit 3c488d0cb20eea79acf3c540b78a0f5399a8372f
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Thu Jul 16 20:56:16 1992 +0000
+
+    Initial revision
+
+commit 9a623661c76da444685f1c3ca8bb4580f013cfc3
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Jul 8 19:58:07 1992 +0000
+
+    entered into RCS
+
+commit 44b481aaa297582491bda6e5a1596715c25ddeb8
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Jul 8 19:46:10 1992 +0000
+
+    *** empty log message ***
+
+commit b2f3f8fcaa081c862a2255843f0b76d5fe7b71fb
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Jul 8 19:21:40 1992 +0000
+
+    Initial revision
+
+commit 6456bbcb000f5ed63d292784735927c30cd8b072
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 23:00:18 1992 +0000
+
+    *** empty log message ***
+
+commit df1eb75645ab62efff57fec5a9cac6c560f3f702
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 22:44:43 1992 +0000
+
+    Initial revision
+
+commit 2e9d141071cb6b33d62fdd978377c6498300656b
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 20:24:37 1992 +0000
+
+    Initial revision
+
+commit 8691ced4aabd114cdb74367161da732387ff9af7
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 20:23:47 1992 +0000
+
+    *** empty log message ***
+
+commit 4ca6ed131399d3d74f0d95041ff66ece1e416938
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 19:18:10 1992 +0000
+
+    *** empty log message ***
+
+commit d36834de48b7c513f2a5849e2a4aee275985744b
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 19:13:19 1992 +0000
+
+    Initial revision
+
+commit ab6c5254736e07241596fbd56b41ea5ad32d1f7e
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 07:33:49 1992 +0000
+
+    Initial revision
+
+commit aecd57a13df471e11e3f6abba9bfdbfa84cb47e2
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 07:32:29 1992 +0000
+
+    *** empty log message ***
+
+commit 1e9c0c48752ccc530417c730f8ebd432ffd6ecd4
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 07:23:07 1992 +0000
+
+    entered into RCS
+
+commit f11aa4bd8771b99b8ca3d37384eaa8349e54c561
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Fri Jul 3 18:31:18 1992 +0000
+
+    Initial revision
+
+commit 615c30008ee878beffa91d5181f8efeb5f756cd3
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue May 12 00:09:43 1992 +0000
+
+    Initial revision
+
+commit c8e2427fa22e3ecd5410358af1f343b168cb211c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 2 17:45:34 1992 +0000
+
+    Initial revision
+
+commit e9274e2af61de3ff67404a19e1b4e585b7709d8b
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Dec 24 05:09:33 1991 +0000
+
+    Initial revision
+
+commit b3c1e930b846248e3d1d0961547202c7b5d65bb2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 17 19:33:18 1991 +0000
+
+    Initial revision
+
+commit f9d66e6012b57e77bafd7b034a16c422cf454ab6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jul 26 15:24:24 1988 +0000
+
+    Initial revision
diff --git a/git-tags.txt b/git-tags.txt
new file mode 100644
index 0000000..6249466
--- /dev/null
+++ b/git-tags.txt
@@ -0,0 +1,15 @@
+v2.7
+v2.8
+v2.8.3
+v2.8.4
+v2.8.6
+v2.8.7
+v2.9
+v3.0
+v3.1
+v3.2
+v3.3
+v3.4
+v3.5
+v3.6
+v3.7
diff --git a/quote-3.0-patch.txt b/quote-3.0-patch.txt
new file mode 100644
index 0000000..658f89f
--- /dev/null
+++ b/quote-3.0-patch.txt
@@ -0,0 +1,326 @@
+diff --git a/src/cmp.c b/src/cmp.c
+index 2455dc4..e19f013 100644
+--- a/src/cmp.c
++++ b/src/cmp.c
+@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **argptr, char delimiter)
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@ usage (void)
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@ main (int argc, char **argv)
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@ main (int argc, char **argv)
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@ main (int argc, char **argv)
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+diff --git a/src/diff.c b/src/diff.c
+index cc1b611..256a984 100644
+--- a/src/diff.c
++++ b/src/diff.c
+@@ -330,7 +330,7 @@ main (int argc, char **argv)
+ 	      {
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+-		  try_help ("invalid context length `%s'", optarg);
++		  try_help ("invalid context length '%s'", optarg);
+ 		if (LIN_MAX < numval)
+ 		  numval = LIN_MAX;
+ 	      }
+@@ -505,7 +505,7 @@ main (int argc, char **argv)
+ 	case 'W':
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid width `%s'", optarg);
++	    try_help ("invalid width '%s'", optarg);
+ 	  if (width != numval)
+ 	    {
+ 	      if (width)
+@@ -534,7 +534,7 @@ main (int argc, char **argv)
+ 	case HORIZON_LINES_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (*numend)
+-	    try_help ("invalid horizon length `%s'", optarg);
++	    try_help ("invalid horizon length '%s'", optarg);
+ 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+ 	  break;
+ 
+@@ -585,7 +585,7 @@ main (int argc, char **argv)
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid tabsize `%s'", optarg);
++	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+ 	      if (tabsize)
+@@ -744,9 +744,9 @@ main (int argc, char **argv)
+ 	  if (argc - optind != 2)
+ 	    {
+ 	      if (argc - optind < 2)
+-		try_help ("missing operand after `%s'", argv[argc - 1]);
++		try_help ("missing operand after '%s'", argv[argc - 1]);
+ 	      else
+-		try_help ("extra operand `%s'", argv[optind + 2]);
++		try_help ("extra operand '%s'", argv[optind + 2]);
+ 	    }
+ 
+ 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+@@ -826,7 +826,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -870,11 +870,11 @@ static char const * const option_help_msgid[] = {
+   -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+   --left-column  Output only the left column of common lines.\n\
+   --suppress-common-lines  Do not output common lines."),
+-  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
++  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
++  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+   N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+@@ -895,7 +895,7 @@ static char const * const option_help_msgid[] = {
+     %c'C'  the single character C\n\
+     %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+@@ -918,9 +918,9 @@ static char const * const option_help_msgid[] = {
+   N_("-v  --version  Output version info."),
+   N_("--help  Output this help."),
+   "",
+-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+-  N_("If a FILE is `-', read standard input."),
++  N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+ };
+@@ -960,7 +960,7 @@ specify_value (char const **var, char const *value, char const *option)
+ {
+   if (*var && strcmp (*var, value) != 0)
+     {
+-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
++      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+     }
+   *var = value;
+@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *parent,
+ 	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+-	fatal ("cannot compare `-' to a directory");
++	fatal ("cannot compare '-' to a directory");
+ 
+       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+diff --git a/src/diff3.c b/src/diff3.c
+index 0f11fdc..fbfb28b 100644
+--- a/src/diff3.c
++++ b/src/diff3.c
+@@ -316,9 +316,9 @@ main (int argc, char **argv)
+   if (argc - optind != 3)
+     {
+       if (argc - optind < 3)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 3]);
++	try_help ("extra operand '%s'", argv[optind + 3]);
+     }
+ 
+   file = &argv[optind];
+@@ -351,7 +351,7 @@ main (int argc, char **argv)
+ 	 file instead.  */
+       common = 3 - common;
+       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+-	fatal ("`-' specified for more than one input file");
++	fatal ("'-' specified for more than one input file");
+     }
+ 
+   mapping[0] = 0;
+@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -435,7 +435,7 @@ static char const * const option_help_msgid[] = {
+   "",
+   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+-  N_("-i  Append `w' and `q' commands to ed scripts."),
++  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+   N_("-a  --text  Treat all files as text."),
+   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+@@ -460,7 +460,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -1275,12 +1275,12 @@ read_diff (char const *filea,
+   if (EXIT_TROUBLE <= status)
+     error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+-	     ? "subsidiary program `%s' could not be invoked"
++	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+-	     ? "subsidiary program `%s' not found"
++	     ? "subsidiary program '%s' not found"
+ 	     : status == INT_MAX
+-	     ? "subsidiary program `%s' failed"
+-	     : "subsidiary program `%s' failed (exit status %d)"),
++	     ? "subsidiary program '%s' failed"
++	     : "subsidiary program '%s' failed (exit status %d)"),
+ 	   diff_program, status);
+ 
+   return diff_result + total;
+diff --git a/src/dir.c b/src/dir.c
+index 5b4eaec..5e08318 100644
+--- a/src/dir.c
++++ b/src/dir.c
+@@ -154,7 +154,7 @@ compare_names (char const *name1, char const *name2)
+ 	r = strcoll (name1, name2);
+       if (errno)
+ 	{
+-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+ 		 name1, name2);
+ 	  longjmp (failed_locale_specific_sorting, 1);
+ 	}
+diff --git a/src/sdiff.c b/src/sdiff.c
+index 4344e8d..5bbecd8 100644
+--- a/src/sdiff.c
++++ b/src/sdiff.c
+@@ -175,7 +175,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -230,7 +230,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -286,12 +286,12 @@ check_child_status (int werrno, int wstatus, int max_ok_status,
+     {
+       error (0, werrno,
+ 	     _(status == 126
+-	       ? "subsidiary program `%s' could not be invoked"
++	       ? "subsidiary program '%s' could not be invoked"
+ 	       : status == 127
+-	       ? "subsidiary program `%s' not found"
++	       ? "subsidiary program '%s' not found"
+ 	       : status == INT_MAX
+-	       ? "subsidiary program `%s' failed"
+-	       : "subsidiary program `%s' failed (exit status %d)"),
++	       ? "subsidiary program '%s' failed"
++	       : "subsidiary program '%s' failed (exit status %d)"),
+ 	     subsidiary_program, status);
+       exiterr ();
+     }
+@@ -572,9 +572,9 @@ main (int argc, char *argv[])
+   if (argc - optind != 2)
+     {
+       if (argc - optind < 2)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 2]);
++	try_help ("extra operand '%s'", argv[optind + 2]);
+     }
+ 
+   if (! output)
+diff --git a/src/util.c b/src/util.c
+index 3be03e9..d18bf38 100644
+--- a/src/util.c
++++ b/src/util.c
+@@ -298,12 +298,12 @@ finish_output (void)
+       if (status)
+ 	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+-		 ? "subsidiary program `%s' could not be invoked"
++		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+-		 ? "subsidiary program `%s' not found"
++		 ? "subsidiary program '%s' not found"
+ 		 : status == INT_MAX
+-		 ? "subsidiary program `%s' failed"
+-		 : "subsidiary program `%s' failed (exit status %d)"),
++		 ? "subsidiary program '%s' failed"
++		 : "subsidiary program '%s' failed (exit status %d)"),
+ 	       pr_program, status);
+     }
+ 
diff --git a/quote-3.0-test.txt b/quote-3.0-test.txt
new file mode 100644
index 0000000..fa9a348
--- /dev/null
+++ b/quote-3.0-test.txt
@@ -0,0 +1,320 @@
+diff -pru diffutils-3.0/cmp.c diffutils-3.0-patch/cmp.c
+--- diffutils-3.0/cmp.c	2019-03-14 18:31:07.186534000 -0700
++++ diffutils-3.0-patch/cmp.c	2019-03-14 18:32:05.687224000 -0700
+@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **ar
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@ usage (void)
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@ main (int argc, char **argv)
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@ main (int argc, char **argv)
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@ main (int argc, char **argv)
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+diff -pru diffutils-3.0/diff3.c diffutils-3.0-patch/diff3.c
+--- diffutils-3.0/diff3.c	2019-03-14 18:31:07.193527000 -0700
++++ diffutils-3.0-patch/diff3.c	2019-03-14 18:32:05.712200000 -0700
+@@ -316,9 +316,9 @@ main (int argc, char **argv)
+   if (argc - optind != 3)
+     {
+       if (argc - optind < 3)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 3]);
++	try_help ("extra operand '%s'", argv[optind + 3]);
+     }
+ 
+   file = &argv[optind];
+@@ -351,7 +351,7 @@ main (int argc, char **argv)
+ 	 file instead.  */
+       common = 3 - common;
+       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+-	fatal ("`-' specified for more than one input file");
++	fatal ("'-' specified for more than one input file");
+     }
+ 
+   mapping[0] = 0;
+@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -435,7 +435,7 @@ static char const * const option_help_ms
+   "",
+   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+-  N_("-i  Append `w' and `q' commands to ed scripts."),
++  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+   N_("-a  --text  Treat all files as text."),
+   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+@@ -460,7 +460,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -1275,12 +1275,12 @@ read_diff (char const *filea,
+   if (EXIT_TROUBLE <= status)
+     error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+-	     ? "subsidiary program `%s' could not be invoked"
++	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+-	     ? "subsidiary program `%s' not found"
++	     ? "subsidiary program '%s' not found"
+ 	     : status == INT_MAX
+-	     ? "subsidiary program `%s' failed"
+-	     : "subsidiary program `%s' failed (exit status %d)"),
++	     ? "subsidiary program '%s' failed"
++	     : "subsidiary program '%s' failed (exit status %d)"),
+ 	   diff_program, status);
+ 
+   return diff_result + total;
+diff -pru diffutils-3.0/diff.c diffutils-3.0-patch/diff.c
+--- diffutils-3.0/diff.c	2019-03-14 18:31:07.196525000 -0700
++++ diffutils-3.0-patch/diff.c	2019-03-14 18:32:05.727184000 -0700
+@@ -330,7 +330,7 @@ main (int argc, char **argv)
+ 	      {
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+-		  try_help ("invalid context length `%s'", optarg);
++		  try_help ("invalid context length '%s'", optarg);
+ 		if (LIN_MAX < numval)
+ 		  numval = LIN_MAX;
+ 	      }
+@@ -505,7 +505,7 @@ main (int argc, char **argv)
+ 	case 'W':
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid width `%s'", optarg);
++	    try_help ("invalid width '%s'", optarg);
+ 	  if (width != numval)
+ 	    {
+ 	      if (width)
+@@ -534,7 +534,7 @@ main (int argc, char **argv)
+ 	case HORIZON_LINES_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (*numend)
+-	    try_help ("invalid horizon length `%s'", optarg);
++	    try_help ("invalid horizon length '%s'", optarg);
+ 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+ 	  break;
+ 
+@@ -585,7 +585,7 @@ main (int argc, char **argv)
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid tabsize `%s'", optarg);
++	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+ 	      if (tabsize)
+@@ -744,9 +744,9 @@ main (int argc, char **argv)
+ 	  if (argc - optind != 2)
+ 	    {
+ 	      if (argc - optind < 2)
+-		try_help ("missing operand after `%s'", argv[argc - 1]);
++		try_help ("missing operand after '%s'", argv[argc - 1]);
+ 	      else
+-		try_help ("extra operand `%s'", argv[optind + 2]);
++		try_help ("extra operand '%s'", argv[optind + 2]);
+ 	    }
+ 
+ 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+@@ -826,7 +826,7 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -870,11 +870,11 @@ static char const * const option_help_ms
+   -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+   --left-column  Output only the left column of common lines.\n\
+   --suppress-common-lines  Do not output common lines."),
+-  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
++  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
++  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+   N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+@@ -895,7 +895,7 @@ static char const * const option_help_ms
+     %c'C'  the single character C\n\
+     %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+@@ -918,9 +918,9 @@ static char const * const option_help_ms
+   N_("-v  --version  Output version info."),
+   N_("--help  Output this help."),
+   "",
+-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+-  N_("If a FILE is `-', read standard input."),
++  N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+ };
+@@ -960,7 +960,7 @@ specify_value (char const **var, char co
+ {
+   if (*var && strcmp (*var, value) != 0)
+     {
+-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
++      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+     }
+   *var = value;
+@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *
+ 	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+-	fatal ("cannot compare `-' to a directory");
++	fatal ("cannot compare '-' to a directory");
+ 
+       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+diff -pru diffutils-3.0/dir.c diffutils-3.0-patch/dir.c
+--- diffutils-3.0/dir.c	2019-03-14 18:31:07.202518000 -0700
++++ diffutils-3.0-patch/dir.c	2019-03-14 18:32:05.735175000 -0700
+@@ -154,7 +154,7 @@ compare_names (char const *name1, char c
+ 	r = strcoll (name1, name2);
+       if (errno)
+ 	{
+-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+ 		 name1, name2);
+ 	  longjmp (failed_locale_specific_sorting, 1);
+ 	}
+diff -pru diffutils-3.0/sdiff.c diffutils-3.0-patch/sdiff.c
+--- diffutils-3.0/sdiff.c	2019-03-14 18:31:07.220500000 -0700
++++ diffutils-3.0-patch/sdiff.c	2019-03-14 18:32:05.774155000 -0700
+@@ -175,7 +175,7 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -230,7 +230,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -286,12 +286,12 @@ check_child_status (int werrno, int wsta
+     {
+       error (0, werrno,
+ 	     _(status == 126
+-	       ? "subsidiary program `%s' could not be invoked"
++	       ? "subsidiary program '%s' could not be invoked"
+ 	       : status == 127
+-	       ? "subsidiary program `%s' not found"
++	       ? "subsidiary program '%s' not found"
+ 	       : status == INT_MAX
+-	       ? "subsidiary program `%s' failed"
+-	       : "subsidiary program `%s' failed (exit status %d)"),
++	       ? "subsidiary program '%s' failed"
++	       : "subsidiary program '%s' failed (exit status %d)"),
+ 	     subsidiary_program, status);
+       exiterr ();
+     }
+@@ -572,9 +572,9 @@ main (int argc, char *argv[])
+   if (argc - optind != 2)
+     {
+       if (argc - optind < 2)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 2]);
++	try_help ("extra operand '%s'", argv[optind + 2]);
+     }
+ 
+   if (! output)
+diff -pru diffutils-3.0/util.c diffutils-3.0-patch/util.c
+--- diffutils-3.0/util.c	2019-03-14 18:31:07.226494000 -0700
++++ diffutils-3.0-patch/util.c	2019-03-14 18:32:05.795156000 -0700
+@@ -298,12 +298,12 @@ finish_output (void)
+       if (status)
+ 	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+-		 ? "subsidiary program `%s' could not be invoked"
++		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+-		 ? "subsidiary program `%s' not found"
++		 ? "subsidiary program '%s' not found"
+ 		 : status == INT_MAX
+-		 ? "subsidiary program `%s' failed"
+-		 : "subsidiary program `%s' failed (exit status %d)"),
++		 ? "subsidiary program '%s' failed"
++		 : "subsidiary program '%s' failed (exit status %d)"),
+ 	       pr_program, status);
+     }
+ 
diff --git a/quote-patch.txt b/quote-patch.txt
new file mode 100644
index 0000000..050e81b
--- /dev/null
+++ b/quote-patch.txt
@@ -0,0 +1,1195 @@
+commit 62ca21c8c1a5aa3488589dcb191a4ef04ae9ed4f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 25 23:46:16 2012 -0800
+
+    maint: quote 'like this' or "like this", not `like this'
+    
+    This is in response to a recent change in the GNU coding standards,
+    which now suggest quoting 'like this' or "like this", instead of
+    `like this' or ``like this''.
+    * HACKING, NEWS, README, README-hacking, TODO, doc/diagmeet.note:
+    * doc/diffutils.texi, ms/config.bat, ms/config.site:
+    * src/analyze.c, src/cmp.c, src/context.c, src/diff.c:
+    * src/diff.h, src/diff3.c, src/dir.c, src/ifdef.c, src/io.c:
+    * src/sdiff.c, src/side.c, src/system.h, src/util.c:
+    * tests/help-version:
+    Quote 'like this' or "like this" in commentary.
+    * cfg.mk (old_NEWS_hash): Adjust to reflect new NEWS quoting.
+    * man/help2man: Update to 1.40.4 version, with quoting fixed as above.
+    * po/en.po: Remove translation involving `, as it's no longer needed.
+    * src/cmp.c (try_help, specify_ignore_initial, usage, main):
+    * src/diff.c (main, try_help, option_help_msgid, specify_value)
+    (compare_files):
+    * src/diff3.c (main, try_help, option_help_msgid, usage)
+    (read_diff):
+    * src/dir.c (compare_names):
+    * src/sdiff.c (try_help, usage, check_child_status, main):
+    * src/util.c (finish_output):
+    * tests/help-version:
+    Quote 'like this' in output.
+
+diff --git a/HACKING b/HACKING
+index 3a99833..522e0b5 100644
+--- a/HACKING
++++ b/HACKING
+@@ -587,5 +587,5 @@ Permission is granted to copy, distribute and/or modify this document
+ under the terms of the GNU Free Documentation License, Version 1.3 or
+ any later version published by the Free Software Foundation; with no
+ Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
+-Texts.  A copy of the license is included in the ``GNU Free
+-Documentation License'' file as part of this distribution.
++Texts.  A copy of the license is included in the "GNU Free
++Documentation License" file as part of this distribution.
+diff --git a/NEWS b/NEWS
+index 8105f1d..808c603 100644
+--- a/NEWS
++++ b/NEWS
+@@ -58,7 +58,7 @@ GNU diffutils NEWS                                    -*- outline -*-
+ 
+   New diff option --suppress-blank-empty.
+ 
+-  Bring back support for `diff -NUM', where NUM is a number,
++  Bring back support for 'diff -NUM', where NUM is a number,
+   even when conforming to POSIX 1003.1-2001.  This change reverts to
+   the behavior of GNU diff 2.7 and earlier.  This is a change only
+   when conforming to POSIX 1003.1-2001; there is no effect when
+@@ -94,7 +94,7 @@ User-visible changes in version 2.8.6:
+   that 'patch' creates to indicate nonexistent backups) are now
+   treated as nonexistent when they are in the 'backup' file position.
+ 
+-* If multiple SKIP values are given to cmp, e.g., `cmp -i 10 -i 20',
++* If multiple SKIP values are given to cmp, e.g., 'cmp -i 10 -i 20',
+   cmp now uses the maximal value instead of the last one.
+ 
+ * diff now omits the ".000000000" on hosts that do not support
+@@ -134,7 +134,7 @@ User-visible changes in version 2.8:
+ * cmp and diff now conform to POSIX 1003.1-2001 (IEEE Std 1003.1-2001)
+   if the underlying system conforms to POSIX and if the _POSIX2_VERSION
+   environment variable is set to 200112.  Conformance removes support
+-  for `diff -NUM', where NUM is a number.  Use -C NUM or -U NUM instead.
++  for 'diff -NUM', where NUM is a number.  Use -C NUM or -U NUM instead.
+ * cmp now supports trailing operands SKIP1 and SKIP2, like BSD cmp.
+ * cmp -i or --ignore-initial now accepts SKIP1:SKIP2 option value.
+ * New cmp option: -n or --bytes.
+@@ -168,13 +168,13 @@ User-visible changes in version 2.8:
+   category if possible, instead of using native byte comparison.
+ * Recursive diffs now detect and report directory loops.
+ * Diff printf specs can now use the "0" and "'" flags.
+-* The new sdiff interactive command `ed' precedes each version with a header.
++* The new sdiff interactive command 'ed' precedes each version with a header.
+ * On 64-bit hosts, files larger than 2 GB can be compared.
+ * Some internationalization support has been added, but multibyte locales
+   are still not completely supported yet.
+ * Some diagnostics have been reworded slightly for consistency.
+-  Also, `diff -D FOO' now outputs `/* ! FOO */' instead of `/* not FOO */'.
+-* The `patch' part of the manual now describes `patch' version 2.5.4.
++  Also, 'diff -D FOO' now outputs '/* ! FOO */' instead of '/* not FOO */'.
++* The 'patch' part of the manual now describes 'patch' version 2.5.4.
+ * Man pages are now distributed and installed.
+ * There is support for DJGPP; see the 'ms' subdirectory and the files
+   m4/dos.m4 and */setmode.*.
+@@ -212,7 +212,7 @@ User-visible changes in version 2.4:
+       A printf spec followed by one of the following letters
+       causes the integer corresponding to that letter to be
+       printed according to the printf specification.
+-      E.g. `%5df' prints the number of the first line in the
++      E.g. '%5df' prints the number of the first line in the
+       group in the old file using the "%5d" format.
+ 	e: line number just before the group in old file; equals f - 1
+ 	f: first line number in group in the old file
+@@ -225,9 +225,9 @@ User-visible changes in version 2.4:
+       constant or a single letter interpreted as above.  T and E are
+       arbitrary format strings.  This format spec is equivalent to T if
+       A's value equals B's; otherwise it is equivalent to E.  For
+-      example, `%(N=0?no:%dN) line%(N=1?:s)' is equivalent to `no lines'
++      example, '%(N=0?no:%dN) line%(N=1?:s)' is equivalent to 'no lines'
+       if N (the number of lines in the group in the new file) is 0,
+-      to `1 line' if N is 1, and to `%dN lines' otherwise.
++      to '1 line' if N is 1, and to '%dN lines' otherwise.
+   %c'C'
+       where C is a single character, stands for the character C.  C may not
+       be a backslash or an apostrophe.  E.g. %c':' stands for a colon.
+@@ -237,7 +237,7 @@ User-visible changes in version 2.4:
+ * New diff line format specifications:
+   <PRINTF_SPEC>n
+       The line number, printed with <PRINTF_SPEC>.
+-      E.g. `%5dn' prints the line number with a "%5d" format.
++      E.g. '%5dn' prints the line number with a "%5d" format.
+   %c'C'
+   %c'\O'
+       The character C, or with octal code O, as above.
+@@ -249,14 +249,14 @@ User-visible changes in version 2.4:
+ * cmp and diff now conform to POSIX 1003.2-1992 (ISO/IEC 9945-2:1993)
+   if the underlying system conforms to POSIX:
+   - Some messages' wordings are changed in minor ways.
+-  - ``White space'' is now whatever C's `isspace' says it is.
+-  - When comparing directories, if `diff' finds a file that is not a regular
++  - "White space" is now whatever C's 'isspace' says it is.
++  - When comparing directories, if 'diff' finds a file that is not a regular
+     file or a directory, it reports the file's type instead of diffing it.
+     (As usual, it follows symbolic links first.)
+   - When signaled, sdiff exits with the signal's status, not with status 2.
+ * Now portable to hosts where int, long, pointer, etc. are not all the same
+   size.
+-* `cmp - -' now works like `diff - -'.
++* 'cmp - -' now works like 'diff - -'.
+ 
+ 
+ User-visible changes in version 2.3:
+diff --git a/README b/README
+index b249c56..ddab36e 100644
+--- a/README
++++ b/README
+@@ -9,8 +9,8 @@ Please see the file COPYING for copying conditions.
+ Please see the file doc/version.texi for version information.
+ 
+ Please see the file doc/diffutils.texi (or doc/diffutils.info) for
+-documentation that can be printed with TeX, or read with the `info'
+-program or with Emacs's `M-x info'.  Brief man pages are in man/*,
++documentation that can be printed with TeX, or read with the 'info'
++program or with Emacs's 'M-x info'.  Brief man pages are in man/*,
+ but they are no substitute for the documentation.
+ 
+ Please see the file ABOUT-NLS for notes about translations.
+@@ -21,7 +21,7 @@ command "./configure --help" lists the supported --enable and --with
+ options.
+ 
+ If you have a problem with internationalization, you might be able to
+-work around it as described in ABOUT-NLS by invoking `./configure
++work around it as described in ABOUT-NLS by invoking './configure
+ --disable-nls'.  Many of the problems arise from dynamic linking
+ issues on non-GNU platforms (e.g. with the iconv library).  Such
+ problems tend to be shared by other GNU applications on these
+@@ -60,5 +60,5 @@ Permission is granted to copy, distribute and/or modify this document
+ under the terms of the GNU Free Documentation License, Version 1.3 or
+ any later version published by the Free Software Foundation; with no
+ Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
+-Texts.  A copy of the license is included in the ``GNU Free
+-Documentation License'' file as part of this distribution.
++Texts.  A copy of the license is included in the "GNU Free
++Documentation License" file as part of this distribution.
+diff --git a/README-hacking b/README-hacking
+index b5dc6f8..e276592 100644
+--- a/README-hacking
++++ b/README-hacking
+@@ -19,7 +19,7 @@ Valgrind <http://valgrind.org/> is also highly recommended, if
+ Valgrind supports your architecture.
+ 
+ While building from a just-cloned source tree may require installing a
+-few prerequisites, later, a plain `git pull && make' should be sufficient.
++few prerequisites, later, a plain 'git pull && make' should be sufficient.
+ 
+ * First GIT checkout
+ 
+diff --git a/TODO b/TODO
+index f8dc34a..5132de8 100644
+--- a/TODO
++++ b/TODO
+@@ -6,4 +6,4 @@ http://www.pkix.net/~chuck/sdiff2.diff
+ Propagate stderr from subprocess so that diff3 does
+ a better job of explaining _why_:
+   > $ diff3 /bin/sh /bin/false /bin/mv
+-  > diff3: subsidiary program `diff' failed (exit status 2)
++  > diff3: subsidiary program 'diff' failed (exit status 2)
+diff --git a/cfg.mk b/cfg.mk
+index f4d58db..72fddc0 100644
+--- a/cfg.mk
++++ b/cfg.mk
+@@ -29,7 +29,7 @@ bootstrap-tools = autoconf,automake,gnulib
+ # Now that we have better tests, make this the default.
+ export VERBOSE = yes
+ 
+-old_NEWS_hash = becaac48768c0024859d5837010c801e
++old_NEWS_hash = 7d70c18e90495732e671b3c94da01651
+ 
+ # Tell maint.mk's syntax-check rules that diff gets config.h directly or
+ # via diff.h or system.h.
+diff --git a/doc/diagmeet.note b/doc/diagmeet.note
+index 9ffd175..2d30d21 100644
+--- a/doc/diagmeet.note
++++ b/doc/diagmeet.note
+@@ -1,5 +1,5 @@
+ Here is a comparison matrix which shows a case in which
+-it is possible for the forward and backward scan in `diag'
++it is possible for the forward and backward scan in 'diag'
+ to meet along a nonzero length of diagonal simultaneous
+ (so that bdiag[d] and fdiag[d] are not equal)
+ even though there is no snake on that diagonal at the meeting point.
+diff --git a/doc/diffutils.texi b/doc/diffutils.texi
+index 58b140c..00403df 100644
+--- a/doc/diffutils.texi
++++ b/doc/diffutils.texi
+@@ -3190,7 +3190,7 @@ characters.
+ @c locale.
+ @c @item locale
+ @c @c Use @t instead of @samp to avoid duplicate quoting in some output styles.
+-@c Like @samp{clocale}, but quote @t{`like this'} instead of @t{"like
++@c Like @samp{clocale}, but quote @t{'like this'} instead of @t{"like
+ @c this"} in the default C locale.  This looks nicer on many displays.
+ @end table
+ 
+diff --git a/man/help2man b/man/help2man
+index f9983f7..8bc961c 100755
+--- a/man/help2man
++++ b/man/help2man
+@@ -1,7 +1,8 @@
+ #!/usr/bin/perl -w
+ 
+ # Generate a short man page from --help and --version output.
+-# Copyright (C) 1997-2005, 2009-2012 Free Software Foundation, Inc.
++# Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2009, 2010,
++# 2011 Free Software Foundation, Inc.
+ 
+ # This program is free software; you can redistribute it and/or modify
+ # it under the terms of the GNU General Public License as published by
+@@ -27,7 +28,7 @@ use Text::Tabs qw(expand);
+ use POSIX qw(strftime setlocale LC_ALL);
+ 
+ my $this_program = 'help2man';
+-my $this_version = '1.39.2';
++my $this_version = '1.40.4';
+ 
+ sub _ { $_[0] }
+ sub configure_locale
+@@ -55,7 +56,7 @@ Written by Brendan O'Dea <bod@debian.org>
+ EOT
+ 
+ my $help_info = enc_user sprintf _(<<'EOT'), $this_program, $this_program;
+-`%s' generates a man page out of `--help' and `--version' output.
++'%s' generates a man page out of '--help' and '--version' output.
+ 
+ Usage: %s [OPTION]... EXECUTABLE
+ 
+@@ -64,16 +65,16 @@ Usage: %s [OPTION]... EXECUTABLE
+  -m, --manual=TEXT       name of manual (User Commands, ...)
+  -S, --source=TEXT       source of program (FSF, Debian, ...)
+  -L, --locale=STRING     select locale (default "C")
+- -i, --include=FILE      include material from `FILE'
+- -I, --opt-include=FILE  include material from `FILE' if it exists
+- -o, --output=FILE       send output to `FILE'
++ -i, --include=FILE      include material from 'FILE'
++ -I, --opt-include=FILE  include material from 'FILE' if it exists
++ -o, --output=FILE       send output to 'FILE'
+  -p, --info-page=TEXT    name of Texinfo manual
+  -N, --no-info           suppress pointer to Texinfo manual
+- -l, --libtool           exclude the `lt-' from the program name
++ -l, --libtool           exclude the 'lt-' from the program name
+      --help              print this help, then exit
+      --version           print version number, then exit
+ 
+-EXECUTABLE should accept `--help' and `--version' options and produce output on
++EXECUTABLE should accept '--help' and '--version' options and produce output on
+ stdout although alternatives may be specified using:
+ 
+  -h, --help-option=STRING     help option string
+@@ -137,7 +138,7 @@ while (@opt_include)
+     my ($inc, $required) = @{shift @opt_include};
+ 
+     next unless -f $inc or $required;
+-    kark N_("%s: can't open `%s' (%s)"), $this_program, $inc, $!
++    kark N_("%s: can't open '%s' (%s)"), $this_program, $inc, $!
+ 	unless open INC, $inc;
+ 
+     my $key;
+@@ -198,7 +199,7 @@ while (@opt_include)
+ 
+     close INC;
+ 
+-    kark N_("%s: no valid information found in `%s'"), $this_program, $inc
++    kark N_("%s: no valid information found in '%s'"), $this_program, $inc
+ 	unless $key;
+ }
+ 
+@@ -214,7 +215,11 @@ sub get_option_value;
+ my $help_text   = get_option_value $ARGV[0], $help_option;
+ $version_text ||= get_option_value $ARGV[0], $version_option;
+ 
+-my $date = strftime "%B %Y", localtime;
++# Translators: the following message is a strftime(3) format string, which in
++# the English version expands to the month as a word and the full year.  It
++# is used on the footer of the generated manual pages.  If in doubt, you may
++# just use %x as the value (which should be the full locale-specific date).
++my $date = enc strftime _("%B %Y"), localtime;
+ (my $program = $ARGV[0]) =~ s!.*/!!;
+ my $package = $program;
+ my $version;
+@@ -261,7 +266,7 @@ else
+ 
+ $program =~ s!.*/!!;
+ 
+-# No info for `info' itself.
++# No info for 'info' itself.
+ $opt_no_info = 1 if $program eq 'info';
+ 
+ # Translators: "NAME", "SYNOPSIS" and other one or two word strings in all
+@@ -637,9 +642,9 @@ sub get_option_value
+ 
+     unless ($value)
+     {
+-	my $err = N_("%s: can't get `%s' info from %s%s");
++	my $err = N_("%s: can't get '%s' info from %s%s");
+ 	my $extra = $discard_stderr
+-	    ? "\n" . N_("Try `--no-discard-stderr' if option outputs to stderr")
++	    ? "\n" . N_("Try '--no-discard-stderr' if option outputs to stderr")
+ 	    : '';
+ 
+ 	kark $err, $this_program, $opt, $prog, $extra;
+diff --git a/ms/config.bat b/ms/config.bat
+index 44ef13b..57d5f3f 100644
+--- a/ms/config.bat
++++ b/ms/config.bat
+@@ -134,7 +134,7 @@ if not errorlevel 1 mv -f %XSRC%/m4/Makefile.am.in %XSRC%/m4/Makefile.am-in
+ 
+ Rem This is required because DOS/Windows are case-insensitive
+ Rem to file names, and "make install" will do nothing if Make
+-Rem finds a file called `install'.
++Rem finds a file called 'install'.
+ if exist INSTALL ren INSTALL INSTALL.txt
+ 
+ Rem Set HOME to a sane default so configure stops complaining.
+diff --git a/ms/config.site b/ms/config.site
+index 31f9aff..c863616 100644
+--- a/ms/config.site
++++ b/ms/config.site
+@@ -73,6 +73,6 @@ MAKEINFO=${MAKEINFO='makeinfo'}
+ # Force the test for 'ln -s' to report 'cp -pf'.
+ ac_cv_prog_LN_S='cp -pf'
+ 
+-# We have `fork', but it always fails.  Don't trust Autoconf to be
++# We have 'fork', but it always fails.  Don't trust Autoconf to be
+ # smart enough to detect that...
+ ac_cv_func_fork=no
+diff --git a/po/en.po b/po/en.po
+index c95e389..ad59232 100644
+--- a/po/en.po
++++ b/po/en.po
+@@ -4,23 +4,15 @@
+ #
+ msgid ""
+ msgstr ""
+-"Project-Id-Version: GNU diffutils 2.8.3\n"
++"Project-Id-Version: GNU diffutils 3.2\n"
+ "POT-Creation-Date: 2002-06-16 23:44-0700\n"
+-"PO-Revision-Date: 2002-06-17 00:01-0700\n"
+-"Last-Translator: Paul Eggert <eggert@twinsun.com>\n"
++"PO-Revision-Date: 2012-01-25 23:11-0700\n"
++"Last-Translator: Paul Eggert <eggert@cs.ucla.edu>\n"
+ "Language-Team: English <en@translate.freefriends.org>\n"
+ "MIME-Version: 1.0\n"
+ "Content-Type: text/plain; charset=ISO-8859-1\n"
+ "Content-Transfer-Encoding: 8bit\n"
+ 
+-# POSIX requires the word "illegal" in the POSIX locale, but the error
+-# is not really against the law.  This is not the POSIX locale, so fix
+-# the wording.
+-#: lib/getopt.c:800
+-#, c-format
+-msgid "%s: illegal option -- %c\n"
+-msgstr "%s: unrecognized option `-%c'\n"
+-
+ #. TRANSLATORS: Please translate "(C)" to the C-in-a-circle symbol
+ #. (U+00A9, COPYRIGHT SIGN) if possible, as this has some minor
+ #. technical advantages in international copyright law.  If the
+diff --git a/src/analyze.c b/src/analyze.c
+index 124ded5..0e61a82 100644
+--- a/src/analyze.c
++++ b/src/analyze.c
+@@ -38,7 +38,7 @@
+ 
+    A line which is discarded will not be considered by the actual
+    comparison algorithm; it will be as if that line were not in the file.
+-   The file's `realindexes' table maps virtual line numbers
++   The file's 'realindexes' table maps virtual line numbers
+    (which don't count the discarded lines) into real line numbers;
+    this is how the actual comparison algorithm produces results
+    that are comprehensible when the discarded lines are counted.
+@@ -251,7 +251,7 @@ discard_confusing_lines (struct file_data filevec[])
+    We do something when a run of changed lines include a
+    line at one end and have an excluded, identical line at the other.
+    We are free to choose which identical line is included.
+-   `compareseq' usually chooses the one at the beginning,
++   'compareseq' usually chooses the one at the beginning,
+    but usually it is cleaner to consider the following identical line
+    to be the "change".  */
+ 
+@@ -595,7 +595,7 @@ diff_2_files (struct comparison *cmp)
+       shift_boundaries (cmp->file);
+ 
+       /* Get the results of comparison in the form of a chain
+-	 of `struct change's -- an edit script.  */
++	 of 'struct change's -- an edit script.  */
+ 
+       if (output_style == OUTPUT_ED)
+ 	script = build_reverse_script (cmp->file);
+diff --git a/src/cmp.c b/src/cmp.c
+index 53ae791..1387ec1 100644
+--- a/src/cmp.c
++++ b/src/cmp.c
+@@ -36,7 +36,7 @@
+ #include <binary-io.h>
+ #include <xstrtol.h>
+ 
+-/* The official name of this program (e.g., no `g' prefix).  */
++/* The official name of this program (e.g., no 'g' prefix).  */
+ #define PROGRAM_NAME "cmp"
+ 
+ #define AUTHORS \
+@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **argptr, char delimiter)
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -191,7 +191,7 @@ Mandatory arguments to long options are mandatory for short options too.\n\
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -237,7 +237,7 @@ main (int argc, char **argv)
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -263,7 +263,7 @@ main (int argc, char **argv)
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -275,7 +275,7 @@ main (int argc, char **argv)
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+@@ -370,8 +370,8 @@ main (int argc, char **argv)
+   return exit_status;
+ }
+ 
+-/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+-   using `buffer[0]' and `buffer[1]'.
++/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
++   using 'buffer[0]' and 'buffer[1]'.
+    Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+    >1 if error.  */
+ 
+@@ -383,7 +383,7 @@ cmp (void)
+   uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+   size_t read0, read1;		/* Number of bytes read from each file. */
+   size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+-  size_t smaller;		/* The lesser of `read0' and `read1'. */
++  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
+   word *buffer0 = buffer[0];
+   word *buffer1 = buffer[1];
+   char *buf0 = (char *) buffer0;
+diff --git a/src/context.c b/src/context.c
+index bd1c981..b73d5c3 100644
+--- a/src/context.c
++++ b/src/context.c
+@@ -158,7 +158,7 @@ print_context_function (FILE *out, char const *function)
+ 
+ /* Print a portion of an edit script in context format.
+    HUNK is the beginning of the portion to be printed.
+-   The end is marked by a `link' that has been nulled out.
++   The end is marked by a 'link' that has been nulled out.
+ 
+    Prints out lines from both files, and precedes each
+    line with the appropriate flag-character.  */
+@@ -288,7 +288,7 @@ print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+ 
+ /* Print a portion of an edit script in unidiff format.
+    HUNK is the beginning of the portion to be printed.
+-   The end is marked by a `link' that has been nulled out.
++   The end is marked by a 'link' that has been nulled out.
+ 
+    Prints out lines from both files, and precedes each
+    line with the appropriate flag-character.  */
+@@ -392,7 +392,7 @@ pr_unidiff_hunk (struct change *hunk)
+ 
+ /* Scan a (forward-ordered) edit script for the first place that more than
+    2*CONTEXT unchanged lines appear, and return a pointer
+-   to the `struct change' for the last change before those lines.  */
++   to the 'struct change' for the last change before those lines.  */
+ 
+ static struct change * _GL_ATTRIBUTE_PURE
+ find_hunk (struct change *start)
+@@ -430,7 +430,7 @@ find_hunk (struct change *start)
+   return prev;
+ }
+ 
+-/* Set the `ignore' flag properly in each change in SCRIPT.
++/* Set the 'ignore' flag properly in each change in SCRIPT.
+    It should be 1 if all the lines inserted or deleted in that change
+    are ignorable lines.  */
+ 
+@@ -458,7 +458,7 @@ mark_ignorable (struct change *script)
+ }
+ 
+ /* Find the last function-header line in LINBUF prior to line number LINENUM.
+-   This is a line containing a match for the regexp in `function_regexp'.
++   This is a line containing a match for the regexp in 'function_regexp'.
+    Return the address of the text, or NULL if no function-header is found.  */
+ 
+ static char const *
+diff --git a/src/diff.c b/src/diff.c
+index 0911131..972d84d 100644
+--- a/src/diff.c
++++ b/src/diff.c
+@@ -42,7 +42,7 @@
+ #include <xreadlink.h>
+ #include <binary-io.h>
+ 
+-/* The official name of this program (e.g., no `g' prefix).  */
++/* The official name of this program (e.g., no 'g' prefix).  */
+ #define PROGRAM_NAME "diff"
+ 
+ #define AUTHORS \
+@@ -59,9 +59,9 @@
+ struct regexp_list
+ {
+   char *regexps;	/* chars representing disjunction of the regexps */
+-  size_t len;		/* chars used in `regexps' */
+-  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
+-  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
++  size_t len;		/* chars used in 'regexps' */
++  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
++  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
+   struct re_pattern_buffer *buf;
+ };
+ 
+@@ -94,13 +94,13 @@ enum { binary = true };
+ 
+ /* When comparing directories, if a file appears only in one
+    directory, treat it as present but empty in the other (-N).
+-   Then `patch' would create the file with appropriate contents.  */
++   Then 'patch' would create the file with appropriate contents.  */
+ static bool new_file;
+ 
+ /* When comparing directories, if a file appears only in the second
+    directory of the two, treat it as present but empty in the other
+    (--unidirectional-new-file).
+-   Then `patch' would create the file with appropriate contents.  */
++   Then 'patch' would create the file with appropriate contents.  */
+ static bool unidirectional_new_file;
+ 
+ /* Report files compared that are the same (-s).
+@@ -340,7 +340,7 @@ main (int argc, char **argv)
+ 	      {
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+-		  try_help ("invalid context length `%s'", optarg);
++		  try_help ("invalid context length '%s'", optarg);
+ 		if (LIN_MAX < numval)
+ 		  numval = LIN_MAX;
+ 	      }
+@@ -515,7 +515,7 @@ main (int argc, char **argv)
+ 	case 'W':
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid width `%s'", optarg);
++	    try_help ("invalid width '%s'", optarg);
+ 	  if (width != numval)
+ 	    {
+ 	      if (width)
+@@ -544,7 +544,7 @@ main (int argc, char **argv)
+ 	case HORIZON_LINES_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (*numend)
+-	    try_help ("invalid horizon length `%s'", optarg);
++	    try_help ("invalid horizon length '%s'", optarg);
+ 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+ 	  break;
+ 
+@@ -599,7 +599,7 @@ main (int argc, char **argv)
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid tabsize `%s'", optarg);
++	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+ 	      if (tabsize)
+@@ -758,9 +758,9 @@ main (int argc, char **argv)
+ 	  if (argc - optind != 2)
+ 	    {
+ 	      if (argc - optind < 2)
+-		try_help ("missing operand after `%s'", argv[argc - 1]);
++		try_help ("missing operand after '%s'", argv[argc - 1]);
+ 	      else
+-		try_help ("extra operand `%s'", argv[optind + 2]);
++		try_help ("extra operand '%s'", argv[optind + 2]);
+ 	    }
+ 
+ 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+@@ -840,7 +840,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -876,7 +876,7 @@ static char const * const option_help_msgid[] = {
+   N_("-T, --initial-tab             make tabs line up by prepending a tab"),
+   N_("    --tabsize=NUM             tab stops every NUM (default 8) print columns"),
+   N_("    --suppress-blank-empty    suppress space or tab before empty output lines"),
+-  N_("-l, --paginate                pass output through `pr' to paginate it"),
++  N_("-l, --paginate                pass output through 'pr' to paginate it"),
+   "",
+   N_("-r, --recursive                 recursively compare any subdirectories found"),
+   N_("    --no-dereference            don't follow symbolic links"),
+@@ -906,13 +906,13 @@ static char const * const option_help_msgid[] = {
+   N_("    --binary                    read and write data in binary mode"),
+ #endif
+   "",
+-  N_("-D, --ifdef=NAME                output merged file with `#ifdef NAME' diffs"),
++  N_("-D, --ifdef=NAME                output merged file with '#ifdef NAME' diffs"),
+   N_("    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"),
+   N_("    --line-format=LFMT          format all input lines with LFMT"),
+   N_("    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"),
+   N_("  These format options provide fine-grained control over the output\n"
+      "    of diff, generalizing -D/--ifdef."),
+-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
++  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+   N_("  GFMT (only) may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+@@ -942,9 +942,9 @@ static char const * const option_help_msgid[] = {
+   N_("    --help               display this help and exit"),
+   N_("-v, --version            output version information and exit"),
+   "",
+-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+   N_("If --from-file or --to-file is given, there are no restrictions on FILE(s)."),
+-  N_("If a FILE is `-', read standard input."),
++  N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+ };
+@@ -989,7 +989,7 @@ specify_value (char const **var, char const *value, char const *option)
+ {
+   if (*var && ! STREQ (*var, value))
+     {
+-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
++      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+     }
+   *var = value;
+@@ -1191,7 +1191,7 @@ compare_files (struct comparison const *parent,
+ 	= find_dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+-	fatal ("cannot compare `-' to a directory");
++	fatal ("cannot compare '-' to a directory");
+ 
+       if ((no_dereference_symlinks
+ 	   ? lstat (filename, &cmp.file[dir_arg].stat)
+diff --git a/src/diff.h b/src/diff.h
+index 05029a3..4b6595c 100644
+--- a/src/diff.h
++++ b/src/diff.h
+@@ -61,7 +61,7 @@ enum output_style
+   /* Output the differences in a unified context diff format (-u).  */
+   OUTPUT_UNIFIED,
+ 
+-  /* Output the differences as commands suitable for `ed' (-e).  */
++  /* Output the differences as commands suitable for 'ed' (-e).  */
+   OUTPUT_ED,
+ 
+   /* Output the diff as a forward ed script (-f).  */
+@@ -139,7 +139,7 @@ XTERN bool ignore_file_name_case;
+    (--no-dereference).  */
+ XTERN bool no_dereference_symlinks;
+ 
+-/* File labels for `-c' output headers (--label).  */
++/* File labels for '-c' output headers (--label).  */
+ XTERN char *file_label[2];
+ 
+ /* Regexp to identify function-header lines (-F).  */
+@@ -215,8 +215,8 @@ XTERN bool minimal;
+ /* The strftime format to use for time strings.  */
+ XTERN char const *time_format;
+ 
+-/* The result of comparison is an "edit script": a chain of `struct change'.
+-   Each `struct change' represents one place where some lines are deleted
++/* The result of comparison is an "edit script": a chain of 'struct change'.
++   Each 'struct change' represents one place where some lines are deleted
+    and some are inserted.
+ 
+    LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+diff --git a/src/diff3.c b/src/diff3.c
+index 7d8a9a5..3b01071 100644
+--- a/src/diff3.c
++++ b/src/diff3.c
+@@ -34,7 +34,7 @@
+ #include <xalloc.h>
+ #include <xfreopen.h>
+ 
+-/* The official name of this program (e.g., no `g' prefix).  */
++/* The official name of this program (e.g., no 'g' prefix).  */
+ #define PROGRAM_NAME "diff3"
+ 
+ #define AUTHORS \
+@@ -158,7 +158,7 @@ static bool overlap_only;
+ /* If nonzero, show information for DIFF_2ND diffs.  */
+ static bool show_2nd;
+ 
+-/* If nonzero, include `:wq' at the end of the script
++/* If nonzero, include ':wq' at the end of the script
+    to write out the file being edited.   */
+ static bool finalwrite;
+ 
+@@ -315,9 +315,9 @@ main (int argc, char **argv)
+   if (argc - optind != 3)
+     {
+       if (argc - optind < 3)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 3]);
++	try_help ("extra operand '%s'", argv[optind + 3]);
+     }
+ 
+   file = &argv[optind];
+@@ -350,7 +350,7 @@ main (int argc, char **argv)
+ 	 file instead.  */
+       common = 3 - common;
+       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+-	fatal ("`-' specified for more than one input file");
++	fatal ("'-' specified for more than one input file");
+     }
+ 
+   mapping[0] = 0;
+@@ -411,7 +411,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -433,7 +433,7 @@ static char const * const option_help_msgid[] = {
+   N_("-3, --easy-only             like -e, but incorporate only nonoverlapping changes"),
+   N_("-x, --overlap-only          like -e, but incorporate only overlapping changes"),
+   N_("-X                          like -x, but bracket conflicts"),
+-  N_("-i                          append `w' and `q' commands to ed scripts"),
++  N_("-i                          append 'w' and 'q' commands to ed scripts"),
+   "",
+   N_("-m, --merge                 output actual merged file, according to\n"
+      "                                -A if no other options are given"),
+@@ -478,7 +478,7 @@ Finally, the -m (--merge) option causes diff3 to do the merge internally\n\
+ and output the actual merged file.  For unusual input, this is more\n\
+ robust than using ed.\n"), stdout);
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -1293,12 +1293,12 @@ read_diff (char const *filea,
+   if (EXIT_TROUBLE <= status)
+     error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+-	     ? "subsidiary program `%s' could not be invoked"
++	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+-	     ? "subsidiary program `%s' not found"
++	     ? "subsidiary program '%s' not found"
+ 	     : status == INT_MAX
+-	     ? "subsidiary program `%s' failed"
+-	     : "subsidiary program `%s' failed (exit status %d)"),
++	     ? "subsidiary program '%s' failed"
++	     : "subsidiary program '%s' failed (exit status %d)"),
+ 	   diff_program, status);
+ 
+   return diff_result + total;
+@@ -1493,7 +1493,7 @@ undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+    around the problems involved with changing line numbers in an ed
+    script.
+ 
+-   As in `output_diff3', the variable MAPPING maps from file number
++   As in 'output_diff3', the variable MAPPING maps from file number
+    according to the argument list to file number according to the diff
+    passed.  All files listed below are in terms of the argument list.
+    REV_MAPPING is the inverse of MAPPING.
+diff --git a/src/dir.c b/src/dir.c
+index 2fbaf4b..57134c7 100644
+--- a/src/dir.c
++++ b/src/dir.c
+@@ -85,7 +85,7 @@ dir_read (struct file_data const *dir, struct dirdata *dirdata)
+       dirdata->data = data = xmalloc (data_alloc);
+ 
+       /* Read the directory entries, and insert the subfiles
+-	 into the `data' table.  */
++	 into the 'data' table.  */
+ 
+       while ((errno = 0, (next = readdir (reading)) != 0))
+ 	{
+@@ -126,7 +126,7 @@ dir_read (struct file_data const *dir, struct dirdata *dirdata)
+ #endif
+     }
+ 
+-  /* Create the `names' table from the `data' table.  */
++  /* Create the 'names' table from the 'data' table.  */
+   if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+     xalloc_die ();
+   dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+@@ -155,7 +155,7 @@ compare_names (char const *name1, char const *name2)
+ 	r = strcoll (name1, name2);
+       if (errno)
+ 	{
+-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+ 		 name1, name2);
+ 	  longjmp (failed_locale_specific_sorting, 1);
+ 	}
+@@ -235,7 +235,7 @@ diff_dirs (struct comparison const *cmp,
+ 	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+ 	       compare_names_for_qsort);
+ 
+-      /* If `-S name' was given, and this is the topmost level of comparison,
++      /* If '-S name' was given, and this is the topmost level of comparison,
+ 	 ignore all file names less than the specified starting name.  */
+ 
+       if (starting_file && ! cmp->parent)
+diff --git a/src/ifdef.c b/src/ifdef.c
+index 7251085..94f170b 100644
+--- a/src/ifdef.c
++++ b/src/ifdef.c
+@@ -132,7 +132,7 @@ format_group (register FILE *out, char const *format, char endchar,
+ 	    break;
+ 
+ 	  case '(':
+-	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
++	    /* Print if-then-else format e.g. '%(n=1?thenpart:elsepart)'.  */
+ 	    {
+ 	      int i;
+ 	      uintmax_t value[2];
+diff --git a/src/io.c b/src/io.c
+index 722cdf0..5a631a5 100644
+--- a/src/io.c
++++ b/src/io.c
+@@ -57,10 +57,10 @@ static size_t nbuckets;
+    The number of an equivalence class is its index in this array.  */
+ static struct equivclass *equivs;
+ 
+-/* Index of first free element in the array `equivs'.  */
++/* Index of first free element in the array 'equivs'.  */
+ static lin equivs_index;
+ 
+-/* Number of elements allocated in the array `equivs'.  */
++/* Number of elements allocated in the array 'equivs'.  */
+ static lin equivs_alloc;
+ 
+ /* Read a block of data into a file buffer, checking for EOF and error.  */
+diff --git a/src/sdiff.c b/src/sdiff.c
+index a77b36b..e1bb117 100644
+--- a/src/sdiff.c
++++ b/src/sdiff.c
+@@ -35,7 +35,7 @@
+ #include <version-etc.h>
+ #include <xalloc.h>
+ 
+-/* The official name of this program (e.g., no `g' prefix).  */
++/* The official name of this program (e.g., no 'g' prefix).  */
+ #define PROGRAM_NAME "sdiff"
+ 
+ #define AUTHORS \
+@@ -91,7 +91,7 @@ static int const sigs[] = {
+ };
+ 
+ #if HAVE_SIGACTION
+-  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
++  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
+   static struct sigaction initial_action[NUM_SIGS];
+ # define initial_handler(i) (initial_action[i].sa_handler)
+   static void signal_handler (int, void (*) (int));
+@@ -152,7 +152,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -213,7 +213,7 @@ Mandatory arguments to long options are mandatory for short options too.\n\
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -269,12 +269,12 @@ check_child_status (int werrno, int wstatus, int max_ok_status,
+     {
+       error (0, werrno,
+ 	     _(status == 126
+-	       ? "subsidiary program `%s' could not be invoked"
++	       ? "subsidiary program '%s' could not be invoked"
+ 	       : status == 127
+-	       ? "subsidiary program `%s' not found"
++	       ? "subsidiary program '%s' not found"
+ 	       : status == INT_MAX
+-	       ? "subsidiary program `%s' failed"
+-	       : "subsidiary program `%s' failed (exit status %d)"),
++	       ? "subsidiary program '%s' failed"
++	       : "subsidiary program '%s' failed (exit status %d)"),
+ 	     subsidiary_program, status);
+       exiterr ();
+     }
+@@ -559,9 +559,9 @@ main (int argc, char *argv[])
+   if (argc - optind != 2)
+     {
+       if (argc - optind < 2)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 2]);
++	try_help ("extra operand '%s'", argv[optind + 2]);
+     }
+ 
+   if (! output)
+@@ -706,7 +706,7 @@ main (int argc, char *argv[])
+ 	exit (WEXITSTATUS (wstatus));
+       }
+     }
+-  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
++  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
+ }
+ 
+ static void
+diff --git a/src/side.c b/src/side.c
+index 19958b4..076b898 100644
+--- a/src/side.c
++++ b/src/side.c
+@@ -292,7 +292,7 @@ print_sdiff_hunk (struct change *hunk)
+       fprintf (outfile, "c%ld,%ld\n", len0, len1);
+     }
+ 
+-  /* Print ``xxx  |  xxx '' lines */
++  /* Print "xxx  |  xxx " lines.  */
+   if (changes == CHANGED)
+     {
+       for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+@@ -302,7 +302,7 @@ print_sdiff_hunk (struct change *hunk)
+       next1 = first1 = j;
+     }
+ 
+-  /* Print ``     >  xxx '' lines */
++  /* Print "     >  xxx " lines.  */
+   if (changes & NEW)
+     {
+       for (j = first1; j <= last1; ++j)
+@@ -310,7 +310,7 @@ print_sdiff_hunk (struct change *hunk)
+       next1 = j;
+     }
+ 
+-  /* Print ``xxx  <     '' lines */
++  /* Print "xxx  <     " lines.  */
+   if (changes & OLD)
+     {
+       for (i = first0; i <= last0; ++i)
+diff --git a/src/system.h b/src/system.h
+index 9919d68..2767b57 100644
+--- a/src/system.h
++++ b/src/system.h
+@@ -20,14 +20,14 @@
+ 
+ #include <config.h>
+ 
+-/* Use this to suppress gcc's `...may be used before initialized' warnings. */
++/* Use this to suppress gcc's "...may be used before initialized" warnings. */
+ #ifdef lint
+ # define IF_LINT(Code) Code
+ #else
+ # define IF_LINT(Code) /* empty */
+ #endif
+ 
+-/* Define `__attribute__' and `volatile' first
++/* Define '__attribute__' and 'volatile' first
+    so that they're used consistently in all system includes.  */
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+ # define __attribute__(x)
+@@ -99,7 +99,7 @@ int strcasecmp (char const *, char const *);
+    - It's typically faster.
+    POSIX 1003.1-2001 says that only '0' through '9' are digits.
+    Prefer ISDIGIT to isdigit unless it's important to use the locale's
+-   definition of `digit' even when the host does not conform to POSIX.  */
++   definition of 'digit' even when the host does not conform to POSIX.  */
+ #define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+ 
+ #include <errno.h>
+diff --git a/src/util.c b/src/util.c
+index 16638a3..2b0bbbf 100644
+--- a/src/util.c
++++ b/src/util.c
+@@ -27,7 +27,7 @@
+ char const pr_program[] = PR_PROGRAM;
+ 
+ /* Queue up one-line messages to be printed at the end,
+-   when -l is specified.  Each message is recorded with a `struct msg'.  */
++   when -l is specified.  Each message is recorded with a 'struct msg'.  */
+ 
+ struct msg
+ {
+@@ -121,7 +121,7 @@ message5 (char const *format_msgid, char const *arg1, char const *arg2,
+     }
+ }
+ 
+-/* Output all the messages that were saved up by calls to `message'.  */
++/* Output all the messages that were saved up by calls to 'message'.  */
+ 
+ void
+ print_message_queue (void)
+@@ -146,8 +146,8 @@ print_message_queue (void)
+    to set up OUTFILE, the stdio stream for the output to go to.
+ 
+    Usually, OUTFILE is just stdout.  But when -l was specified
+-   we fork off a `pr' and make OUTFILE a pipe to it.
+-   `pr' then outputs to our stdout.  */
++   we fork off a 'pr' and make OUTFILE a pipe to it.
++   'pr' then outputs to our stdout.  */
+ 
+ static char const *current_name0;
+ static char const *current_name1;
+@@ -190,7 +190,7 @@ begin_output (void)
+       if (fflush (stdout) != 0)
+ 	pfatal_with_name (_("write failed"));
+ 
+-      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
++      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
+       {
+ #if HAVE_WORKING_FORK
+ 	int pipes[2];
+@@ -241,7 +241,7 @@ begin_output (void)
+   else
+     {
+ 
+-      /* If -l was not specified, output the diff straight to `stdout'.  */
++      /* If -l was not specified, output the diff straight to 'stdout'.  */
+ 
+       outfile = stdout;
+ 
+@@ -270,7 +270,7 @@ begin_output (void)
+ }
+ 
+ /* Call after the end of output of diffs for one file.
+-   Close OUTFILE and get rid of the `pr' subfork.  */
++   Close OUTFILE and get rid of the 'pr' subfork.  */
+ 
+ void
+ finish_output (void)
+@@ -298,12 +298,12 @@ finish_output (void)
+       if (status)
+ 	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+-		 ? "subsidiary program `%s' could not be invoked"
++		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+-		 ? "subsidiary program `%s' not found"
++		 ? "subsidiary program '%s' not found"
+ 		 : status == INT_MAX
+-		 ? "subsidiary program `%s' failed"
+-		 : "subsidiary program `%s' failed (exit status %d)"),
++		 ? "subsidiary program '%s' failed"
++		 : "subsidiary program '%s' failed (exit status %d)"),
+ 	       pr_program, status);
+     }
+ 
+@@ -677,7 +677,7 @@ print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+ 
+ /* Look at a hunk of edit script and report the range of lines in each file
+    that it applies to.  HUNK is the start of the hunk, which is a chain
+-   of `struct change'.  The first and last line numbers of file 0 are stored in
++   of 'struct change'.  The first and last line numbers of file 0 are stored in
+    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+    Note that these are internal line numbers that count from 0.
+ 
+diff --git a/tests/help-version b/tests/help-version
+index 8eb313a..bc9edce 100755
+--- a/tests/help-version
++++ b/tests/help-version
+@@ -74,7 +74,7 @@ test "x$v" = "x$VERSION" \
+ for lang in C fr da; do
+   for i in $built_programs; do
+ 
+-    # Skip `test'; it doesn't accept --help or --version.
++    # Skip 'test'; it doesn't accept --help or --version.
+     test $i = test && continue;
+ 
+     # false fails even when invoked with --help or --version.
+@@ -84,7 +84,7 @@ for lang in C fr da; do
+       continue
+     fi
+ 
+-    # The just-built install executable is always named `ginstall'.
++    # The just-built install executable is always named 'ginstall'.
+     test $i = install && i=ginstall
+ 
+     # Make sure they exit successfully, under normal conditions.
+@@ -95,7 +95,7 @@ for lang in C fr da; do
+     grep "$PACKAGE_BUGREPORT" h-$i > /dev/null || fail=1
+     rm -f h-$i
+ 
+-    # Make sure they fail upon `disk full' error.
++    # Make sure they fail upon 'disk full' error.
+     if test -w /dev/full && test -c /dev/full; then
+       env $i --help    >/dev/full 2>/dev/null && fail=1
+       env $i --version >/dev/full 2>/dev/null && fail=1
+@@ -107,7 +107,7 @@ for lang in C fr da; do
+         : # ok
+       else
+         fail=1
+-        echo "*** $i: bad exit status \`$status' (expected $expected)," 1>&2
++        echo "*** $i: bad exit status '$status' (expected $expected)," 1>&2
+         echo "  with --help or --version output redirected to /dev/full" 1>&2
+       fi
+     fi
+@@ -139,7 +139,7 @@ chown_setup () { args=--version; }
+ mkfifo_setup () { args=--version; }
+ mknod_setup () { args=--version; }
+ # Punt on uptime, since it fails (e.g., failing to get boot time)
+-# on some systems, and we shouldn't let that stop `make check'.
++# on some systems, and we shouldn't let that stop 'make check'.
+ uptime_setup () { args=--version; }
+ 
+ # Create a file in the current directory, not in $TMPDIR.
+@@ -187,7 +187,7 @@ basename_setup () { args=$tmp_in; }
+ dirname_setup () { args=$tmp_in; }
+ expr_setup () { args=foo; }
+ 
+-# Punt, in case GNU `id' hasn't been installed yet.
++# Punt, in case GNU 'id' hasn't been installed yet.
+ groups_setup () { args=--version; }
+ 
+ pathchk_setup () { args=$tmp_in; }
-- 
2.14.2

